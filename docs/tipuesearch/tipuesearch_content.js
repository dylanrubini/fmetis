var tipuesearch = {"pages":[{"text":"Fortran METIS Interface Brief description This is a Fortran interface to the METIS software package for partitioning unstructured graphs, partitioning meshes, and computing fill-reducing orderings\nof sparse matrices. The interface makes use of the C interoperability features available in modern Fortran \n(i.e., Fortran 2003+) and provides a simple and safe way to call the original serial routines. License Further information METIS Home page METIS Manual (PDF) Developer Info Ivan Pribec","tags":"","loc":"index.html","title":" Fortran METIS Interface "},{"text":"This File Depends On sourcefile~~test_partgraphrecursive1.f90~~EfferentGraph sourcefile~test_partgraphrecursive1.f90 test_PartGraphRecursive1.f90 sourcefile~metis_interface.f90 metis_interface.f90 sourcefile~metis_interface.f90->sourcefile~test_partgraphrecursive1.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs test_PartGraphRecursive1 Source Code test_PartGraphRecursive1.f90 Source Code ! https://stackoverflow.com/questions/8155160/metis-with-fortran ! http://glaros.dtc.umn.edu/gkhome/node/799 program test_PartGraphRecursive1 use metis_interface , only : idx_t , METIS_PartGraphRecursive , METIS_OK implicit none integer ( idx_t ), parameter :: nvtxs = 15 ! number of vertices integer ( idx_t ), parameter :: nedgs = 22 ! number of edges integer ( idx_t ) :: xadj ( nvtxs + 1 ), adjncy ( 2 * nedgs ) ! adjacency arrays integer ( idx_t ) :: part ( nvtxs ) ! partiotion vector integer ( idx_t ) :: objval , ios write ( * , '(A)' ) \"TEST METIS_PartGraphRecursive 1\" !  0---1---2---3---4 !  |   |   |   |   | !  5---6---7---8---9 !  |   |   |   |   | ! 10--11--12--13--14 ! Note that we are using C-style numbering! xadj = [ 0 , 2 , 5 , 8 , 11 , 13 , 16 , 20 , 24 , 28 , 31 , 33 , 36 , 39 , 42 , 44 ] adjncy = [ 1 , 5 , 0 , 2 , 6 , 1 , 3 , 7 , 2 , 4 , 8 , 3 , 9 , 0 , 6 , 10 , 1 , 5 , 7 , 11 , 2 , 6 , 8 , 12 , 3 , 7 , 9 , 13 , 4 , 8 , 14 , 5 , 11 , 6 , 10 , 12 , 7 , 11 , 13 , 8 , 12 , 14 , 9 , 13 ] ios = METIS_PartGraphRecursive ( nvtxs , ncon = 1 , xadj = xadj , adjncy = adjncy , nparts = 2 , objval = objval , part = part ) if ( ios /= METIS_OK ) then write ( * , * ) \"METIS_PartGraphRecursive failed with error: \" , ios error stop 1 end if write ( * , '(A,I0)' ) \"objval = \" , objval write ( * , '(A,*(I1,:,1X))' ) \"part = \" , part end program","tags":"","loc":"sourcefile/test_partgraphrecursive1.f90.html","title":"test_PartGraphRecursive1.f90 – Fortran METIS Interface"},{"text":"This File Depends On sourcefile~~test_partmeshnodal1.f90~~EfferentGraph sourcefile~test_partmeshnodal1.f90 test_PartMeshNodal1.f90 sourcefile~metis_interface.f90 metis_interface.f90 sourcefile~metis_interface.f90->sourcefile~test_partmeshnodal1.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs test_PartMeshNodal1 Source Code test_PartMeshNodal1.f90 Source Code ! https://stackoverflow.com/questions/20006253/using-metis-libraries-in-fortran-code-the-basics ! http://glaros.dtc.umn.edu/gkhome/node/852 program test_PartMeshNodal1 use , intrinsic :: iso_c_binding , only : c_ptr , c_f_pointer use metis_interface , only : idx_t , METIS_SetDefaultOptions , METIS_PartMeshNodal , & METIS_MeshToNodal , METIS_Free , METIS_NOPTIONS , METIS_OK , METIS_OPTION_NUMBERING implicit none integer ( idx_t ), parameter :: ne = 3 ! number of elements integer ( idx_t ), parameter :: nn = 8 ! number of nodes integer ( idx_t ), parameter :: npel = 4 ! nodes per element integer ( idx_t ) :: eptr ( ne + 1 ) integer ( idx_t ) :: eind ( ne * npel ) integer ( idx_t ) :: epart ( ne ), npart ( nn ) integer ( idx_t ) :: options ( 0 : METIS_NOPTIONS - 1 ) integer ( idx_t ) :: ios , objval type ( c_ptr ) :: c_xadj , c_adjncy integer ( idx_t ), pointer :: xadj (:) => null (), adjncy (:) => null () write ( * , '(A)' ) \"TEST METIS_PartMeshNodal 1\" ! 0---1---4---6 ! | 0 | 1 | 2 | ! 3---2---5---7 eptr = [ 0 , 4 , 8 , 12 ] eind = [ 0 , 1 , 2 , 3 , 1 , 4 , 5 , 2 , 4 , 6 , 7 , 5 ] ios = METIS_SetDefaultOptions ( options ) if ( ios /= METIS_OK ) then write ( * , * ) \"METIS_SetDefaultOptions failed with error: \" , ios error stop 1 end if options ( METIS_OPTION_NUMBERING ) = 0 ! C-style numbering ios = METIS_PartMeshNodal ( ne , nn , eptr , eind , nparts = 2 , options = options ,& objval = objval , epart = epart , npart = npart ) if ( ios /= METIS_OK ) then write ( * , * ) \"METIS_PartMeshNodal failed with error: \" , ios error stop 1 end if write ( * , '(A,I0)' ) \"objval = \" , objval write ( * , '(A,*(I1,:,1X))' ) \"epart = \" , epart write ( * , '(A,*(I1,:,1X))' ) \"npart = \" , npart ios = METIS_MeshToNodal ( ne , nn , eptr , eind , numflag = 0 , xadj = c_xadj , adjncy = c_adjncy ) if ( ios /= METIS_OK ) then write ( * , * ) \"METIS_MeshToNodal failed with error: \" , ios error stop 1 end if call c_f_pointer ( c_xadj , xadj , shape = [ nn + 1 ]) ! size of adjacency list is one more than number of nodes call c_f_pointer ( c_adjncy , adjncy , shape = [ xadj ( nn + 1 )]) ! size of edge list is in the last element of xadj write ( * , '(A,*(I0,:,1X))' ) \"xadj = \" , xadj write ( * , '(A,*(I1,:,1X))' ) \"adjncy = \" , adjncy ! call write_graph(\"test1.graph\",xadj,adjncy,1) ios = METIS_Free ( c_xadj ); xadj => null () if ( ios /= METIS_OK ) then write ( * , * ) \"METIS_Free failed with error: \" , ios error stop 1 end if ios = METIS_Free ( c_adjncy ); adjncy => null () if ( ios /= METIS_OK ) then write ( * , * ) \"METIS_Free failed with error: \" , ios error stop 1 end if end program","tags":"","loc":"sourcefile/test_partmeshnodal1.f90.html","title":"test_PartMeshNodal1.f90 – Fortran METIS Interface"},{"text":"This File Depends On sourcefile~~test_partgraphkway.f90~~EfferentGraph sourcefile~test_partgraphkway.f90 test_PartGraphKway.f90 sourcefile~metis_interface.f90 metis_interface.f90 sourcefile~metis_interface.f90->sourcefile~test_partgraphkway.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs test_PartGraphKway Source Code test_PartGraphKway.f90 Source Code !>  Partition a graph specified by a matrix ! !   Source: http://people.eecs.berkeley.edu/~demmel/cs267/lecture18/lecture18.html ! program test_PartGraphKway use metis_interface , only : idx_t , METIS_PartGraphKway , METIS_SetDefaultOptions , & METIS_NOPTIONS , METIS_OPTION_NUMBERING , METIS_OK implicit none integer ( idx_t ), parameter :: npart = 3 ! number of partitions integer ( idx_t ), parameter :: n = 8 ! number of nodes integer ( idx_t ), parameter :: m = 10 ! number of edges integer ( idx_t ) :: xadj ( n + 1 ), adjncy ( 2 * m ) ! graph adjacency structure integer ( idx_t ) :: part ( n ) integer ( idx_t ) :: options ( 0 : METIS_NOPTIONS - 1 ), ios , objval write ( * , '(A)' ) \"TEST METIS_PartGraphKway\" !    1  2  3  4  5  6  7  8 !  | a  a  a     a          | 1 !  | a  a     a  a          | 2 !  | b     b        b       | 3 !  |    b     b     b       | 4 !  | a  a           a     a | 5 !  |       b  b  b          | 6 !  |                   c  c | 7 !  |             c     c  c | 8 xadj = [ 1 , 4 , 7 , 9 , 11 , 15 , 18 , 19 , 21 ] adjncy = [ 2 , 3 , 5 ,& 1 , 4 , 5 ,& 1 , 6 ,& 2 , 6 ,& 1 , 2 , 6 , 8 ,& 3 , 4 , 5 ,& 8 ,& 5 , 7 ] ios = METIS_SetDefaultOptions ( options ) if ( ios /= METIS_OK ) then write ( * , * ) \"METIS_SetDefaultOptions failed with error: \" , ios error stop 1 end if options ( METIS_OPTION_NUMBERING ) = 1 ! Fortran-style numbering ios = METIS_PartGraphKway ( n , ncon = 1 , xadj = xadj , adjncy = adjncy , nparts = npart , options = options , objval = objval , part = part ) if ( ios /= METIS_OK ) then write ( * , * ) \"METIS_PartGraphKway failed with error: \" , ios error stop 1 end if write ( * , '(A,I0)' ) \"objval = \" , objval write ( * , '(A,*(I1,:,1X))' ) \"part = \" , part end program","tags":"","loc":"sourcefile/test_partgraphkway.f90.html","title":"test_PartGraphKway.f90 – Fortran METIS Interface"},{"text":"This File Depends On sourcefile~~test_partmeshnodal2.f90~~EfferentGraph sourcefile~test_partmeshnodal2.f90 test_PartMeshNodal2.f90 sourcefile~metis_interface.f90 metis_interface.f90 sourcefile~metis_interface.f90->sourcefile~test_partmeshnodal2.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs test_PartMeshNodal2 Source Code test_PartMeshNodal2.f90 Source Code !>  Example of partitioning a mesh composed of 4 quadrilaterals and 9 nodes !   based upon its nodal graph. ! !   Source: https://www.cfd-online.com/Forums/main/112366-using-metis-functions-fortran.html#post404734 ! program test_PartMeshNodal2 use metis_interface , only : idx_t , METIS_SetDefaultOptions , METIS_PartMeshNodal , METIS_NOPTIONS , & METIS_OPTION_NUMBERING , METIS_OPTION_CONTIG , METIS_OK implicit none integer ( idx_t ), parameter :: ne = 4 ! number of elements integer ( idx_t ), parameter :: nn = 9 ! number of nodes integer ( idx_t ) :: eptr ( ne + 1 ), eind ( 4 * ne ) ! arrays storing mesh structure integer ( idx_t ) :: epart ( ne ), npart ( nn ) ! element and node partition vectors integer ( idx_t ) :: opts ( 0 : METIS_NOPTIONS - 1 ), ios , objval write ( * , '(A)' ) \"TEST METIS_PartMeshNodal2\" !  1---2---5 !  | 1 | 2 | !  4---3---6 !  | 4 | 3 | !  9---8---7 eptr = [ 1 , 5 , 9 , 13 , 17 ] eind = [ 1 , 2 , 3 , 4 ,& 2 , 5 , 6 , 3 ,& 3 , 6 , 7 , 8 ,& 4 , 3 , 8 , 9 ] ios = METIS_SetDefaultOptions ( opts ) if ( ios /= METIS_OK ) then write ( * , * ) \"METIS_SetDefaultOptions failed with error: \" , ios error stop 1 end if opts ( METIS_OPTION_NUMBERING ) = 1 ! Fortran-style numbering opts ( METIS_OPTION_CONTIG ) = 1 ! Force contigous partitions ! call print_metis_options(opts) ios = METIS_PartMeshNodal ( ne , nn , eptr , eind , nparts = 2 , options = opts , & objval = objval , epart = epart , npart = npart ) if ( ios /= METIS_OK ) then write ( * , * ) \"METIS_PartMeshNodal failed with error: \" , ios error stop 1 end if write ( * , '(A,I0)' ) \"objval = \" , objval write ( * , '(A,*(I1,:,1X))' ) \"epart = \" , epart write ( * , '(A,*(I1,:,1X))' ) \"npart = \" , npart end program","tags":"","loc":"sourcefile/test_partmeshnodal2.f90.html","title":"test_PartMeshNodal2.f90 – Fortran METIS Interface"},{"text":"This File Depends On sourcefile~~test_partgraphrecursive2.f90~~EfferentGraph sourcefile~test_partgraphrecursive2.f90 test_PartGraphRecursive2.f90 sourcefile~metis_interface.f90 metis_interface.f90 sourcefile~metis_interface.f90->sourcefile~test_partgraphrecursive2.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs test_PartGraphRecursive2 Source Code test_PartGraphRecursive2.f90 Source Code !>  Partitioning a graph with non-equal number of edges per node. ! program test_PartGraphRecursive2 use metis_interface , only : idx_t , METIS_PartGraphRecursive , METIS_SetDefaultOptions , & METIS_NOPTIONS , METIS_OPTION_NUMBERING , METIS_OK integer ( idx_t ) :: n , m integer ( idx_t ), allocatable :: xadj (:), adjncy (:), part (:) integer ( idx_t ) :: options ( 0 : METIS_NOPTIONS - 1 ), ios , ncon , objval write ( * , '(A)' ) \"TEST METIS_PartGraphRecursive 2\" !   1---5 !   |\\ / \\ !   | 3   6 !   |/ \\ / \\ !   2---4---7 xadj = [ 1 , 4 , 7 , 11 , 15 , 18 , 21 , 23 ] adjncy = [ 5 , 3 , 2 , 1 , 3 , 4 , 5 , 4 , 2 , 1 , 2 , 3 , 6 , 7 , 1 , 3 , 6 , 5 , 4 , 7 , 6 , 4 ] n = size ( xadj ) - 1 m = size ( adjncy ) / 2 write ( * , '(A,I0)' ) \"n = \" , n write ( * , '(A,I0)' ) \"m = \" , m ios = METIS_SetDefaultOptions ( options ) if ( ios /= METIS_OK ) then write ( * , * ) \"METIS_SetDefaultOptions failed with error: \" , ios error stop 1 end if options ( METIS_OPTION_NUMBERING ) = 1 ! Fortran-style numbering ncon = 1 allocate ( part ( n )) ios = METIS_PartGraphRecursive ( n , ncon , xadj , adjncy ,& nparts = 2 , objval = objval , part = part , options = options ) if ( ios /= METIS_OK ) then write ( * , * ) \"METIS_PartGraphKway failed with error: \" , ios error stop 1 end if write ( * , '(A,I0)' ) \"objval = \" , objval write ( * , '(A,*(I1,:,1X))' ) \"part = \" , part end program","tags":"","loc":"sourcefile/test_partgraphrecursive2.f90.html","title":"test_PartGraphRecursive2.f90 – Fortran METIS Interface"},{"text":"This File Depends On sourcefile~~test_nodend.f90~~EfferentGraph sourcefile~test_nodend.f90 test_NodeND.f90 sourcefile~metis_interface.f90 metis_interface.f90 sourcefile~metis_interface.f90->sourcefile~test_nodend.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs test_NodeND Source Code test_NodeND.f90 Source Code !>  Example of computing a fill-reducing ordering of a sparse matrix ! !   Source: http://comp.lang.fortran.narkive.com/uFmDM7Bo/how-to-call-a-metis-subroutine-from-my-fortran-code ! program test_NodeND use metis_interface , only : idx_t , METIS_SetDefaultOptions , METIS_NodeND , & METIS_NOPTIONS , METIS_OK , METIS_OPTION_NUMBERING implicit none integer ( idx_t ), parameter :: n = 15 ! number of vertices integer ( idx_t ), parameter :: m = 22 ! number of edges integer ( idx_t ) :: xadj ( n + 1 ), adjncy ( 2 * m ) ! graph adjacency structure integer ( idx_t ) :: perm ( n ), iperm ( n ) ! fill-reducing permutation and inverse permutation integer ( idx_t ) :: options ( 0 : METIS_NOPTIONS - 1 ), ios write ( * , '(A)' ) \"TEST METIS_NodeND\" !  1---2---3---4---5 !  |   |   |   |   | !  6---7---8---9---10 !  |   |   |   |   | !  11--12--13--14--15 xadj = [ 1 , 3 , 6 , 9 , 12 , 14 , 17 , 21 , 25 , 29 , 32 , 34 , 37 , 40 , 43 , 45 ] adjncy = [ 2 , 6 , 1 , 3 , 7 , 2 , 4 , 8 , 3 , 5 , 9 , 4 , 10 , 1 , 7 , 11 , 2 , 6 , & 8 , 12 , 3 , 7 , 9 , 13 , 4 , 8 , 10 , 14 , 5 , 9 , 15 , 6 , 12 , 7 , 11 , 13 , & 8 , 12 , 14 , 9 , 13 , 15 , 10 , 14 ] ios = METIS_SetDefaultOptions ( options ) if ( ios /= METIS_OK ) then write ( * , * ) \"METIS_SetDefaultOptions failed with error: \" , ios error stop 1 end if options ( METIS_OPTION_NUMBERING ) = 1 ! Fortran-style numbering ios = METIS_NodeND ( n , xadj , adjncy , options = options , perm = perm , iperm = iperm ) if ( ios /= METIS_OK ) then write ( * , * ) \"METIS_NodeND failed with error: \" , ios error stop 1 end if write ( * , '(A,*(I2,:,1X))' ) \"perm  = \" , perm write ( * , '(A,*(I2,:,1X))' ) \"iperm = \" , iperm end program","tags":"","loc":"sourcefile/test_nodend.f90.html","title":"test_NodeND.f90 – Fortran METIS Interface"},{"text":"Files Dependent On This One sourcefile~~metis_interface.f90~~AfferentGraph sourcefile~metis_interface.f90 metis_interface.f90 sourcefile~test_partgraphrecursive1.f90 test_PartGraphRecursive1.f90 sourcefile~metis_interface.f90->sourcefile~test_partgraphrecursive1.f90 sourcefile~metis_oo_interface.f90 metis_oo_interface.f90 sourcefile~metis_interface.f90->sourcefile~metis_oo_interface.f90 sourcefile~test_partmeshnodal1.f90 test_PartMeshNodal1.f90 sourcefile~metis_interface.f90->sourcefile~test_partmeshnodal1.f90 sourcefile~test_partgraphkway.f90 test_PartGraphKway.f90 sourcefile~metis_interface.f90->sourcefile~test_partgraphkway.f90 sourcefile~test_partmeshnodal2.f90 test_PartMeshNodal2.f90 sourcefile~metis_interface.f90->sourcefile~test_partmeshnodal2.f90 sourcefile~test_partgraphrecursive2.f90 test_PartGraphRecursive2.f90 sourcefile~metis_interface.f90->sourcefile~test_partgraphrecursive2.f90 sourcefile~test_nodend.f90 test_NodeND.f90 sourcefile~metis_interface.f90->sourcefile~test_nodend.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules metis_interface Source Code metis_interface.f90 Source Code ! metis_interface.f90 -- Fortran METIS Interface ! ! Copyright 2019 Ivan Pribec <ivan.pribec@gmail.com> ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !***************************************************************************************** !> author: Ivan Pribec !  date: 7/2019 ! ! A Fortran interface to the METIS graph partitioning library. ! ! http://glaros.dtc.umn.edu/gkhome/node/877 ! module metis_interface use iso_c_binding , only : c_int32_t , c_int64_t , c_float , c_double , c_ptr implicit none private ! ! Width of elementary data types (should match those of metis.h) ! integer , parameter , public :: idx_t = c_int32_t ! <--- modify integer size here (c_int32_t or c_int64_t) integer , parameter , public :: real_t = c_float ! <--- modify real size here (c_float or c_double) ! ! Number of METIS options ! integer ( kind = idx_t ), parameter , public :: METIS_NOPTIONS = 40 !! Number of METIS OPTIONS ! ! ! Enum type definitions ! ! Return codes integer ( kind = idx_t ), parameter , public :: METIS_OK = 1 !! Returned normally. integer ( kind = idx_t ), parameter , public :: METIS_ERROR_INPUT = - 2 !! Returned due to erroneous inputs and/or options. integer ( kind = idx_t ), parameter , public :: METIS_ERROR_MEMORY = - 3 !! Returned due to insufficient memory. integer ( kind = idx_t ), parameter , public :: METIS_ERROR = - 4 !! Return status: some other type of error. ! Operation type codes ! integer(kind=idx_t), parameter, public :: METIS_OP_PMETIS = 0 ! integer(kind=idx_t), parameter, public :: METIS_OP_KMETIS = 1 ! integer(kind=idx_t), parameter, public :: METIS_OP_OMETIS = 2 ! Options codes (i.e., `options`) integer ( kind = idx_t ), parameter , public :: METIS_OPTION_PTYPE = 0 !! Specifies the partitioning method. integer ( kind = idx_t ), parameter , public :: METIS_OPTION_OBJTYPE = 1 !! Specifies the type of objective. integer ( kind = idx_t ), parameter , public :: METIS_OPTION_CTYPE = 2 !! Specifies the matching scheme to be used during coarsening. integer ( kind = idx_t ), parameter , public :: METIS_OPTION_IPTYPE = 3 !! Determines the algorithm used during initial partitioning. integer ( kind = idx_t ), parameter , public :: METIS_OPTION_RTYPE = 4 !! Determines the algorithm used for refinement. integer ( kind = idx_t ), parameter , public :: METIS_OPTION_DBGLVL = 5 !! Specifies the amount of progress/debugging information will be printed. integer ( kind = idx_t ), parameter , public :: METIS_OPTION_NITER = 6 !! Specifies the number of iterations for the refinement algorithm. integer ( kind = idx_t ), parameter , public :: METIS_OPTION_NCUTS = 7 !! Specifies the number of different partitionings that it will compute. integer ( kind = idx_t ), parameter , public :: METIS_OPTION_SEED = 8 !! Specifies the seed for the random number generator. integer ( kind = idx_t ), parameter , public :: METIS_OPTION_NO2HOP = 9 !! Specifies that the coarsening will not perform any 2–hop matchings when the standard matching approach fails to sufficiently coarsen the graph. integer ( kind = idx_t ), parameter , public :: METIS_OPTION_MINCONN = 10 !! Specifies that the partitioning routines should try to minimize the maximum degree of the subdomain graph. integer ( kind = idx_t ), parameter , public :: METIS_OPTION_CONTIG = 11 !! Specifies that the partitioning routines should try to produce partitions that are contigous. integer ( kind = idx_t ), parameter , public :: METIS_OPTION_COMPRESS = 12 !! Specifies that the graph should be compressed by combining together vertices that have identical adjacency lists. integer ( kind = idx_t ), parameter , public :: METIS_OPTION_CCORDER = 13 !! Specifies if the connected components of the graph should first be identifies and ordered separately. integer ( kind = idx_t ), parameter , public :: METIS_OPTION_PFACTOR = 14 !! Specifies the minimum degree of the vertices that will be ordered last. integer ( kind = idx_t ), parameter , public :: METIS_OPTION_NSEPS = 15 !! Specifies the number of different separators that it will compute at each level of nested dissection. integer ( kind = idx_t ), parameter , public :: METIS_OPTION_UFACTOR = 16 !! Specifies the maximum allowed load imbalance among the partitions. integer ( kind = idx_t ), parameter , public :: METIS_OPTION_NUMBERING = 17 !! Used to indicate which numbering scheme is used for the adjacency structure of a graph or the element-node structure of a mesh ! Partitioning Schemes integer ( kind = idx_t ), parameter , public :: METIS_PTYPE_RB = 0 !! Multilevel recursive bisectioning. integer ( kind = idx_t ), parameter , public :: METIS_PTYPE_KWAY = 1 !! Multilevel k-way partitioning. ! Graph types for meshes ! integer(kind=idx_t), parameter, public :: METIS_GTYPE_DUAL  = 0 ! integer(kind=idx_t), parameter, public :: METIS_GTYPE_NODAL = 1 ! Coarsening Schemes integer ( kind = idx_t ), parameter , public :: METIS_CTYPE_RM = 0 !! Random matching. integer ( kind = idx_t ), parameter , public :: METIS_CTYPE_SHEM = 1 !! Sorted heavy-edge matching. ! Initial partitioning schemes integer ( kind = idx_t ), parameter , public :: METIS_IPTYPE_GROW = 0 !! Grows a bisection using a greedy strategy. integer ( kind = idx_t ), parameter , public :: METIS_IPTYPE_RANDOM = 1 !! Computes a bisection at random followed by a refinement. integer ( kind = idx_t ), parameter , public :: METIS_IPTYPE_EDGE = 2 !! Derives a separator form an edge cut. integer ( kind = idx_t ), parameter , public :: METIS_IPTYPE_NODE = 3 !! Grows a bisection using a greedy node-based strategy. integer ( kind = idx_t ), parameter , public :: METIS_IPTYPE_METISRB = 4 ! Refinement schemes integer ( kind = idx_t ), parameter , public :: METIS_RTYPE_FM = 0 !! FM-based cut refinement. integer ( kind = idx_t ), parameter , public :: METIS_RTYPE_GREEDY = 1 !! Greedy-based cut and volume refinement. integer ( kind = idx_t ), parameter , public :: METIS_RTYPE_SEP2SIDED = 2 !! Two-sided node FM refinement. integer ( kind = idx_t ), parameter , public :: METIS_RTYPE_SEP1SIDED = 3 !! One-sided node FM refinement. ! Debug Levels integer ( kind = idx_t ), parameter , public :: METIS_DBG_INFO = 1 !! Shows various diagnostic messages. integer ( kind = idx_t ), parameter , public :: METIS_DBG_TIME = 2 !! Perform timing analysis. integer ( kind = idx_t ), parameter , public :: METIS_DBG_COARSEN = 4 !! Show the coarsening progress. integer ( kind = idx_t ), parameter , public :: METIS_DBG_REFINE = 8 !! Show the refinement progress. integer ( kind = idx_t ), parameter , public :: METIS_DBG_IPART = 16 !! Show info on initial partitioning. integer ( kind = idx_t ), parameter , public :: METIS_DBG_MOVEINFO = 32 !! Show info on vertex moves during refinement. integer ( kind = idx_t ), parameter , public :: METIS_DBG_SEPINFO = 64 !! Show info on vertex moves during sep refinement. integer ( kind = idx_t ), parameter , public :: METIS_DBG_CONNINFO = 128 !! Show info on minimization of subdomain connectivity. integer ( kind = idx_t ), parameter , public :: METIS_DBG_CONTIGINFO = 256 !! Show info on elimination of connected components. integer ( kind = idx_t ), parameter , public :: METIS_DBG_MEMORY = 2048 !! Show info related to wspace allocation. ! Types of objectives integer ( kind = idx_t ), parameter , public :: METIS_OBJTYPE_CUT = 0 !! Edge-cut minimization. integer ( kind = idx_t ), parameter , public :: METIS_OBJTYPE_VOL = 1 !! Total communication volume minimization. integer ( kind = idx_t ), parameter , public :: METIS_OBJTYPE_NODE = 2 ! ! METIS API ! ! Graph partitioning routines public :: METIS_PartGraphRecursive public :: METIS_PartGraphKway ! Mesh partitioning routines public :: METIS_PartMeshDual public :: METIS_PartMeshNodal ! Sparse matrix reordering routines public :: METIS_NodeND ! Mesh-to-graph conversion routines public :: METIS_MeshToDual public :: METIS_MeshToNodal ! Utility routines public :: METIS_SetDefaultOptions public :: METIS_Free interface ! ! Graph partitioning routines ! !***************************************************************************************** !> This function is used to partition a graph into `nparts` parts using recursive bisection. ! !  If `tpwgt` is present, the *target partition weight* for the `i`-th partition and `j`-th constraint should !  be specified at `tpwgts(i*ncon+j)` (the numbering for both partitions and constraints starts from 0). !  For each constraint, the sum of the `tpwgts`entries must be 1.0. ! !  The following options are valid: <br /> !  `METIS_OPTION_CTYPE`, `METIS_OPTION_IPTYPE`, `METIS_OPTION_RTYPE`, !  `METIS_OPTION_NO2HOP`, `METIS_OPTION_NCUTS`, `METIS_OPTION_NITER`, !  `METIS_OPTION_SEED`, `METIS_OPTION_UFACTOR`, `METIS_OPTION_NUMBERING`, !  `METIS_OPTION_DBGLVL` ! function METIS_PartGraphRecursive ( nvtxs , ncon , xadj , adjncy ,& vwgt , vsize , adjwgt , nparts , tpwgts , ubvec , options , objval , part ) result ( ierr ) bind ( C , name = \"METIS_PartGraphRecursive\" ) import idx_t , real_t , METIS_NOPTIONS ! Parameters integer ( kind = idx_t ), intent ( in ) :: nvtxs !! The number of vertices in the graph. integer ( kind = idx_t ), intent ( in ) :: ncon !! The number of balancing constraints. It should be atleast 1. integer ( kind = idx_t ), intent ( in ), dimension ( * ) :: xadj , adjncy !! The adjacency structure of the graph as described in section 5.5 of the [manual](http://glaros.dtc.umn.edu/gkhome/fetch/sw/metis/manual.pdf). integer ( kind = idx_t ), intent ( in ), dimension ( * ), optional :: vwgt ! NULL !! The weights of the vertices as described in Section 5.5 of the [manual](http://glaros.dtc.umn.edu/gkhome/fetch/sw/metis/manual.pdf). integer ( kind = idx_t ), intent ( in ), dimension ( * ), optional :: vsize ! NULL !! The size of the vertices for computing the total communication volume as described in section 5.7 of the [manual](http://glaros.dtc.umn.edu/gkhome/fetch/sw/metis/manual.pdf). integer ( kind = idx_t ), intent ( in ), dimension ( * ), optional :: adjwgt ! NULL !! The weights of the edges as describe in Section 5.5 of the [manual](http://glaros.dtc.umn.edu/gkhome/fetch/sw/metis/manual.pdf). integer ( kind = idx_t ) , intent ( in ) :: nparts !! The number of parts to partition the graph. real ( kind = real_t ), intent ( in ), optional :: tpwgts ( nparts * ncon ) !! An array of size `nparts*ncon` that specifies the desired weight for each partition and constraint. !! If not present, the graph is divided equally among the partitions. More in the description. real ( kind = real_t ), intent ( in ), optional :: ubvec ( ncon ) !! An array of size `ncon` that specifies the allowed load imbalance for each constraint. !! For the `i`-th partition and `j`-th constraint the allowed weight is the `ubvec(j)*tpwgts(i*ncon+j)` !! fraction of the `j`-th's constraint total weight. If not present, the load imbalance !! tolerance is 1.001 (for `ncon = 1`) or 1.01 (for `ncon > 1`). integer ( kind = idx_t ), intent ( in ), optional :: options ( METIS_NOPTIONS ) !! An array of options as described in Section 5.4 of the METIS manual. See description for valid options. integer ( kind = idx_t ), intent ( out ) :: objval !! Upon successful completion, this variable stores the edge-cut or the total communication volume of the partitioning !! solution. The value returned depends on the partitioning's objective function. integer ( kind = idx_t ), intent ( out ) :: part ( nvtxs ) !! This is a vector of size `nvtxs` that upon successful completion stores the partition vector of the graph. !! The numbering of this vector starts from either 0 or 1, depending on the value of `options(METIS_OPTION_NUMBERING)`. ! Returns integer ( kind = idx_t ) :: ierr !! `METIS_OK` - Indicates that the function returned normally.<br /> !! `METIS_ERROR_INPUT` - Indicates an input error.<br /> !! `METIS_ERROR_MEMORY` - Indicates that it could not allocate the required memory.<br /> !! `METIS_ERROR` - Indicates some other type of error. end function !***************************************************************************************** !***************************************************************************************** !> This function is used to partition a graph into `nparts` parts using multilevel k-way partitioning. ! !  If `tpwgt` is present, the *target partition weight* for the `i`-th partition and `j`-th constraint should !  be specified at `tpwgts(i*ncon+j)` (the numbering for both partitions and constraints starts from 0). !  For each constraint, the sum of the `tpwgts`entries must be 1.0. ! !  The following options are valid: <br /> !  `METIS_OPTION_OBJTYPE`, `METIS_OPTION_CTYPE`, `METIS_OPTION_IPTYPE`, !  `METIS_OPTION_RTYPE`, `METIS_OPTION_NO2HOP`, `METIS_OPTION_NCUTS`, !  `METIS_OPTION_NITER`, `METIS_OPTION_UFACTOR`, `METIS_OPTION_MINCONN`, !  `METIS_OPTION_CONTIG`, `METIS_OPTION_SEED`, `METIS_OPTION_NUMBERING`, !  `METIS_OPTION_DBGLVL` ! function METIS_PartGraphKway ( nvtxs , ncon , xadj , adjncy ,& vwgt , vsize , adjwgt , nparts , tpwgts , ubvec , options , objval , part ) result ( ierr ) bind ( C , name = \"METIS_PartGraphKway\" ) import idx_t , real_t , METIS_NOPTIONS ! Parameters integer ( kind = idx_t ), intent ( in ) :: nvtxs !! The number of vertices in the graph. integer ( kind = idx_t ), intent ( in ) :: ncon !! The number of balancing constraints. It should be at least 1. integer ( kind = idx_t ), intent ( in ), dimension ( * ) :: xadj , adjncy !! The adjacency structure of the graph as described in section 5.5 of the [manual](http://glaros.dtc.umn.edu/gkhome/fetch/sw/metis/manual.pdf). integer ( kind = idx_t ), intent ( in ), dimension ( * ), optional :: vwgt !! The weights of the vertices as described in Section 5.5 of the [manual](http://glaros.dtc.umn.edu/gkhome/fetch/sw/metis/manual.pdf). integer ( kind = idx_t ), intent ( in ), dimension ( * ), optional :: vsize !! The size of the vertices for computing the total communication volume as described in section 5.7 of the [manual](http://glaros.dtc.umn.edu/gkhome/fetch/sw/metis/manual.pdf). integer ( kind = idx_t ), intent ( in ), dimension ( * ), optional :: adjwgt !! The weights of the edges as describe in Section 5.5 of the [manual](http://glaros.dtc.umn.edu/gkhome/fetch/sw/metis/manual.pdf). integer ( kind = idx_t ), intent ( in ) :: nparts !! The number of parts to partition the graph. real ( kind = real_t ), intent ( in ), optional :: tpwgts ( nparts * ncon ) !! An array of size `nparts*ncon` that specifies the desired weight for each partition and constraint. !! If not present, the graph is divided equally among the partitions. More in the description. real ( kind = real_t ), intent ( in ), optional :: ubvec ( ncon ) !! An array of size `ncon` that specifiew the allowed load imbalance for each constraint. !! For the `i`-th partition and `j`-th constraint the allowed weight is the `ubvec(j)*tpwgts(i*ncon+j)` !! fraction of the `j`-th's constraint total weight. If not present, the load imbalance !! tolerance is 1.001 (for `ncon == 1`) or 1.01 (for `ncon > 1`). integer ( kind = idx_t ), intent ( in ), optional :: options ( METIS_NOPTIONS ) !! An array of options as described in Section 5.4 of the [manual](http://glaros.dtc.umn.edu/gkhome/fetch/sw/metis/manual.pdf). See description for valid options. integer ( kind = idx_t ), intent ( out ) :: objval !! Upon successful completion, this variable stores the edge-cut or the total communication volume of the partitioning !! solution. The value returned depends on the partitioning's objective function. integer ( kind = idx_t ), intent ( out ) :: part ( nvtxs ) !! This is a vector of size `nvtxs` that upon successful completion stores the partition vector of the graph. !! The numbering of this vector starts from either 0 or 1, depending on the value of `options(METIS_OPTION_NUMBERING)`. ! Returns integer ( kind = idx_t ) :: ierr !! `METIS_OK` - Indicates that the function returned normally.<br /> !! `METIS_ERROR_INPUT` - Indicates an input error.<br /> !! `METIS_ERROR_MEMORY` - Indicates that it could not allocate the required memory.<br /> !! `METIS_ERROR` - Indicates some other type of error. end function !***************************************************************************************** ! ! Mesh partitioning routines ! !***************************************************************************************** !> This function is used to partition a mesh into `nparts` parts based on a partitioning of the mesh's dual graph. ! !  The following options are valid: <br /> !  `METIS_OPTION_PTYPE`, `METIS_OPTION_OBJTYPE`, `METIS_OPTION_CTYPE`, !  `METIS_OPTION_IPTYPE`, `METIS_OPTION_RTYPE`, `METIS_OPTION_NCUTS`, !  `METIS_OPTION_NITER`, `METIS_OPTION_SEED`, `METIS_OPTION_UFACTOR`, !  `METIS_OPTION_NUMBERING`, `METIS_OPTION_DBGLVL` ! function METIS_PartMeshDual ( ne , nn , eptr , eind , vwgt , vsize , ncommon , & nparts , tpwgts , options , objval , epart , npart ) result ( ierr ) bind ( C , name = \"METIS_PartMeshDual\" ) import idx_t , METIS_NOPTIONS integer ( kind = idx_t ), intent ( in ) :: ne !! The number of elements in the mesh. integer ( kind = idx_t ), intent ( in ) :: nn !! The number of nodes in the mesh. integer ( kind = idx_t ), intent ( in ), dimension ( * ) :: eptr , eind !! The pair of arrays storing the mesh as described in Section 5.6 of the [manual](http://glaros.dtc.umn.edu/gkhome/fetch/sw/metis/manual.pdf). integer ( kind = idx_t ), intent ( in ), optional :: vwgt ( ne ) !! An array of size `ne` specifying the weights of the elements. If not present, !! all elements have an equal weight. integer ( kind = idx_t ), intent ( in ), optional :: vsize ( ne ) !! An array of size `ne` specifying the size of the elements that is used !! for computing the total comunication volume as described in Section 5.7 of the  [manual](http://glaros.dtc.umn.edu/gkhome/fetch/sw/metis/manual.pdf). !! If not present, the objective is cut or all elements have an equal size. integer ( kind = idx_t ), intent ( in ) :: ncommon integer ( kind = idx_t ), intent ( in ) :: nparts !! The number of parts to partition the mesh. integer ( kind = idx_t ), intent ( in ), optional :: tpwgts ( nparts ) !! An array of size `nparts` that specifies the desired weight for each partition. The *target !! partition weight* for the `i`-th partition is specified at `tpwgts(i)` (the numbering for the !! partitions starts from 0). The sum of the `tpwgts` entries must be 1.0. <br /> If not present, the graph !! is divided equally among the partitions. integer ( kind = idx_t ), intent ( in ), optional :: options ( METIS_NOPTIONS ) !! An array of options as described in Section 5.4 of the [manual](http://glaros.dtc.umn.edu/gkhome/fetch/sw/metis/manual.pdf). See description for valid options. integer ( kind = idx_t ), intent ( out ) :: objval !! Upon successful completion, this variable stores either the edgecut or the total communication !! volume of the dual graph's partitioning. integer ( kind = idx_t ), intent ( out ) :: epart ( ne ) !! A vector of size `ne` that upon successful completion stores the partition vector for the elements !! of the mesh. The numbering of this vector starts from either 0 or 1, depending on the value of !! `options(METIS_OPTION_NUMBERING)`. integer ( kind = idx_t ), intent ( out ) :: npart ( nn ) !! A vector of size `nn` that upon successful completion stores the partition vector for the nodes !! of the mesh. The numbering of this vector starts from either 0 or 1, depending on the value of !! `options(METIS_OPTION_NUMBERING)`. ! Returns integer ( kind = idx_t ) :: ierr !! `METIS_OK` - Indicates that the function returned normally.<br /> !! `METIS_ERROR_INPUT` - Indicates an input error.<br /> !! `METIS_ERROR_MEMORY` - Indicates that it could not allocate the required memory.<br /> !! `METIS_ERROR` - Indicates some other type of error. end function !***************************************************************************************** !***************************************************************************************** !> This function us used to partition a mesh into `nparts` parts based on a !  partitioning of the mesh's nodal graph. ! !  The following options are valid: <br /> !  `METIS_OPTION_PTYPE`, `METIS_OPTION_OBJTYPE`, `METIS_OPTION_CTYPE`, !  `METIS_OPTION_IPTYPE`, `METIS_OPTION_RTYPE`, `METIS_OPTION_NCUTS`, !  `METIS_OPTION_NITER`, `METIS_OPTION_SEED`, `METIS_OPTION_UFACTOR`, !  `METIS_OPTION_NUMBERING`, `METIS_OPTION_DBGLVL` ! function METIS_PartMeshNodal ( ne , nn , eptr , eind , vwgt , vsize , & nparts , tpwgts , options , objval , epart , npart ) result ( ierr ) bind ( C , name = \"METIS_PartMeshNodal\" ) import idx_t , METIS_NOPTIONS integer ( kind = idx_t ), intent ( in ) :: ne !! The number of elements in the mesh. integer ( kind = idx_t ), intent ( in ) :: nn !! The number of nodes in the mesh. integer ( kind = idx_t ), intent ( in ), dimension ( * ) :: eptr , eind !! The pair of arrays storing the mesh as described in Section 5.6 of the [manual](http://glaros.dtc.umn.edu/gkhome/fetch/sw/metis/manual.pdf). integer ( kind = idx_t ), intent ( in ), optional :: vwgt ( nn ) !! An array of size `nn` specifying weights of the nodes. If not passed, all nodes have an equal weight. integer ( kind = idx_t ), intent ( in ), optional :: vsize ( nn ) !! An array of size `nn` specifying the size of the nodes that is used for computing the !! total comunication volume as described in Section 5.7 of the [manual](http://glaros.dtc.umn.edu/gkhome/fetch/sw/metis/manual.pdf). If not passed, !! the objective is cut or all nodes have an equal size. integer ( kind = idx_t ), intent ( in ) :: nparts !! The number of parts to partition the mesh. integer ( kind = idx_t ), intent ( in ), optional :: tpwgts ( nparts ) !! An array of size `nparts` that specifies the desired weight for each partition. The *target !! partition weight* for the `i`-th partition is specified at `tpwgts(i)` (the numbering for the !! partitions starts from 0). The sum of the `tpwgts` entries must be 1.0. If not passed, the graph !! is divided equally among the partitions. integer ( kind = idx_t ), intent ( in ), optional :: options ( METIS_NOPTIONS ) !! An array of options as described in Section 5.4 of the [manual](http://glaros.dtc.umn.edu/gkhome/fetch/sw/metis/manual.pdf). See description for valid options. integer ( kind = idx_t ), intent ( out ) :: objval !! Upon successful completion, this variable stores either the edgecut or the total communication !! volume of the nodal graph's partitioning. integer ( kind = idx_t ), intent ( out ) :: epart ( ne ) !! A vector of size `ne` that upon successful completion stores the partition vector for the elements !! of the mesh. The numbering of this vector starts from either 0 or 1, depending on the value of !! `options(METIS_OPTION_NUMBERING)`. integer ( kind = idx_t ), intent ( out ) :: npart ( nn ) !! A vector of size `nn` that upon successful completion stores the partition vector for the nodes !! of the mesh. The numbering of this vector starts from either 0 or 1, depending on the value of !! `options(METIS_OPTION_NUMBERING)`. ! Returns integer ( kind = idx_t ) :: ierr !! `METIS_OK` - Indicates that the function returned normally.<br /> !! `METIS_ERROR_INPUT` - Indicates an input error.<br /> !! `METIS_ERROR_MEMORY` - Indicates that it could not allocate the required memory.<br /> !! `METIS_ERROR` - Indicates some other type of error. end function !***************************************************************************************** ! ! Sparse Matrix Reordering Routines ! !***************************************************************************************** !> This function computes fill reducing orderings of sparse matrices using the !  multilevel nested dissection algorithm. ! !  Let A be the original matrix and A' be the permuted matrix. The arrays !  `perm` and `iperm` are defined as follows. Row (column) `i` of A' is the !  `perm(i)` row (column) of A, and row (column) `i` of A is the `iperm(i)` !  row (column) of A'. the numbering of this vector starts from either 0 or 1, !  depending on the value of `options(METIS_OPTION_NUMBERING)`. ! !  If the graph is weighted, meaning `vgwt` was provided, the nested dissection ordering computes !  vertex separators that minimize the sum of the weights of the vertices on the separators. ! !  The following options are valid: <br /> !  `METIS_OPTION_CTYPE`, `METIS_OPTION_RTYPE`, `METIS_OPTION_NO2HOP`, !  `METIS_OPTION_NSEPS`, `METIS_OPTION_NITER`, `METIS_OPTION_UFACTOR`, !  `METIS_OPTION_COMPRESS`, `METIS_OPTION_CCORDER`, `METIS_OPTION_SEED`, !  `METIS_OPTION_PFACTOR`, `METIS_OPTION_NUMBERING`, `METIS_OPTION_DBGLVL` ! !#Example ! The code below generates the nodal graph of the following mesh: !```Fortran ! use metis_interface, only: idx_t, METIS_SetDefaultOptions, METIS_NodeND !integer(kind=idx_t), parameter :: n = 15, m = 22 !integer(kind=idx_t) :: xadj(n+1), adjncy(2*m) !integer(kind=idx_t) :: perm(n), iperm(n) !integer(kind=idx_t) :: options(0:39), ierr ! !xadj = [1,3,6,9,12,14,17,21,25,29,32,34,37,40,43,45] !adjncy = [2,6,1,3,7,2,4,8,3,5,9,4,10,1,7,11,2,6, & !                  8,12,3,7,9,13,4,8,10,14,5,9,15,6,12,7,11,13, & !                  8,12,14,9,13,15,10,14] ! !ierr = METIS_SetDefaultOptions(options) !options(18) = 1 ! !ierr = METIS_NodeND(n,xadj,adjncy,options=options,perm=perm,iperm=iperm) !end !``` function METIS_NodeND ( nvtxs , xadj , adjncy , vwgt , options , perm , iperm ) result ( ierr ) bind ( C , name = \"METIS_NodeND\" ) import idx_t , METIS_NOPTIONS ! Parameters integer ( kind = idx_t ), intent ( in ) :: nvtxs !! The number of vertices in the graph. integer ( kind = idx_t ), intent ( in ), dimension ( * ) :: xadj , adjncy !! The adjacency structure of the graph as described in Section 5.5 of the [manual](http://glaros.dtc.umn.edu/gkhome/fetch/sw/metis/manual.pdf). integer ( kind = idx_t ), intent ( in ), optional :: vwgt ( nvtxs ) !! An array of size `nvtxs` specifying the weights of the vertices. integer ( kind = idx_t ), intent ( in ), optional :: options ( METIS_NOPTIONS ) !! This is the array of options as described in Section 5.4 of the [manual](http://glaros.dtc.umn.edu/gkhome/fetch/sw/metis/manual.pdf). See description for valid options. integer ( kind = idx_t ), intent ( out ) :: perm ( nvtxs ), iperm ( nvtxs ) !! Vectors of size `nvtxs`. Upon successful completion, they store the fill-reducing !! permutation and inverse-permutation. More in the description. ! Returns integer ( kind = idx_t ) :: ierr !! `METIS_OK` - Indicates that the function returned normally.<br /> !! `METIS_ERROR_INPUT` - Indicates an input error.<br /> !! `METIS_ERROR_MEMORY` - Indicates that it could not allocate the required memory.<br /> !! `METIS_ERROR` - Indicates some other type of error. end function !***************************************************************************************** ! ! Mesh-to-graph conversion routines ! !***************************************************************************************** !> This function is used to generate the dual graph of a mesh. ! !@note ! To use the returned arrays `xadj` and `adjncy`, these must be first converted from ! a C pointer to a Fortran pointer using the subroutine `c_f_pointer(cptr,fptr,shape)` ! that assigns the target of the C pointer `cptr` to the Fortran pointer `fptr` and ! specifies its shape. The `shape` is an integer rank-one array, storing the size `ne+1` ! in case of the dual graph. The size of the new `adjncy` array is stored in the ! last element of `xadj` when using C-style numbering. An example is shown below. !@endnote ! !@warning ! Memory for the returned arrays `xadj` and `adjncy` is allocated by METIS' API in C ! using the standard `malloc` function. It is the responsibility of the application to free ! this memory by calling `free`. Therefore, METIS provides the [[METIS_Free]] function that is a wrapper to ! C's `free`function. !@endwarning ! !# Example ! The code below generates the nodal graph of the following mesh: ! __image__ !```Fortran !use iso_c_binding, only : c_ptr, c_f_pointer !use metis_interface, only: idx_t, METIS_MeshToDual, METIS_Free !integer(kind=idx_t), parameter :: ne = 3, nn = 8, npel = 4 !integer(kind=idx_t) :: ierr, eptr(ne+1), eind(ne*npel), numflag, ncommon !type(c_ptr) :: xadj, adjncy !integer(kind=idx_t), dimension(:), pointer :: fxadj => null(), fadjncy => null() ! !numflag = 0 ! C-style numbering !ncommon = 2 ! 2 common nodes per edge !eptr = [0,4,8,12] !eind = [0,1,2,3,1,4,5,2,4,6,7,5] ! note four nodes per element ! !ierr = METIS_MeshToDual(ne,nn,eptr,eind,ncommon,numflag,xadj,adjncy) !call c_f_pointer(xadj,fxadj,shape=[ne+1]) ! xadj is of the size ne+1 !call c_f_pointer(adjncy,fadjncy,shape=[fxadj(ne+1)]) ! last value in xadj is the size of adjncy ! ! !... use values in fxadj and fadjncy ... ! !call METIS_Free(xadj) !call METIS_Free(adjncy) !end !``` function METIS_MeshToDual ( ne , nn , eptr , eind , ncommon , numflag , xadj , adjncy ) result ( ierr ) bind ( C , name = \"METIS_MeshToDual\" ) import idx_t , c_ptr ! Parameters integer ( kind = idx_t ), intent ( in ) :: ne !! The number of elements in the mesh. integer ( kind = idx_t ), intent ( in ) :: nn !! The number of nodes in the mesh. integer ( kind = idx_t ), intent ( in ), dimension ( * ) :: eptr , eind !! The pair of arrays storing the mesh as described in Section 5.6 of the [manual](http://glaros.dtc.umn.edu/gkhome/fetch/sw/metis/manual.pdf). integer ( kind = idx_t ), intent ( in ) :: ncommon !! The number of common nodes that two elements must have in order to put !! an edge between them in the dual graph. integer ( kind = idx_t ), intent ( in ) :: numflag !! Used to indicate which numbering scheme is used for `eptr` and `eind`. !! The possible values are: <br /> !! 0 - C-style numbering is assumed that starts from 0 <br /> !! 1 - Fortran-style numbering is assumed that starts from 1 type ( c_ptr ), intent ( out ) :: xadj , adjncy !! These arrays store the adjacency structure of the generated dual graph. !! The format of the adjacency structure is described in Section 5.5 of the [manual](http://glaros.dtc.umn.edu/gkhome/fetch/sw/metis/manual.pdf). ! Returns integer ( kind = idx_t ) :: ierr !! `METIS_OK` - Indicates that the function returned normally.<br /> !! `METIS_ERROR_INPUT` - Indicates an input error.<br /> !! `METIS_ERROR_MEMORY` - Indicates that it could not allocate the required memory.<br /> !! `METIS_ERROR` - Indicates some other type of error. end function !***************************************************************************************** !***************************************************************************************** !> This function is used to generate the nodal graph of a mesh. ! !@note ! To use the returned arrays `xadj` and `adjncy`, these must be first converted from ! a C pointer to a Fortran pointer using the subroutine `c_f_pointer(cptr,fptr,shape)` ! that assigns the target of the C pointer `cptr` to the Fortran pointer `fptr` and ! specifies its shape. The `shape` is an integer rank-one array, storing the size `nn+1` ! in case of the nodal graph. The size of the new `adjncy` array is stored in the ! last element of `xadj` when using C-style numbering. An example is shown below. !@endnote ! !@warning ! Memory for the returned arrays `xadj` and `adjncy` is allocated by METIS' API in C ! using the standard `malloc` function. It is the responsibility of the application to free ! this memory by calling `free`. Therefore, METIS provides the [[METIS_Free]] function that is a wrapper to ! C's `free`function. !@endwarning ! !# Example ! The code below generates the nodal graph of the following mesh: ! __image__ !```Fortran !use iso_c_binding, only : c_ptr, c_f_pointer !use metis_interface, only: idx_t, METIS_MeshToNodal, METIS_Free !integer(kind=idx_t), parameter :: ne = 3, nn = 8, npel = 4 !integer(kind=idx_t) :: ierr, eptr(ne+1), eind(ne*npel), numflag !type(c_ptr) :: xadj, adjncy !integer(kind=idx_t), dimension(:), pointer :: fxadj => null(), fadjncy => null() ! !numflag = 0 ! C-style numbering !eptr = [0,4,8,12] !eind = [0,1,2,3,1,4,5,2,4,6,7,5] ! note four nodes per element ! !ierr = METIS_MeshToNodal(ne,nn,eptr,eind,numflag,xadj,adjncy) !call c_f_pointer(xadj,fxadj,shape=[nn+1]) ! xadj is of the size nn+1 !call c_f_pointer(adjncy,fadjncy,shape=[fxadj(nn+1)]) ! last value in xadj is the size of adjncy ! ! !... use values in fxadj and fadjncy ... ! !call METIS_Free(xadj) !call METIS_Free(adjncy) !end !``` function METIS_MeshToNodal ( ne , nn , eptr , eind , numflag , xadj , adjncy ) result ( ierr ) bind ( C , name = \"METIS_MeshToNodal\" ) import idx_t , c_ptr ! Parameters integer ( kind = idx_t ), intent ( in ) :: ne !! The number of elements in the mesh. integer ( kind = idx_t ), intent ( in ) :: nn !! The number of nodes in the mesh. integer ( kind = idx_t ), intent ( in ), dimension ( * ) :: eptr , eind !! The pair of arrays storing the mesh as described in Section 5.6 of the [manual](http://glaros.dtc.umn.edu/gkhome/fetch/sw/metis/manual.pdf). integer ( kind = idx_t ), intent ( in ) :: numflag !! Used to indicate which numbering scheme is used for `eptr` and `eind`. !! The possible values are: <br /> !! 0 - C-style numbering is assumed that starts from 0 <br /> !! 1 - Fortran-style numbering is assumed that starts from 1 type ( c_ptr ), intent ( out ) :: xadj , adjncy !! These arrays store the adjacency structure of the generated dual graph. !! The format of the adjacency structure is described in Section 5.5 of the [manual](http://glaros.dtc.umn.edu/gkhome/fetch/sw/metis/manual.pdf). ! Returns integer ( kind = idx_t ) :: ierr !! `METIS_OK` - Indicates that the function returned normally.<br /> !! `METIS_ERROR_INPUT` - Indicates an input error.<br /> !! `METIS_ERROR_MEMORY` - Indicates that it could not allocate the required memory.<br /> !! `METIS_ERROR` - Indicates some other type of error. end function !***************************************************************************************** ! ! Utility routines ! !***************************************************************************************** !> Initializes the options array into its default values. ! !@note ! The passed array `options` must have the size `METIS_NOPTIONS` (40). ! To be able to use the option parameters specified in the [[metis_interface]] module ! it is recommended to use zero-based indexing for the options array: !```Fortran !integer(kind=idx_t) :: opts(0:39) !``` !@endnote ! !# Examples ! To set Fortran style index-numbering use: !```Fortran !use metis_enum, only: METIS_OPTION_NUMBERING !use metis_interface, only: idx_t, METIS_SetDefaultOptions !integer(kind=idx_t) :: opts(0:39) ! !call METIS_SetDefaultOptions(opts) !opts(METIS_OPTION_NUMBERING) = 1 ! Fortran-style index numbering !``` ! ! Other options can also be changed using parameters specified in the [[metis_interface]] module. !```Fortran !use metis_enum, only : METIS_OPTION_DBGLVL, METIS_DBG_INFO !use metis_interface, only : idx_t, METIS_SetDefaultOptions !integer(kind=idx_t) :: opts(0:39) ! !call METIS_SetDefaultOptions(opts) !opts(METIS_OPTION_DBGLVL) = METIS_DBG_INFO ! Show various diagnostic messages !end !``` function METIS_SetDefaultOptions ( options ) result ( ierr ) bind ( C , name = \"METIS_SetDefaultOptions\" ) import idx_t , METIS_NOPTIONS ! Parameters integer ( kind = idx_t ), intent ( out ) :: options ( METIS_NOPTIONS ) !! The array of options that will be initialized. ! Returns integer ( kind = idx_t ) :: ierr !! `METIS_OK` - Indicates that the function returned normally. end function !***************************************************************************************** !***************************************************************************************** !> Frees the memory that was allocated by either the [[METIS_MeshToDual]] or the !  [[METIS_MeshToNodal]] routines for returning the dual or nodal graph of a mesh. ! !@warning Memory deallocation should always happen on the same side it was allocated! ! Also check the descriptions of the above-mentioned routines. ! !# Example ! !```Fortran ! type(c_ptr) :: xadj(:),adjncy(:) ! ! call METIS_MeshToNodal(...,xadj,adjncy) ! ! ! xadj and adjncy should be deallocated on the C side! ;) ! call METIS_Free(xadj) ! call METIS_Free(adjncy) !``` function METIS_Free ( ptr ) result ( ierr ) bind ( C , name = \"METIS_Free\" ) import idx_t , c_ptr ! Parameters type ( c_ptr ), value :: ptr !! The pointer to be freed. This pointer should be one of the `xadj` or `adjncy` !! arrays returned by METIS' API routines. ! Returns integer ( kind = idx_t ) :: ierr !! `METIS_OK` - Indicates that the function returned normally. end function !***************************************************************************************** end interface end module !*****************************************************************************************","tags":"","loc":"sourcefile/metis_interface.f90.html","title":"metis_interface.f90 – Fortran METIS Interface"},{"text":"This File Depends On sourcefile~~metis_oo_interface.f90~~EfferentGraph sourcefile~metis_oo_interface.f90 metis_oo_interface.f90 sourcefile~metis_interface.f90 metis_interface.f90 sourcefile~metis_interface.f90->sourcefile~metis_oo_interface.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules metis_oo_interface Source Code metis_oo_interface.f90 Source Code ! metis_oo_interface.f90 ! ! Copyright 2019 Ivan Pribec <ivan.pribec@gmail.com> ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module metis_oo_interface use metis_interface implicit none public :: graph_type public :: export_graph type :: graph_type integer :: nvxts !! Number of vertices. integer :: nedgs !! Number of edges. integer , pointer :: xadj (:) => null () integer , pointer :: adjncy (:) => null () integer :: numflag = 1 !! Numbering style. integer :: ncon integer , pointer :: vwgt (:) => null () integer , pointer :: adjwgt (:) => null () integer , pointer :: vsize (:) => null () end type contains subroutine import_graph ( fname , graph , numflag ) character ( len =* ), intent ( in ) :: fname class ( graph_type ), intent ( out ) :: graph integer , intent ( in ), optional :: numflag integer :: unit , ios if ( present ( numflag )) graph % numflag = numflag open ( newunit = unit , file = fname , status = 'old' , iostat = ios ) call read_graph ( unit , graph % xadj , graph % adjncy , numflag = graph % numflag , vwgt = graph % vwgt , & adjwgt = graph % adjwgt , vsize = graph % vsize ) print * , graph % adjncy graph % nvxts = size ( graph % xadj ) - 1 graph % nedgs = size ( graph % adjncy ) / 2 close ( unit ) end subroutine subroutine export_graph ( fname , graph ) character ( len =* ), intent ( in ) :: fname class ( graph_type ), intent ( in ) :: graph integer :: unit open ( newunit = unit , file = fname ) call write_graph ( unit , graph % xadj , graph % adjncy , graph % numflag , & graph % vwgt , graph % adjwgt , graph % vsize ) close ( unit ) end subroutine subroutine write_graph ( unit , xadj , adjncy , numflag , vwgt , adjwgt , vsize ) integer , intent ( in ) :: unit integer , intent ( in ) :: xadj (:) integer , intent ( in ) :: adjncy (:) integer , intent ( in ), optional :: numflag integer , intent ( in ), optional :: vwgt (:) integer , intent ( in ), optional :: adjwgt (:) integer , intent ( in ), optional :: vsize (:) integer :: nvxts , nedgs , ncon , numflag_ , i , j , fmt character ( len = 3 ) :: cfmt character ( len = 11 ) :: fstring fstring = '(*(i0,:,x))' ! Format string for graph output numflag_ = 1 ! Assume Fortran numbering by default if ( present ( numflag )) numflag_ = numflag ! Get number of vertices and edges nvxts = size ( xadj ) - 1 nedgs = size ( adjncy ) / 2 ! Format specifier fmt = 0 if ( present ( adjwgt )) fmt = ibset ( fmt , 0 ) if ( present ( vwgt )) fmt = ibset ( fmt , 1 ) if ( present ( vsize )) fmt = ibset ( fmt , 2 ) ! Number of constraints ncon = 0 if ( btest ( fmt , 1 )) ncon = size ( vwgt ) / nvxts ! Write header line if ( fmt > 0 ) then ! Write fmt to character string write ( cfmt , '(b3.3)' ) fmt if ( btest ( fmt , 1 )) then if ( ncon > 1 ) write ( unit , '(i0,1x,i0,1x,a3,1x,i0)' ) nvxts , nedgs , cfmt , ncon else write ( unit , '(i0,1x,i0,1x,a3)' ) nvxts , nedgs , cfmt end if else write ( unit , '(i0,1x,i0)' ) nvxts , nedgs end if select case ( fmt ) case ( b '000' ) do i = 1 , nvxts ! v1 v2 v3 ... write ( unit , fstring ) ( adjncy ( j ), j = xadj ( i ), xadj ( i + 1 ) - 1 ) end do case ( b '001' ) ! edge weights do i = 1 , nvxts ! v1 e1 v2 e2 ... write ( unit , fstring ) ( adjncy ( j ), adjwgt ( j ), j = xadj ( i ), xadj ( i + 1 ) - 1 ) end do case ( b '010' ) ! vertex weights do i = 1 , nvxts ! w1 w2 ... wncon v1 v2 v3 ... write ( unit , fstring ) vwgt (( i - 1 ) * ncon + 1 :( i - 1 ) * ncon + ncon ),( adjncy ( j ), j = xadj ( i ), xadj ( i + 1 ) - 1 ) end do case ( b '100' ) ! vertex sizes do i = 1 , nvxts write ( unit , fstring ) vsize ( i ), ( adjncy ( j ), j = xadj ( i ), xadj ( i + 1 ) - 1 ) end do case ( b '011' ) do i = 1 , nvxts write ( unit , fstring ) vwgt (( i - 1 ) * ncon + 1 :( i - 1 ) * ncon + ncon ), ( adjncy ( j ), adjwgt ( j ), j = xadj ( i ), xadj ( i + 1 ) - 1 ) end do case ( b '110' ) do i = 1 , nvxts write ( unit , fstring ) vsize ( i ), vwgt (( i - 1 ) * ncon + 1 :( i - 1 ) * ncon + ncon ),( adjncy ( j ), j = xadj ( i ), xadj ( i + 1 ) - 1 ) end do case ( b '101' ) do i = 1 , nvxts write ( unit , fstring ) vsize ( i ), ( adjncy ( j ), adjwgt ( j ), j = xadj ( i ), xadj ( i + 1 ) - 1 ) end do case ( b '111' ) do i = 1 , nvxts write ( unit , fstring ) vsize ( i ), vwgt (( i - 1 ) * ncon + 1 :( i - 1 ) * ncon + ncon ), ( adjncy ( j ), adjwgt ( j ), j = xadj ( i ), xadj ( i + 1 ) - 1 ) end do case default write ( * , * ) '[write_graph] Error occured' end select end subroutine logical function whitechar ( char ) ! white character ! returns .true. if char is space (32) or tab (9), .false. otherwise character , intent ( in ) :: char if ( iachar ( char ) == 32 . or . iachar ( char ) == 9 ) then whitechar = . true . else whitechar = . false . end if end function integer function count_columns ( unit , stat ) result ( ncol ) integer , intent ( in ) :: unit integer , intent ( out ) :: stat character ( len = 1 ) :: c logical :: lastwhite ncol = 0 lastwhite = . true . do read ( unit , '(a)' , advance = 'no' , iostat = stat ) c if ( stat /= 0 ) exit if ( lastwhite . and . . not . whitechar ( c )) ncol = ncol + 1 lastwhite = whitechar ( c ) end do backspace ( unit , iostat = stat ) end function subroutine read_graph ( unit , xadj , adjncy , numflag , vwgt , adjwgt , vsize ) implicit none integer , intent ( in ) :: unit integer , intent ( out ), pointer :: xadj (:) integer , intent ( out ), pointer :: adjncy (:) integer , intent ( in ), optional :: numflag integer , pointer , optional :: vwgt (:) integer , intent ( out ), pointer , optional :: adjwgt (:) integer , intent ( out ), pointer , optional :: vsize (:) character ( len = 1 ) :: c integer :: ncol , ios , i , rowcol , j logical :: lastwhite character ( len = 3 ) :: cfmt integer :: nvtxs , nedgs , ncon , fmt , numflag_ numflag_ = 1 ! Assume Fortran numbering by default if ( present ( numflag )) numflag_ = numflag ! Determine number of columns in header line ncol = 0 lastwhite = . true . do read ( unit , '(a)' , advance = 'no' , iostat = ios ) c ! if (iachar(c) == 37) then !     read(unit,*) ! skipline !     print *, \"Skipped line\" !     cycle ! end if if ( ios /= 0 ) exit if ( lastwhite . and . . not . whitechar ( c )) ncol = ncol + 1 lastwhite = whitechar ( c ) end do print * , \"Number of columns in header = \" , ncol rewind ( unit ) ! do !     read(unit,'(a)',iostat=ios) c !     if (iachar(c) == 37) then !         print *, \"Skipped line\" !         cycle !     else !         backspace(unit) !         exit !     end if ! end do ! Parse values in header line ncon = 1 cfmt = '000' select case ( ncol ) case ( 2 ) read ( unit , * , iostat = ios ) nvtxs , nedgs case ( 3 ) read ( unit , * , iostat = ios ) nvtxs , nedgs , cfmt case ( 4 ) read ( unit , * , iostat = ios ) nvtxs , nedgs , cfmt , ncon print * , \"hello\" case default write ( * , * ) \"[load_graph]: incorrect file\" stop end select read ( cfmt , '(b3.3)' ) fmt print * , nvtxs , nedgs , cfmt , ncon write ( * , '(A,B3.3)' ) \"fmt = \" , fmt ! Allocate necessary space allocate ( xadj ( nvtxs + 1 )) allocate ( adjncy ( 2 * nedgs )) if ( btest ( fmt , 0 )) allocate ( adjwgt ( 2 * nedgs )) if ( btest ( fmt , 1 )) allocate ( vwgt ( nvtxs * ncon )) if ( btest ( fmt , 2 )) allocate ( vsize ( nvtxs )) write ( * , * ) associated ( vsize ), associated ( vwgt ), associated ( adjwgt ) ! stop xadj ( 1 ) = 0 select case ( fmt ) case ( b '000' ) do i = 1 , nvtxs rowcol = count_columns ( unit , stat = ios ) xadj ( i + 1 ) = xadj ( i ) + rowcol read ( unit , * ) adjncy ( xadj ( i ) + 1 : xadj ( i + 1 )) end do case ( b '001' ) do i = 1 , nvtxs rowcol = count_columns ( unit , stat = ios ) / 2 xadj ( i + 1 ) = xadj ( i ) + rowcol read ( unit , * ) ( adjncy ( j ), adjwgt ( j ), j = xadj ( i ) + 1 , xadj ( i + 1 )) end do case ( b '010' ) do i = 1 , nvtxs rowcol = count_columns ( unit , stat = ios ) - ncon xadj ( i + 1 ) = xadj ( i ) + rowcol read ( unit , * ) vwgt (( i - 1 ) * ncon + 1 :( i - 1 ) * ncon + ncon ), adjncy ( xadj ( i ) + 1 : xadj ( i + 1 )) end do case ( b '100' ) do i = 1 , nvtxs rowcol = count_columns ( unit , stat = ios ) - 1 xadj ( i + 1 ) = xadj ( i ) + rowcol read ( unit , * ) vsize ( i ), adjncy ( xadj ( i ) + 1 : xadj ( i + 1 )) end do case ( b '011' ) do i = 1 , nvtxs rowcol = ( count_columns ( unit , stat = ios ) - ncon ) / 2 xadj ( i + 1 ) = xadj ( i ) + rowcol read ( unit , * ) vwgt (( i - 1 ) * ncon + 1 :( i - 1 ) * ncon + ncon ), ( adjncy ( j ), adjwgt ( j ), j = xadj ( i ) + 1 , xadj ( i + 1 )) end do case ( b '110' ) do i = 1 , nvtxs rowcol = count_columns ( unit , stat = ios ) - 1 - ncon xadj ( i + 1 ) = xadj ( i ) + rowcol read ( unit , * ) vsize ( i ), vwgt (( i - 1 ) * ncon + 1 :( i - 1 ) * ncon + ncon ), adjncy ( xadj ( i ) + 1 : xadj ( i + 1 )) end do case ( b '101' ) do i = 1 , nvtxs rowcol = ( count_columns ( unit , stat = ios ) - 1 ) / 2 xadj ( i + 1 ) = xadj ( i ) + rowcol read ( unit , * ) vsize ( i ), ( adjncy ( j ), adjwgt ( j ), j = xadj ( i ) + 1 , xadj ( i + 1 )) end do case ( b '111' ) do i = 1 , nvtxs rowcol = ( count_columns ( unit , stat = ios ) - 1 - ncon ) / 2 xadj ( i + 1 ) = xadj ( i ) + rowcol read ( unit , * ) vsize ( i ), vwgt (( i - 1 ) * ncon + 1 :( i - 1 ) * ncon + ncon ), ( adjncy ( j ), adjwgt ( j ), j = xadj ( i ) + 1 , xadj ( i + 1 )) end do case default print * , \"[read_graph] should not be here\" stop end select if ( numflag_ == 0 ) then adjncy = adjncy - 1 else xadj = xadj + 1 end if end subroutine subroutine print_metis_options ( opts , unit ) use iso_fortran_env , only : output_unit integer , intent ( in ) :: opts ( 0 :) integer , intent ( in ), optional :: unit integer :: i , unit_ unit_ = output_unit ! standard output if ( present ( unit )) unit_ = unit do i = 0 , METIS_NOPTIONS - 1 write ( unit_ , '(\"Option \",I2,\":\",I3)' ) i , opts ( i ) end do end subroutine function FMETIS_MeshToNodal ( ne , nn , eptr , eind , numflag , xadj , adjncy , stat ) result ( ierr ) use iso_c_binding , only : c_int , c_ptr , c_f_pointer integer ( c_int ), intent ( in ) :: ne integer ( c_int ), intent ( in ) :: nn integer ( c_int ), intent ( in ) :: eptr ( ne + 1 ) integer ( c_int ), intent ( in ) :: eind (:) integer ( c_int ), intent ( in ) :: numflag integer ( c_int ), intent ( out ), allocatable :: xadj (:) integer ( c_int ), intent ( out ), allocatable :: adjncy (:) integer ( c_int ), intent ( out ), optional :: stat ! stat = 0 indicates successful allocation and correct arguments ! Result integer ( c_int ) :: ierr integer ( c_int ) :: stat_ character ( len = 80 ) :: errmsg_ type ( c_ptr ) :: c_xadj , c_adjncy integer ( c_int ), pointer :: f_xadj (:) => null (), f_adjncy (:) => null () ierr = METIS_MeshToNodal ( ne , nn , eptr , eind , numflag , c_xadj , c_adjncy ) if ( ierr /= METIS_OK ) return call c_f_pointer ( c_xadj , f_xadj , shape = [ nn + 1 ]) select case ( numflag ) case ( 0 ) call c_f_pointer ( c_adjncy , f_adjncy , shape = [ f_xadj ( nn + 1 )]) case ( 1 ) call c_f_pointer ( c_adjncy , f_adjncy , shape = [ f_xadj ( nn + 1 ) - 1 ]) case default write ( * , * ) \"[FMETIS_MeshToNodal] Wrong numflag argument! Only 0 or 1 are allowed. Got \" , numflag , \" instead.\" if ( present ( stat )) stat = - 1 return end select allocate ( xadj , source = f_xadj , stat = stat_ , errmsg = errmsg_ ) if ( present ( stat )) stat = stat_ if ( stat_ > 0 ) then write ( * , * ) \"[FMETIS_MeshToNodal] Allocation of xadj failed with error: \" , stat_ , \", \" // trim ( errmsg_ ) // \".\" return end if allocate ( adjncy , source = f_adjncy , stat = stat_ , errmsg = errmsg_ ) if ( present ( stat )) stat = stat_ if ( stat_ > 0 ) then write ( * , * ) \"[FMETIS_MeshToNodal] Allocation of adjncy failed with error: \" , stat_ , \", \" // trim ( errmsg_ ) // \".\" return end if ierr = METIS_Free ( c_xadj ) if ( ierr /= METIS_OK ) return ierr = METIS_Free ( c_adjncy ) if ( ierr /= METIS_OK ) return end function end module","tags":"","loc":"sourcefile/metis_oo_interface.f90.html","title":"metis_oo_interface.f90 – Fortran METIS Interface"},{"text":"type, public :: graph_type Variables nvxts nedgs xadj adjncy numflag ncon vwgt adjwgt vsize Components Type Visibility Attributes Name Initial integer, public :: nvxts Number of vertices. integer, public :: nedgs Number of edges. integer, public, pointer :: xadj (:) => null() integer, public, pointer :: adjncy (:) => null() integer, public :: numflag = 1 Numbering style. integer, public :: ncon integer, public, pointer :: vwgt (:) => null() integer, public, pointer :: adjwgt (:) => null() integer, public, pointer :: vsize (:) => null()","tags":"","loc":"type/graph_type.html","title":"graph_type – Fortran METIS Interface "},{"text":"interface public function METIS_PartGraphRecursive(nvtxs, ncon, xadj, adjncy, vwgt, vsize, adjwgt, nparts, tpwgts, ubvec, options, objval, part) result(ierr) bind(C,name=\"METIS_PartGraphRecursive\") Arguments Type Intent Optional Attributes Name integer(kind=idx_t), intent(in) :: nvtxs The number of vertices in the graph. integer(kind=idx_t), intent(in) :: ncon The number of balancing constraints. It should be atleast 1. integer(kind=idx_t), intent(in), dimension(*) :: xadj The adjacency structure of the graph as described in section 5.5 of the manual . integer(kind=idx_t), intent(in), dimension(*) :: adjncy The adjacency structure of the graph as described in section 5.5 of the manual . integer(kind=idx_t), intent(in), optional dimension(*) :: vwgt The weights of the vertices as described in Section 5.5 of the manual . integer(kind=idx_t), intent(in), optional dimension(*) :: vsize The size of the vertices for computing the total communication volume as described in section 5.7 of the manual . integer(kind=idx_t), intent(in), optional dimension(*) :: adjwgt The weights of the edges as describe in Section 5.5 of the manual . integer(kind=idx_t), intent(in) :: nparts The number of parts to partition the graph. real(kind=real_t), intent(in), optional :: tpwgts (nparts*ncon) An array of size nparts*ncon that specifies the desired weight for each partition and constraint.\n If not present, the graph is divided equally among the partitions. More in the description. real(kind=real_t), intent(in), optional :: ubvec (ncon) An array of size ncon that specifies the allowed load imbalance for each constraint. \n For the i -th partition and j -th constraint the allowed weight is the ubvec(j)*tpwgts(i*ncon+j) fraction of the j -th's constraint total weight. If not present, the load imbalance\n tolerance is 1.001 (for ncon = 1 ) or 1.01 (for ncon > 1 ). integer(kind=idx_t), intent(in), optional :: options (METIS_NOPTIONS) An array of options as described in Section 5.4 of the METIS manual. See description for valid options. integer(kind=idx_t), intent(out) :: objval Upon successful completion, this variable stores the edge-cut or the total communication volume of the partitioning\n solution. The value returned depends on the partitioning's objective function. integer(kind=idx_t), intent(out) :: part (nvtxs) This is a vector of size nvtxs that upon successful completion stores the partition vector of the graph.\n The numbering of this vector starts from either 0 or 1, depending on the value of options(METIS_OPTION_NUMBERING) . Return Value integer(kind=idx_t) METIS_OK - Indicates that the function returned normally. METIS_ERROR_INPUT - Indicates an input error. METIS_ERROR_MEMORY - Indicates that it could not allocate the required memory. METIS_ERROR - Indicates some other type of error. Description This function is used to partition a graph into nparts parts using recursive bisection. If tpwgt is present, the target partition weight for the i -th partition and j -th constraint should\n  be specified at tpwgts(i*ncon+j) (the numbering for both partitions and constraints starts from 0).\n  For each constraint, the sum of the tpwgts entries must be 1.0. The following options are valid: METIS_OPTION_CTYPE , METIS_OPTION_IPTYPE , METIS_OPTION_RTYPE , METIS_OPTION_NO2HOP , METIS_OPTION_NCUTS , METIS_OPTION_NITER , METIS_OPTION_SEED , METIS_OPTION_UFACTOR , METIS_OPTION_NUMBERING , METIS_OPTION_DBGLVL","tags":"","loc":"interface/metis_partgraphrecursive.html","title":"METIS_PartGraphRecursive – Fortran METIS Interface"},{"text":"interface public function METIS_PartGraphKway(nvtxs, ncon, xadj, adjncy, vwgt, vsize, adjwgt, nparts, tpwgts, ubvec, options, objval, part) result(ierr) bind(C,name=\"METIS_PartGraphKway\") Arguments Type Intent Optional Attributes Name integer(kind=idx_t), intent(in) :: nvtxs The number of vertices in the graph. integer(kind=idx_t), intent(in) :: ncon The number of balancing constraints. It should be at least 1. integer(kind=idx_t), intent(in), dimension(*) :: xadj The adjacency structure of the graph as described in section 5.5 of the manual . integer(kind=idx_t), intent(in), dimension(*) :: adjncy The adjacency structure of the graph as described in section 5.5 of the manual . integer(kind=idx_t), intent(in), optional dimension(*) :: vwgt The weights of the vertices as described in Section 5.5 of the manual . integer(kind=idx_t), intent(in), optional dimension(*) :: vsize The size of the vertices for computing the total communication volume as described in section 5.7 of the manual . integer(kind=idx_t), intent(in), optional dimension(*) :: adjwgt The weights of the edges as describe in Section 5.5 of the manual . integer(kind=idx_t), intent(in) :: nparts The number of parts to partition the graph. real(kind=real_t), intent(in), optional :: tpwgts (nparts*ncon) An array of size nparts*ncon that specifies the desired weight for each partition and constraint.\n If not present, the graph is divided equally among the partitions. More in the description. real(kind=real_t), intent(in), optional :: ubvec (ncon) An array of size ncon that specifiew the allowed load imbalance for each constraint. \n For the i -th partition and j -th constraint the allowed weight is the ubvec(j)*tpwgts(i*ncon+j) fraction of the j -th's constraint total weight. If not present, the load imbalance\n tolerance is 1.001 (for ncon == 1 ) or 1.01 (for ncon > 1 ). integer(kind=idx_t), intent(in), optional :: options (METIS_NOPTIONS) An array of options as described in Section 5.4 of the manual . See description for valid options. integer(kind=idx_t), intent(out) :: objval Upon successful completion, this variable stores the edge-cut or the total communication volume of the partitioning\n solution. The value returned depends on the partitioning's objective function. integer(kind=idx_t), intent(out) :: part (nvtxs) This is a vector of size nvtxs that upon successful completion stores the partition vector of the graph.\n The numbering of this vector starts from either 0 or 1, depending on the value of options(METIS_OPTION_NUMBERING) . Return Value integer(kind=idx_t) METIS_OK - Indicates that the function returned normally. METIS_ERROR_INPUT - Indicates an input error. METIS_ERROR_MEMORY - Indicates that it could not allocate the required memory. METIS_ERROR - Indicates some other type of error. Description This function is used to partition a graph into nparts parts using multilevel k-way partitioning. If tpwgt is present, the target partition weight for the i -th partition and j -th constraint should\n  be specified at tpwgts(i*ncon+j) (the numbering for both partitions and constraints starts from 0).\n  For each constraint, the sum of the tpwgts entries must be 1.0. The following options are valid: METIS_OPTION_OBJTYPE , METIS_OPTION_CTYPE , METIS_OPTION_IPTYPE , METIS_OPTION_RTYPE , METIS_OPTION_NO2HOP , METIS_OPTION_NCUTS , METIS_OPTION_NITER , METIS_OPTION_UFACTOR , METIS_OPTION_MINCONN , METIS_OPTION_CONTIG , METIS_OPTION_SEED , METIS_OPTION_NUMBERING , METIS_OPTION_DBGLVL","tags":"","loc":"interface/metis_partgraphkway.html","title":"METIS_PartGraphKway – Fortran METIS Interface"},{"text":"interface public function METIS_PartMeshDual(ne, nn, eptr, eind, vwgt, vsize, ncommon, nparts, tpwgts, options, objval, epart, npart) result(ierr) bind(C,name=\"METIS_PartMeshDual\") Arguments Type Intent Optional Attributes Name integer(kind=idx_t), intent(in) :: ne The number of elements in the mesh. integer(kind=idx_t), intent(in) :: nn The number of nodes in the mesh. integer(kind=idx_t), intent(in), dimension(*) :: eptr The pair of arrays storing the mesh as described in Section 5.6 of the manual . integer(kind=idx_t), intent(in), dimension(*) :: eind The pair of arrays storing the mesh as described in Section 5.6 of the manual . integer(kind=idx_t), intent(in), optional :: vwgt (ne) An array of size ne specifying the weights of the elements. If not present,\n all elements have an equal weight. integer(kind=idx_t), intent(in), optional :: vsize (ne) An array of size ne specifying the size of the elements that is used\n for computing the total comunication volume as described in Section 5.7 of the manual .\n If not present, the objective is cut or all elements have an equal size. integer(kind=idx_t), intent(in) :: ncommon integer(kind=idx_t), intent(in) :: nparts The number of parts to partition the mesh. integer(kind=idx_t), intent(in), optional :: tpwgts (nparts) An array of size nparts that specifies the desired weight for each partition. The target\n partition weight for the i -th partition is specified at tpwgts(i) (the numbering for the \n partitions starts from 0). The sum of the tpwgts entries must be 1.0. If not present, the graph\n is divided equally among the partitions. integer(kind=idx_t), intent(in), optional :: options (METIS_NOPTIONS) An array of options as described in Section 5.4 of the manual . See description for valid options. integer(kind=idx_t), intent(out) :: objval Upon successful completion, this variable stores either the edgecut or the total communication\n volume of the dual graph's partitioning. integer(kind=idx_t), intent(out) :: epart (ne) A vector of size ne that upon successful completion stores the partition vector for the elements\n of the mesh. The numbering of this vector starts from either 0 or 1, depending on the value of options(METIS_OPTION_NUMBERING) . integer(kind=idx_t), intent(out) :: npart (nn) A vector of size nn that upon successful completion stores the partition vector for the nodes \n of the mesh. The numbering of this vector starts from either 0 or 1, depending on the value of options(METIS_OPTION_NUMBERING) . Return Value integer(kind=idx_t) METIS_OK - Indicates that the function returned normally. METIS_ERROR_INPUT - Indicates an input error. METIS_ERROR_MEMORY - Indicates that it could not allocate the required memory. METIS_ERROR - Indicates some other type of error. Description This function is used to partition a mesh into nparts parts based on a partitioning of the mesh's dual graph. The following options are valid: METIS_OPTION_PTYPE , METIS_OPTION_OBJTYPE , METIS_OPTION_CTYPE , METIS_OPTION_IPTYPE , METIS_OPTION_RTYPE , METIS_OPTION_NCUTS , METIS_OPTION_NITER , METIS_OPTION_SEED , METIS_OPTION_UFACTOR , METIS_OPTION_NUMBERING , METIS_OPTION_DBGLVL","tags":"","loc":"interface/metis_partmeshdual.html","title":"METIS_PartMeshDual – Fortran METIS Interface"},{"text":"interface public function METIS_PartMeshNodal(ne, nn, eptr, eind, vwgt, vsize, nparts, tpwgts, options, objval, epart, npart) result(ierr) bind(C,name=\"METIS_PartMeshNodal\") Arguments Type Intent Optional Attributes Name integer(kind=idx_t), intent(in) :: ne The number of elements in the mesh. integer(kind=idx_t), intent(in) :: nn The number of nodes in the mesh. integer(kind=idx_t), intent(in), dimension(*) :: eptr The pair of arrays storing the mesh as described in Section 5.6 of the manual . integer(kind=idx_t), intent(in), dimension(*) :: eind The pair of arrays storing the mesh as described in Section 5.6 of the manual . integer(kind=idx_t), intent(in), optional :: vwgt (nn) An array of size nn specifying weights of the nodes. If not passed, all nodes have an equal weight. integer(kind=idx_t), intent(in), optional :: vsize (nn) An array of size nn specifying the size of the nodes that is used for computing the\n total comunication volume as described in Section 5.7 of the manual . If not passed,\n the objective is cut or all nodes have an equal size. integer(kind=idx_t), intent(in) :: nparts The number of parts to partition the mesh. integer(kind=idx_t), intent(in), optional :: tpwgts (nparts) An array of size nparts that specifies the desired weight for each partition. The target\n partition weight for the i -th partition is specified at tpwgts(i) (the numbering for the \n partitions starts from 0). The sum of the tpwgts entries must be 1.0. If not passed, the graph\n is divided equally among the partitions. integer(kind=idx_t), intent(in), optional :: options (METIS_NOPTIONS) An array of options as described in Section 5.4 of the manual . See description for valid options. integer(kind=idx_t), intent(out) :: objval Upon successful completion, this variable stores either the edgecut or the total communication\n volume of the nodal graph's partitioning. integer(kind=idx_t), intent(out) :: epart (ne) A vector of size ne that upon successful completion stores the partition vector for the elements\n of the mesh. The numbering of this vector starts from either 0 or 1, depending on the value of options(METIS_OPTION_NUMBERING) . integer(kind=idx_t), intent(out) :: npart (nn) A vector of size nn that upon successful completion stores the partition vector for the nodes \n of the mesh. The numbering of this vector starts from either 0 or 1, depending on the value of options(METIS_OPTION_NUMBERING) . Return Value integer(kind=idx_t) METIS_OK - Indicates that the function returned normally. METIS_ERROR_INPUT - Indicates an input error. METIS_ERROR_MEMORY - Indicates that it could not allocate the required memory. METIS_ERROR - Indicates some other type of error. Description This function us used to partition a mesh into nparts parts based on a \n  partitioning of the mesh's nodal graph. The following options are valid: METIS_OPTION_PTYPE , METIS_OPTION_OBJTYPE , METIS_OPTION_CTYPE , METIS_OPTION_IPTYPE , METIS_OPTION_RTYPE , METIS_OPTION_NCUTS , METIS_OPTION_NITER , METIS_OPTION_SEED , METIS_OPTION_UFACTOR , METIS_OPTION_NUMBERING , METIS_OPTION_DBGLVL","tags":"","loc":"interface/metis_partmeshnodal.html","title":"METIS_PartMeshNodal – Fortran METIS Interface"},{"text":"interface public function METIS_NodeND(nvtxs, xadj, adjncy, vwgt, options, perm, iperm) result(ierr) bind(C,name=\"METIS_NodeND\") Arguments Type Intent Optional Attributes Name integer(kind=idx_t), intent(in) :: nvtxs The number of vertices in the graph. integer(kind=idx_t), intent(in), dimension(*) :: xadj The adjacency structure of the graph as described in Section 5.5 of the manual . integer(kind=idx_t), intent(in), dimension(*) :: adjncy The adjacency structure of the graph as described in Section 5.5 of the manual . integer(kind=idx_t), intent(in), optional :: vwgt (nvtxs) An array of size nvtxs specifying the weights of the vertices. integer(kind=idx_t), intent(in), optional :: options (METIS_NOPTIONS) This is the array of options as described in Section 5.4 of the manual . See description for valid options. integer(kind=idx_t), intent(out) :: perm (nvtxs) Vectors of size nvtxs . Upon successful completion, they store the fill-reducing\n permutation and inverse-permutation. More in the description. integer(kind=idx_t), intent(out) :: iperm (nvtxs) Vectors of size nvtxs . Upon successful completion, they store the fill-reducing\n permutation and inverse-permutation. More in the description. Return Value integer(kind=idx_t) METIS_OK - Indicates that the function returned normally. METIS_ERROR_INPUT - Indicates an input error. METIS_ERROR_MEMORY - Indicates that it could not allocate the required memory. METIS_ERROR - Indicates some other type of error. Description This function computes fill reducing orderings of sparse matrices using the\n  multilevel nested dissection algorithm. Let A be the original matrix and A' be the permuted matrix. The arrays perm and iperm are defined as follows. Row (column) i of A' is the perm(i) row (column) of A, and row (column) i of A is the iperm(i) row (column) of A'. the numbering of this vector starts from either 0 or 1,\n  depending on the value of options(METIS_OPTION_NUMBERING) . If the graph is weighted, meaning vgwt was provided, the nested dissection ordering computes\n  vertex separators that minimize the sum of the weights of the vertices on the separators. The following options are valid: METIS_OPTION_CTYPE , METIS_OPTION_RTYPE , METIS_OPTION_NO2HOP , METIS_OPTION_NSEPS , METIS_OPTION_NITER , METIS_OPTION_UFACTOR , METIS_OPTION_COMPRESS , METIS_OPTION_CCORDER , METIS_OPTION_SEED , METIS_OPTION_PFACTOR , METIS_OPTION_NUMBERING , METIS_OPTION_DBGLVL Example The code below generates the nodal graph of the following mesh: use metis_interface , only : idx_t , METIS_SetDefaultOptions , METIS_NodeND integer ( kind = idx_t ), parameter :: n = 15 , m = 22 integer ( kind = idx_t ) :: xadj ( n + 1 ), adjncy ( 2 * m ) integer ( kind = idx_t ) :: perm ( n ), iperm ( n ) integer ( kind = idx_t ) :: options ( 0 : 39 ), ierr xadj = [ 1 , 3 , 6 , 9 , 12 , 14 , 17 , 21 , 25 , 29 , 32 , 34 , 37 , 40 , 43 , 45 ] adjncy = [ 2 , 6 , 1 , 3 , 7 , 2 , 4 , 8 , 3 , 5 , 9 , 4 , 10 , 1 , 7 , 11 , 2 , 6 , & 8 , 12 , 3 , 7 , 9 , 13 , 4 , 8 , 10 , 14 , 5 , 9 , 15 , 6 , 12 , 7 , 11 , 13 , & 8 , 12 , 14 , 9 , 13 , 15 , 10 , 14 ] ierr = METIS_SetDefaultOptions ( options ) options ( 18 ) = 1 ierr = METIS_NodeND ( n , xadj , adjncy , options = options , perm = perm , iperm = iperm ) end","tags":"","loc":"interface/metis_nodend.html","title":"METIS_NodeND – Fortran METIS Interface"},{"text":"interface public function METIS_MeshToDual(ne, nn, eptr, eind, ncommon, numflag, xadj, adjncy) result(ierr) bind(C,name=\"METIS_MeshToDual\") Arguments Type Intent Optional Attributes Name integer(kind=idx_t), intent(in) :: ne The number of elements in the mesh. integer(kind=idx_t), intent(in) :: nn The number of nodes in the mesh. integer(kind=idx_t), intent(in), dimension(*) :: eptr The pair of arrays storing the mesh as described in Section 5.6 of the manual . integer(kind=idx_t), intent(in), dimension(*) :: eind The pair of arrays storing the mesh as described in Section 5.6 of the manual . integer(kind=idx_t), intent(in) :: ncommon The number of common nodes that two elements must have in order to put\n an edge between them in the dual graph. integer(kind=idx_t), intent(in) :: numflag Used to indicate which numbering scheme is used for eptr and eind . \n The possible values are: 0 - C-style numbering is assumed that starts from 0 1 - Fortran-style numbering is assumed that starts from 1 type(c_ptr), intent(out) :: xadj These arrays store the adjacency structure of the generated dual graph. \n The format of the adjacency structure is described in Section 5.5 of the manual . type(c_ptr), intent(out) :: adjncy These arrays store the adjacency structure of the generated dual graph. \n The format of the adjacency structure is described in Section 5.5 of the manual . Return Value integer(kind=idx_t) METIS_OK - Indicates that the function returned normally. METIS_ERROR_INPUT - Indicates an input error. METIS_ERROR_MEMORY - Indicates that it could not allocate the required memory. METIS_ERROR - Indicates some other type of error. Description This function is used to generate the dual graph of a mesh. Note To use the returned arrays xadj and adjncy , these must be first converted from\n a C pointer to a Fortran pointer using the subroutine c_f_pointer(cptr,fptr,shape) that assigns the target of the C pointer cptr to the Fortran pointer fptr and\n specifies its shape. The shape is an integer rank-one array, storing the size ne+1 in case of the dual graph. The size of the new adjncy array is stored in the \n last element of xadj when using C-style numbering. An example is shown below. Warning Memory for the returned arrays xadj and adjncy is allocated by METIS' API in C\n using the standard malloc function. It is the responsibility of the application to free\n this memory by calling free . Therefore, METIS provides the METIS_Free function that is a wrapper to\n C's free function. Example The code below generates the nodal graph of the following mesh: image use iso_c_binding , only : c_ptr , c_f_pointer use metis_interface , only : idx_t , METIS_MeshToDual , METIS_Free integer ( kind = idx_t ), parameter :: ne = 3 , nn = 8 , npel = 4 integer ( kind = idx_t ) :: ierr , eptr ( ne + 1 ), eind ( ne * npel ), numflag , ncommon type ( c_ptr ) :: xadj , adjncy integer ( kind = idx_t ), dimension (:), pointer :: fxadj => null (), fadjncy => null () numflag = 0 ! C-style numbering ncommon = 2 ! 2 common nodes per edge eptr = [ 0 , 4 , 8 , 12 ] eind = [ 0 , 1 , 2 , 3 , 1 , 4 , 5 , 2 , 4 , 6 , 7 , 5 ] ! note four nodes per element ierr = METIS_MeshToDual ( ne , nn , eptr , eind , ncommon , numflag , xadj , adjncy ) call c_f_pointer ( xadj , fxadj , shape = [ ne + 1 ]) ! xadj is of the size ne+1 call c_f_pointer ( adjncy , fadjncy , shape = [ fxadj ( ne + 1 )]) ! last value in xadj is the size of adjncy !... use values in fxadj and fadjncy ... call METIS_Free ( xadj ) call METIS_Free ( adjncy ) end","tags":"","loc":"interface/metis_meshtodual.html","title":"METIS_MeshToDual – Fortran METIS Interface"},{"text":"interface Called By interface~~metis_meshtonodal~~CalledByGraph interface~metis_meshtonodal METIS_MeshToNodal proc~fmetis_meshtonodal FMETIS_MeshToNodal proc~fmetis_meshtonodal->interface~metis_meshtonodal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public function METIS_MeshToNodal(ne, nn, eptr, eind, numflag, xadj, adjncy) result(ierr) bind(C,name=\"METIS_MeshToNodal\") Arguments Type Intent Optional Attributes Name integer(kind=idx_t), intent(in) :: ne The number of elements in the mesh. integer(kind=idx_t), intent(in) :: nn The number of nodes in the mesh. integer(kind=idx_t), intent(in), dimension(*) :: eptr The pair of arrays storing the mesh as described in Section 5.6 of the manual . integer(kind=idx_t), intent(in), dimension(*) :: eind The pair of arrays storing the mesh as described in Section 5.6 of the manual . integer(kind=idx_t), intent(in) :: numflag Used to indicate which numbering scheme is used for eptr and eind .\n The possible values are: 0 - C-style numbering is assumed that starts from 0 1 - Fortran-style numbering is assumed that starts from 1 type(c_ptr), intent(out) :: xadj These arrays store the adjacency structure of the generated dual graph. \n The format of the adjacency structure is described in Section 5.5 of the manual . type(c_ptr), intent(out) :: adjncy These arrays store the adjacency structure of the generated dual graph. \n The format of the adjacency structure is described in Section 5.5 of the manual . Return Value integer(kind=idx_t) METIS_OK - Indicates that the function returned normally. METIS_ERROR_INPUT - Indicates an input error. METIS_ERROR_MEMORY - Indicates that it could not allocate the required memory. METIS_ERROR - Indicates some other type of error. Description This function is used to generate the nodal graph of a mesh. Note To use the returned arrays xadj and adjncy , these must be first converted from\n a C pointer to a Fortran pointer using the subroutine c_f_pointer(cptr,fptr,shape) that assigns the target of the C pointer cptr to the Fortran pointer fptr and\n specifies its shape. The shape is an integer rank-one array, storing the size nn+1 in case of the nodal graph. The size of the new adjncy array is stored in the \n last element of xadj when using C-style numbering. An example is shown below. Warning Memory for the returned arrays xadj and adjncy is allocated by METIS' API in C\n using the standard malloc function. It is the responsibility of the application to free\n this memory by calling free . Therefore, METIS provides the METIS_Free function that is a wrapper to\n C's free function. Example The code below generates the nodal graph of the following mesh: image use iso_c_binding , only : c_ptr , c_f_pointer use metis_interface , only : idx_t , METIS_MeshToNodal , METIS_Free integer ( kind = idx_t ), parameter :: ne = 3 , nn = 8 , npel = 4 integer ( kind = idx_t ) :: ierr , eptr ( ne + 1 ), eind ( ne * npel ), numflag type ( c_ptr ) :: xadj , adjncy integer ( kind = idx_t ), dimension (:), pointer :: fxadj => null (), fadjncy => null () numflag = 0 ! C-style numbering eptr = [ 0 , 4 , 8 , 12 ] eind = [ 0 , 1 , 2 , 3 , 1 , 4 , 5 , 2 , 4 , 6 , 7 , 5 ] ! note four nodes per element ierr = METIS_MeshToNodal ( ne , nn , eptr , eind , numflag , xadj , adjncy ) call c_f_pointer ( xadj , fxadj , shape = [ nn + 1 ]) ! xadj is of the size nn+1 call c_f_pointer ( adjncy , fadjncy , shape = [ fxadj ( nn + 1 )]) ! last value in xadj is the size of adjncy !... use values in fxadj and fadjncy ... call METIS_Free ( xadj ) call METIS_Free ( adjncy ) end","tags":"","loc":"interface/metis_meshtonodal.html","title":"METIS_MeshToNodal – Fortran METIS Interface"},{"text":"interface public function METIS_SetDefaultOptions(options) result(ierr) bind(C,name=\"METIS_SetDefaultOptions\") Arguments Type Intent Optional Attributes Name integer(kind=idx_t), intent(out) :: options (METIS_NOPTIONS) The array of options that will be initialized. Return Value integer(kind=idx_t) METIS_OK - Indicates that the function returned normally. Description Initializes the options array into its default values. Note The passed array options must have the size METIS_NOPTIONS (40).\n To be able to use the option parameters specified in the metis_interface module \n it is recommended to use zero-based indexing for the options array: integer ( kind = idx_t ) :: opts ( 0 : 39 ) Examples To set Fortran style index-numbering use: use metis_enum , only : METIS_OPTION_NUMBERING use metis_interface , only : idx_t , METIS_SetDefaultOptions integer ( kind = idx_t ) :: opts ( 0 : 39 ) call METIS_SetDefaultOptions ( opts ) opts ( METIS_OPTION_NUMBERING ) = 1 ! Fortran-style index numbering Other options can also be changed using parameters specified in the metis_interface module. use metis_enum , only : METIS_OPTION_DBGLVL , METIS_DBG_INFO use metis_interface , only : idx_t , METIS_SetDefaultOptions integer ( kind = idx_t ) :: opts ( 0 : 39 ) call METIS_SetDefaultOptions ( opts ) opts ( METIS_OPTION_DBGLVL ) = METIS_DBG_INFO ! Show various diagnostic messages end","tags":"","loc":"interface/metis_setdefaultoptions.html","title":"METIS_SetDefaultOptions – Fortran METIS Interface"},{"text":"interface Called By interface~~metis_free~~CalledByGraph interface~metis_free METIS_Free proc~fmetis_meshtonodal FMETIS_MeshToNodal proc~fmetis_meshtonodal->interface~metis_free Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public function METIS_Free(ptr) result(ierr) bind(C,name=\"METIS_Free\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: ptr The pointer to be freed. This pointer should be one of the xadj or adjncy arrays returned by METIS' API routines. Return Value integer(kind=idx_t) METIS_OK - Indicates that the function returned normally. Description Frees the memory that was allocated by either the METIS_MeshToDual or the METIS_MeshToNodal routines for returning the dual or nodal graph of a mesh. Warning Memory deallocation should always happen on the same side it was allocated!\n Also check the descriptions of the above-mentioned routines. Example type ( c_ptr ) :: xadj (:), adjncy (:) call METIS_MeshToNodal (..., xadj , adjncy ) ! xadj and adjncy should be deallocated on the C side! ;) call METIS_Free ( xadj ) call METIS_Free ( adjncy )","tags":"","loc":"interface/metis_free.html","title":"METIS_Free – Fortran METIS Interface"},{"text":"public function whitechar(char) Arguments Type Intent Optional Attributes Name character, intent(in) :: char Return Value logical Called By proc~~whitechar~~CalledByGraph proc~whitechar whitechar proc~count_columns count_columns proc~count_columns->proc~whitechar proc~read_graph read_graph proc~read_graph->proc~whitechar proc~read_graph->proc~count_columns proc~import_graph import_graph proc~import_graph->proc~read_graph Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/whitechar.html","title":"whitechar – Fortran METIS Interface"},{"text":"public function count_columns(unit, stat) result(ncol) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit integer, intent(out) :: stat Return Value integer Calls proc~~count_columns~~CallsGraph proc~count_columns count_columns proc~whitechar whitechar proc~count_columns->proc~whitechar Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~count_columns~~CalledByGraph proc~count_columns count_columns proc~read_graph read_graph proc~read_graph->proc~count_columns proc~import_graph import_graph proc~import_graph->proc~read_graph Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/count_columns.html","title":"count_columns – Fortran METIS Interface"},{"text":"public function FMETIS_MeshToNodal(ne, nn, eptr, eind, numflag, xadj, adjncy, stat) result(ierr) Uses: iso_c_binding proc~~fmetis_meshtonodal~~UsesGraph proc~fmetis_meshtonodal FMETIS_MeshToNodal iso_c_binding iso_c_binding iso_c_binding->proc~fmetis_meshtonodal Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: ne integer(kind=c_int), intent(in) :: nn integer(kind=c_int), intent(in) :: eptr (ne+1) integer(kind=c_int), intent(in) :: eind (:) integer(kind=c_int), intent(in) :: numflag integer(kind=c_int), intent(out), allocatable :: xadj (:) integer(kind=c_int), intent(out), allocatable :: adjncy (:) integer(kind=c_int), intent(out), optional :: stat Return Value integer(kind=c_int) Calls proc~~fmetis_meshtonodal~~CallsGraph proc~fmetis_meshtonodal FMETIS_MeshToNodal interface~metis_free METIS_Free proc~fmetis_meshtonodal->interface~metis_free interface~metis_meshtonodal METIS_MeshToNodal proc~fmetis_meshtonodal->interface~metis_meshtonodal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/fmetis_meshtonodal.html","title":"FMETIS_MeshToNodal – Fortran METIS Interface"},{"text":"public subroutine import_graph(fname, graph, numflag) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname class( graph_type ), intent(out) :: graph integer, intent(in), optional :: numflag Calls proc~~import_graph~~CallsGraph proc~import_graph import_graph proc~read_graph read_graph proc~import_graph->proc~read_graph proc~count_columns count_columns proc~read_graph->proc~count_columns proc~whitechar whitechar proc~read_graph->proc~whitechar proc~count_columns->proc~whitechar Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/import_graph.html","title":"import_graph – Fortran METIS Interface"},{"text":"public subroutine export_graph(fname, graph) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname class( graph_type ), intent(in) :: graph Calls proc~~export_graph~~CallsGraph proc~export_graph export_graph proc~write_graph write_graph proc~export_graph->proc~write_graph Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/export_graph.html","title":"export_graph – Fortran METIS Interface"},{"text":"public subroutine write_graph(unit, xadj, adjncy, numflag, vwgt, adjwgt, vsize) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit integer, intent(in) :: xadj (:) integer, intent(in) :: adjncy (:) integer, intent(in), optional :: numflag integer, intent(in), optional :: vwgt (:) integer, intent(in), optional :: adjwgt (:) integer, intent(in), optional :: vsize (:) Called By proc~~write_graph~~CalledByGraph proc~write_graph write_graph proc~export_graph export_graph proc~export_graph->proc~write_graph Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/write_graph.html","title":"write_graph – Fortran METIS Interface"},{"text":"public subroutine read_graph(unit, xadj, adjncy, numflag, vwgt, adjwgt, vsize) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit integer, intent(out), pointer :: xadj (:) integer, intent(out), pointer :: adjncy (:) integer, intent(in), optional :: numflag integer, optional pointer :: vwgt (:) integer, intent(out), optional pointer :: adjwgt (:) integer, intent(out), optional pointer :: vsize (:) Calls proc~~read_graph~~CallsGraph proc~read_graph read_graph proc~count_columns count_columns proc~read_graph->proc~count_columns proc~whitechar whitechar proc~read_graph->proc~whitechar proc~count_columns->proc~whitechar Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~read_graph~~CalledByGraph proc~read_graph read_graph proc~import_graph import_graph proc~import_graph->proc~read_graph Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/read_graph.html","title":"read_graph – Fortran METIS Interface"},{"text":"public subroutine print_metis_options(opts, unit) Uses: iso_fortran_env proc~~print_metis_options~~UsesGraph proc~print_metis_options print_metis_options iso_fortran_env iso_fortran_env iso_fortran_env->proc~print_metis_options Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Arguments Type Intent Optional Attributes Name integer, intent(in) :: opts (0:) integer, intent(in), optional :: unit","tags":"","loc":"proc/print_metis_options.html","title":"print_metis_options – Fortran METIS Interface"},{"text":"Uses: iso_c_binding module~~metis_interface~~UsesGraph module~metis_interface metis_interface iso_c_binding iso_c_binding iso_c_binding->module~metis_interface Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. A Fortran interface to the METIS graph partitioning library. http://glaros.dtc.umn.edu/gkhome/node/877 Used By module~~metis_interface~~UsedByGraph module~metis_interface metis_interface program~test_partmeshnodal2 test_PartMeshNodal2 module~metis_interface->program~test_partmeshnodal2 program~test_partgraphkway test_PartGraphKway module~metis_interface->program~test_partgraphkway program~test_partgraphrecursive1 test_PartGraphRecursive1 module~metis_interface->program~test_partgraphrecursive1 program~test_partgraphrecursive2 test_PartGraphRecursive2 module~metis_interface->program~test_partgraphrecursive2 module~metis_oo_interface metis_oo_interface module~metis_interface->module~metis_oo_interface program~test_partmeshnodal1 test_PartMeshNodal1 module~metis_interface->program~test_partmeshnodal1 program~test_nodend test_NodeND module~metis_interface->program~test_nodend Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables idx_t real_t METIS_NOPTIONS METIS_OK METIS_ERROR_INPUT METIS_ERROR_MEMORY METIS_ERROR METIS_OPTION_PTYPE METIS_OPTION_OBJTYPE METIS_OPTION_CTYPE METIS_OPTION_IPTYPE METIS_OPTION_RTYPE METIS_OPTION_DBGLVL METIS_OPTION_NITER METIS_OPTION_NCUTS METIS_OPTION_SEED METIS_OPTION_NO2HOP METIS_OPTION_MINCONN METIS_OPTION_CONTIG METIS_OPTION_COMPRESS METIS_OPTION_CCORDER METIS_OPTION_PFACTOR METIS_OPTION_NSEPS METIS_OPTION_UFACTOR METIS_OPTION_NUMBERING METIS_PTYPE_RB METIS_PTYPE_KWAY METIS_CTYPE_RM METIS_CTYPE_SHEM METIS_IPTYPE_GROW METIS_IPTYPE_RANDOM METIS_IPTYPE_EDGE METIS_IPTYPE_NODE METIS_IPTYPE_METISRB METIS_RTYPE_FM METIS_RTYPE_GREEDY METIS_RTYPE_SEP2SIDED METIS_RTYPE_SEP1SIDED METIS_DBG_INFO METIS_DBG_TIME METIS_DBG_COARSEN METIS_DBG_REFINE METIS_DBG_IPART METIS_DBG_MOVEINFO METIS_DBG_SEPINFO METIS_DBG_CONNINFO METIS_DBG_CONTIGINFO METIS_DBG_MEMORY METIS_OBJTYPE_CUT METIS_OBJTYPE_VOL METIS_OBJTYPE_NODE Interfaces METIS_PartGraphRecursive METIS_PartGraphKway METIS_PartMeshDual METIS_PartMeshNodal METIS_NodeND METIS_MeshToDual METIS_MeshToNodal METIS_SetDefaultOptions METIS_Free Variables Type Visibility Attributes Name Initial integer, public, parameter :: idx_t = c_int32_t integer, public, parameter :: real_t = c_float integer(kind=idx_t), public, parameter :: METIS_NOPTIONS = 40 Number of METIS OPTIONS integer(kind=idx_t), public, parameter :: METIS_OK = 1 Returned normally. integer(kind=idx_t), public, parameter :: METIS_ERROR_INPUT = -2 Returned due to erroneous inputs and/or options. integer(kind=idx_t), public, parameter :: METIS_ERROR_MEMORY = -3 Returned due to insufficient memory. integer(kind=idx_t), public, parameter :: METIS_ERROR = -4 Return status: some other type of error. integer(kind=idx_t), public, parameter :: METIS_OPTION_PTYPE = 0 Specifies the partitioning method. integer(kind=idx_t), public, parameter :: METIS_OPTION_OBJTYPE = 1 Specifies the type of objective. integer(kind=idx_t), public, parameter :: METIS_OPTION_CTYPE = 2 Specifies the matching scheme to be used during coarsening. integer(kind=idx_t), public, parameter :: METIS_OPTION_IPTYPE = 3 Determines the algorithm used during initial partitioning. integer(kind=idx_t), public, parameter :: METIS_OPTION_RTYPE = 4 Determines the algorithm used for refinement. integer(kind=idx_t), public, parameter :: METIS_OPTION_DBGLVL = 5 Specifies the amount of progress/debugging information will be printed. integer(kind=idx_t), public, parameter :: METIS_OPTION_NITER = 6 Specifies the number of iterations for the refinement algorithm. integer(kind=idx_t), public, parameter :: METIS_OPTION_NCUTS = 7 Specifies the number of different partitionings that it will compute. integer(kind=idx_t), public, parameter :: METIS_OPTION_SEED = 8 Specifies the seed for the random number generator. integer(kind=idx_t), public, parameter :: METIS_OPTION_NO2HOP = 9 Specifies that the coarsening will not perform any 2–hop matchings when the standard matching approach fails to sufficiently coarsen the graph. integer(kind=idx_t), public, parameter :: METIS_OPTION_MINCONN = 10 Specifies that the partitioning routines should try to minimize the maximum degree of the subdomain graph. integer(kind=idx_t), public, parameter :: METIS_OPTION_CONTIG = 11 Specifies that the partitioning routines should try to produce partitions that are contigous. integer(kind=idx_t), public, parameter :: METIS_OPTION_COMPRESS = 12 Specifies that the graph should be compressed by combining together vertices that have identical adjacency lists. integer(kind=idx_t), public, parameter :: METIS_OPTION_CCORDER = 13 Specifies if the connected components of the graph should first be identifies and ordered separately. integer(kind=idx_t), public, parameter :: METIS_OPTION_PFACTOR = 14 Specifies the minimum degree of the vertices that will be ordered last. integer(kind=idx_t), public, parameter :: METIS_OPTION_NSEPS = 15 Specifies the number of different separators that it will compute at each level of nested dissection. integer(kind=idx_t), public, parameter :: METIS_OPTION_UFACTOR = 16 Specifies the maximum allowed load imbalance among the partitions. integer(kind=idx_t), public, parameter :: METIS_OPTION_NUMBERING = 17 Used to indicate which numbering scheme is used for the adjacency structure of a graph or the element-node structure of a mesh integer(kind=idx_t), public, parameter :: METIS_PTYPE_RB = 0 Multilevel recursive bisectioning. integer(kind=idx_t), public, parameter :: METIS_PTYPE_KWAY = 1 Multilevel k-way partitioning. integer(kind=idx_t), public, parameter :: METIS_CTYPE_RM = 0 Random matching. integer(kind=idx_t), public, parameter :: METIS_CTYPE_SHEM = 1 Sorted heavy-edge matching. integer(kind=idx_t), public, parameter :: METIS_IPTYPE_GROW = 0 Grows a bisection using a greedy strategy. integer(kind=idx_t), public, parameter :: METIS_IPTYPE_RANDOM = 1 Computes a bisection at random followed by a refinement. integer(kind=idx_t), public, parameter :: METIS_IPTYPE_EDGE = 2 Derives a separator form an edge cut. integer(kind=idx_t), public, parameter :: METIS_IPTYPE_NODE = 3 Grows a bisection using a greedy node-based strategy. integer(kind=idx_t), public, parameter :: METIS_IPTYPE_METISRB = 4 integer(kind=idx_t), public, parameter :: METIS_RTYPE_FM = 0 FM-based cut refinement. integer(kind=idx_t), public, parameter :: METIS_RTYPE_GREEDY = 1 Greedy-based cut and volume refinement. integer(kind=idx_t), public, parameter :: METIS_RTYPE_SEP2SIDED = 2 Two-sided node FM refinement. integer(kind=idx_t), public, parameter :: METIS_RTYPE_SEP1SIDED = 3 One-sided node FM refinement. integer(kind=idx_t), public, parameter :: METIS_DBG_INFO = 1 Shows various diagnostic messages. integer(kind=idx_t), public, parameter :: METIS_DBG_TIME = 2 Perform timing analysis. integer(kind=idx_t), public, parameter :: METIS_DBG_COARSEN = 4 Show the coarsening progress. integer(kind=idx_t), public, parameter :: METIS_DBG_REFINE = 8 Show the refinement progress. integer(kind=idx_t), public, parameter :: METIS_DBG_IPART = 16 Show info on initial partitioning. integer(kind=idx_t), public, parameter :: METIS_DBG_MOVEINFO = 32 Show info on vertex moves during refinement. integer(kind=idx_t), public, parameter :: METIS_DBG_SEPINFO = 64 Show info on vertex moves during sep refinement. integer(kind=idx_t), public, parameter :: METIS_DBG_CONNINFO = 128 Show info on minimization of subdomain connectivity. integer(kind=idx_t), public, parameter :: METIS_DBG_CONTIGINFO = 256 Show info on elimination of connected components. integer(kind=idx_t), public, parameter :: METIS_DBG_MEMORY = 2048 Show info related to wspace allocation. integer(kind=idx_t), public, parameter :: METIS_OBJTYPE_CUT = 0 Edge-cut minimization. integer(kind=idx_t), public, parameter :: METIS_OBJTYPE_VOL = 1 Total communication volume minimization. integer(kind=idx_t), public, parameter :: METIS_OBJTYPE_NODE = 2 Interfaces interface public function METIS_PartGraphRecursive (nvtxs, ncon, xadj, adjncy, vwgt, vsize, adjwgt, nparts, tpwgts, ubvec, options, objval, part) result(ierr) bind(C,name=\"METIS_PartGraphRecursive\") This function is used to partition a graph into nparts parts using recursive bisection. Arguments Type Intent Optional Attributes Name integer(kind=idx_t), intent(in) :: nvtxs The number of vertices in the graph. integer(kind=idx_t), intent(in) :: ncon The number of balancing constraints. It should be atleast 1. integer(kind=idx_t), intent(in), dimension(*) :: xadj The adjacency structure of the graph as described in section 5.5 of the manual . integer(kind=idx_t), intent(in), dimension(*) :: adjncy The adjacency structure of the graph as described in section 5.5 of the manual . integer(kind=idx_t), intent(in), optional dimension(*) :: vwgt The weights of the vertices as described in Section 5.5 of the manual . integer(kind=idx_t), intent(in), optional dimension(*) :: vsize The size of the vertices for computing the total communication volume as described in section 5.7 of the manual . integer(kind=idx_t), intent(in), optional dimension(*) :: adjwgt The weights of the edges as describe in Section 5.5 of the manual . integer(kind=idx_t), intent(in) :: nparts The number of parts to partition the graph. real(kind=real_t), intent(in), optional :: tpwgts (nparts*ncon) An array of size nparts*ncon that specifies the desired weight for each partition and constraint.\n If not present, the graph is divided equally among the partitions. More in the description. real(kind=real_t), intent(in), optional :: ubvec (ncon) An array of size ncon that specifies the allowed load imbalance for each constraint. \n For the i -th partition and j -th constraint the allowed weight is the ubvec(j)*tpwgts(i*ncon+j) fraction of the j -th's constraint total weight. If not present, the load imbalance\n tolerance is 1.001 (for ncon = 1 ) or 1.01 (for ncon > 1 ). integer(kind=idx_t), intent(in), optional :: options (METIS_NOPTIONS) An array of options as described in Section 5.4 of the METIS manual. See description for valid options. integer(kind=idx_t), intent(out) :: objval Upon successful completion, this variable stores the edge-cut or the total communication volume of the partitioning\n solution. The value returned depends on the partitioning's objective function. integer(kind=idx_t), intent(out) :: part (nvtxs) This is a vector of size nvtxs that upon successful completion stores the partition vector of the graph.\n The numbering of this vector starts from either 0 or 1, depending on the value of options(METIS_OPTION_NUMBERING) . Return Value integer(kind=idx_t) METIS_OK - Indicates that the function returned normally. METIS_ERROR_INPUT - Indicates an input error. METIS_ERROR_MEMORY - Indicates that it could not allocate the required memory. METIS_ERROR - Indicates some other type of error. interface public function METIS_PartGraphKway (nvtxs, ncon, xadj, adjncy, vwgt, vsize, adjwgt, nparts, tpwgts, ubvec, options, objval, part) result(ierr) bind(C,name=\"METIS_PartGraphKway\") This function is used to partition a graph into nparts parts using multilevel k-way partitioning. Arguments Type Intent Optional Attributes Name integer(kind=idx_t), intent(in) :: nvtxs The number of vertices in the graph. integer(kind=idx_t), intent(in) :: ncon The number of balancing constraints. It should be at least 1. integer(kind=idx_t), intent(in), dimension(*) :: xadj The adjacency structure of the graph as described in section 5.5 of the manual . integer(kind=idx_t), intent(in), dimension(*) :: adjncy The adjacency structure of the graph as described in section 5.5 of the manual . integer(kind=idx_t), intent(in), optional dimension(*) :: vwgt The weights of the vertices as described in Section 5.5 of the manual . integer(kind=idx_t), intent(in), optional dimension(*) :: vsize The size of the vertices for computing the total communication volume as described in section 5.7 of the manual . integer(kind=idx_t), intent(in), optional dimension(*) :: adjwgt The weights of the edges as describe in Section 5.5 of the manual . integer(kind=idx_t), intent(in) :: nparts The number of parts to partition the graph. real(kind=real_t), intent(in), optional :: tpwgts (nparts*ncon) An array of size nparts*ncon that specifies the desired weight for each partition and constraint.\n If not present, the graph is divided equally among the partitions. More in the description. real(kind=real_t), intent(in), optional :: ubvec (ncon) An array of size ncon that specifiew the allowed load imbalance for each constraint. \n For the i -th partition and j -th constraint the allowed weight is the ubvec(j)*tpwgts(i*ncon+j) fraction of the j -th's constraint total weight. If not present, the load imbalance\n tolerance is 1.001 (for ncon == 1 ) or 1.01 (for ncon > 1 ). integer(kind=idx_t), intent(in), optional :: options (METIS_NOPTIONS) An array of options as described in Section 5.4 of the manual . See description for valid options. integer(kind=idx_t), intent(out) :: objval Upon successful completion, this variable stores the edge-cut or the total communication volume of the partitioning\n solution. The value returned depends on the partitioning's objective function. integer(kind=idx_t), intent(out) :: part (nvtxs) This is a vector of size nvtxs that upon successful completion stores the partition vector of the graph.\n The numbering of this vector starts from either 0 or 1, depending on the value of options(METIS_OPTION_NUMBERING) . Return Value integer(kind=idx_t) METIS_OK - Indicates that the function returned normally. METIS_ERROR_INPUT - Indicates an input error. METIS_ERROR_MEMORY - Indicates that it could not allocate the required memory. METIS_ERROR - Indicates some other type of error. interface public function METIS_PartMeshDual (ne, nn, eptr, eind, vwgt, vsize, ncommon, nparts, tpwgts, options, objval, epart, npart) result(ierr) bind(C,name=\"METIS_PartMeshDual\") This function is used to partition a mesh into nparts parts based on a partitioning of the mesh's dual graph. Arguments Type Intent Optional Attributes Name integer(kind=idx_t), intent(in) :: ne The number of elements in the mesh. integer(kind=idx_t), intent(in) :: nn The number of nodes in the mesh. integer(kind=idx_t), intent(in), dimension(*) :: eptr The pair of arrays storing the mesh as described in Section 5.6 of the manual . integer(kind=idx_t), intent(in), dimension(*) :: eind The pair of arrays storing the mesh as described in Section 5.6 of the manual . integer(kind=idx_t), intent(in), optional :: vwgt (ne) An array of size ne specifying the weights of the elements. If not present,\n all elements have an equal weight. integer(kind=idx_t), intent(in), optional :: vsize (ne) An array of size ne specifying the size of the elements that is used\n for computing the total comunication volume as described in Section 5.7 of the manual .\n If not present, the objective is cut or all elements have an equal size. integer(kind=idx_t), intent(in) :: ncommon integer(kind=idx_t), intent(in) :: nparts The number of parts to partition the mesh. integer(kind=idx_t), intent(in), optional :: tpwgts (nparts) An array of size nparts that specifies the desired weight for each partition. The target\n partition weight for the i -th partition is specified at tpwgts(i) (the numbering for the \n partitions starts from 0). The sum of the tpwgts entries must be 1.0. If not present, the graph\n is divided equally among the partitions. integer(kind=idx_t), intent(in), optional :: options (METIS_NOPTIONS) An array of options as described in Section 5.4 of the manual . See description for valid options. integer(kind=idx_t), intent(out) :: objval Upon successful completion, this variable stores either the edgecut or the total communication\n volume of the dual graph's partitioning. integer(kind=idx_t), intent(out) :: epart (ne) A vector of size ne that upon successful completion stores the partition vector for the elements\n of the mesh. The numbering of this vector starts from either 0 or 1, depending on the value of options(METIS_OPTION_NUMBERING) . integer(kind=idx_t), intent(out) :: npart (nn) A vector of size nn that upon successful completion stores the partition vector for the nodes \n of the mesh. The numbering of this vector starts from either 0 or 1, depending on the value of options(METIS_OPTION_NUMBERING) . Return Value integer(kind=idx_t) METIS_OK - Indicates that the function returned normally. METIS_ERROR_INPUT - Indicates an input error. METIS_ERROR_MEMORY - Indicates that it could not allocate the required memory. METIS_ERROR - Indicates some other type of error. interface public function METIS_PartMeshNodal (ne, nn, eptr, eind, vwgt, vsize, nparts, tpwgts, options, objval, epart, npart) result(ierr) bind(C,name=\"METIS_PartMeshNodal\") This function us used to partition a mesh into nparts parts based on a \n  partitioning of the mesh's nodal graph. Arguments Type Intent Optional Attributes Name integer(kind=idx_t), intent(in) :: ne The number of elements in the mesh. integer(kind=idx_t), intent(in) :: nn The number of nodes in the mesh. integer(kind=idx_t), intent(in), dimension(*) :: eptr The pair of arrays storing the mesh as described in Section 5.6 of the manual . integer(kind=idx_t), intent(in), dimension(*) :: eind The pair of arrays storing the mesh as described in Section 5.6 of the manual . integer(kind=idx_t), intent(in), optional :: vwgt (nn) An array of size nn specifying weights of the nodes. If not passed, all nodes have an equal weight. integer(kind=idx_t), intent(in), optional :: vsize (nn) An array of size nn specifying the size of the nodes that is used for computing the\n total comunication volume as described in Section 5.7 of the manual . If not passed,\n the objective is cut or all nodes have an equal size. integer(kind=idx_t), intent(in) :: nparts The number of parts to partition the mesh. integer(kind=idx_t), intent(in), optional :: tpwgts (nparts) An array of size nparts that specifies the desired weight for each partition. The target\n partition weight for the i -th partition is specified at tpwgts(i) (the numbering for the \n partitions starts from 0). The sum of the tpwgts entries must be 1.0. If not passed, the graph\n is divided equally among the partitions. integer(kind=idx_t), intent(in), optional :: options (METIS_NOPTIONS) An array of options as described in Section 5.4 of the manual . See description for valid options. integer(kind=idx_t), intent(out) :: objval Upon successful completion, this variable stores either the edgecut or the total communication\n volume of the nodal graph's partitioning. integer(kind=idx_t), intent(out) :: epart (ne) A vector of size ne that upon successful completion stores the partition vector for the elements\n of the mesh. The numbering of this vector starts from either 0 or 1, depending on the value of options(METIS_OPTION_NUMBERING) . integer(kind=idx_t), intent(out) :: npart (nn) A vector of size nn that upon successful completion stores the partition vector for the nodes \n of the mesh. The numbering of this vector starts from either 0 or 1, depending on the value of options(METIS_OPTION_NUMBERING) . Return Value integer(kind=idx_t) METIS_OK - Indicates that the function returned normally. METIS_ERROR_INPUT - Indicates an input error. METIS_ERROR_MEMORY - Indicates that it could not allocate the required memory. METIS_ERROR - Indicates some other type of error. interface public function METIS_NodeND (nvtxs, xadj, adjncy, vwgt, options, perm, iperm) result(ierr) bind(C,name=\"METIS_NodeND\") This function computes fill reducing orderings of sparse matrices using the\n  multilevel nested dissection algorithm. Arguments Type Intent Optional Attributes Name integer(kind=idx_t), intent(in) :: nvtxs The number of vertices in the graph. integer(kind=idx_t), intent(in), dimension(*) :: xadj The adjacency structure of the graph as described in Section 5.5 of the manual . integer(kind=idx_t), intent(in), dimension(*) :: adjncy The adjacency structure of the graph as described in Section 5.5 of the manual . integer(kind=idx_t), intent(in), optional :: vwgt (nvtxs) An array of size nvtxs specifying the weights of the vertices. integer(kind=idx_t), intent(in), optional :: options (METIS_NOPTIONS) This is the array of options as described in Section 5.4 of the manual . See description for valid options. integer(kind=idx_t), intent(out) :: perm (nvtxs) Vectors of size nvtxs . Upon successful completion, they store the fill-reducing\n permutation and inverse-permutation. More in the description. integer(kind=idx_t), intent(out) :: iperm (nvtxs) Vectors of size nvtxs . Upon successful completion, they store the fill-reducing\n permutation and inverse-permutation. More in the description. Return Value integer(kind=idx_t) METIS_OK - Indicates that the function returned normally. METIS_ERROR_INPUT - Indicates an input error. METIS_ERROR_MEMORY - Indicates that it could not allocate the required memory. METIS_ERROR - Indicates some other type of error. interface public function METIS_MeshToDual (ne, nn, eptr, eind, ncommon, numflag, xadj, adjncy) result(ierr) bind(C,name=\"METIS_MeshToDual\") This function is used to generate the dual graph of a mesh. Arguments Type Intent Optional Attributes Name integer(kind=idx_t), intent(in) :: ne The number of elements in the mesh. integer(kind=idx_t), intent(in) :: nn The number of nodes in the mesh. integer(kind=idx_t), intent(in), dimension(*) :: eptr The pair of arrays storing the mesh as described in Section 5.6 of the manual . integer(kind=idx_t), intent(in), dimension(*) :: eind The pair of arrays storing the mesh as described in Section 5.6 of the manual . integer(kind=idx_t), intent(in) :: ncommon The number of common nodes that two elements must have in order to put\n an edge between them in the dual graph. integer(kind=idx_t), intent(in) :: numflag Used to indicate which numbering scheme is used for eptr and eind . \n The possible values are: 0 - C-style numbering is assumed that starts from 0 1 - Fortran-style numbering is assumed that starts from 1 type(c_ptr), intent(out) :: xadj These arrays store the adjacency structure of the generated dual graph. \n The format of the adjacency structure is described in Section 5.5 of the manual . type(c_ptr), intent(out) :: adjncy These arrays store the adjacency structure of the generated dual graph. \n The format of the adjacency structure is described in Section 5.5 of the manual . Return Value integer(kind=idx_t) METIS_OK - Indicates that the function returned normally. METIS_ERROR_INPUT - Indicates an input error. METIS_ERROR_MEMORY - Indicates that it could not allocate the required memory. METIS_ERROR - Indicates some other type of error. interface public function METIS_MeshToNodal (ne, nn, eptr, eind, numflag, xadj, adjncy) result(ierr) bind(C,name=\"METIS_MeshToNodal\") This function is used to generate the nodal graph of a mesh. Arguments Type Intent Optional Attributes Name integer(kind=idx_t), intent(in) :: ne The number of elements in the mesh. integer(kind=idx_t), intent(in) :: nn The number of nodes in the mesh. integer(kind=idx_t), intent(in), dimension(*) :: eptr The pair of arrays storing the mesh as described in Section 5.6 of the manual . integer(kind=idx_t), intent(in), dimension(*) :: eind The pair of arrays storing the mesh as described in Section 5.6 of the manual . integer(kind=idx_t), intent(in) :: numflag Used to indicate which numbering scheme is used for eptr and eind .\n The possible values are: 0 - C-style numbering is assumed that starts from 0 1 - Fortran-style numbering is assumed that starts from 1 type(c_ptr), intent(out) :: xadj These arrays store the adjacency structure of the generated dual graph. \n The format of the adjacency structure is described in Section 5.5 of the manual . type(c_ptr), intent(out) :: adjncy These arrays store the adjacency structure of the generated dual graph. \n The format of the adjacency structure is described in Section 5.5 of the manual . Return Value integer(kind=idx_t) METIS_OK - Indicates that the function returned normally. METIS_ERROR_INPUT - Indicates an input error. METIS_ERROR_MEMORY - Indicates that it could not allocate the required memory. METIS_ERROR - Indicates some other type of error. interface public function METIS_SetDefaultOptions (options) result(ierr) bind(C,name=\"METIS_SetDefaultOptions\") Initializes the options array into its default values. Arguments Type Intent Optional Attributes Name integer(kind=idx_t), intent(out) :: options (METIS_NOPTIONS) The array of options that will be initialized. Return Value integer(kind=idx_t) METIS_OK - Indicates that the function returned normally. interface public function METIS_Free (ptr) result(ierr) bind(C,name=\"METIS_Free\") Frees the memory that was allocated by either the METIS_MeshToDual or the METIS_MeshToNodal routines for returning the dual or nodal graph of a mesh. Arguments Type Intent Optional Attributes Name type(c_ptr), value :: ptr The pointer to be freed. This pointer should be one of the xadj or adjncy arrays returned by METIS' API routines. Return Value integer(kind=idx_t) METIS_OK - Indicates that the function returned normally.","tags":"","loc":"module/metis_interface.html","title":"metis_interface – Fortran METIS Interface"},{"text":"Uses: metis_interface module~~metis_oo_interface~~UsesGraph module~metis_oo_interface metis_oo_interface module~metis_interface metis_interface module~metis_interface->module~metis_oo_interface iso_c_binding iso_c_binding iso_c_binding->module~metis_interface Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types graph_type Functions whitechar count_columns FMETIS_MeshToNodal Subroutines import_graph export_graph write_graph read_graph print_metis_options Derived Types type, public :: graph_type Components Type Visibility Attributes Name Initial integer, public :: nvxts Number of vertices. integer, public :: nedgs Number of edges. integer, public, pointer :: xadj (:) => null() integer, public, pointer :: adjncy (:) => null() integer, public :: numflag = 1 Numbering style. integer, public :: ncon integer, public, pointer :: vwgt (:) => null() integer, public, pointer :: adjwgt (:) => null() integer, public, pointer :: vsize (:) => null() Functions public function whitechar (char) Arguments Type Intent Optional Attributes Name character, intent(in) :: char Return Value logical public function count_columns (unit, stat) result(ncol) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit integer, intent(out) :: stat Return Value integer public function FMETIS_MeshToNodal (ne, nn, eptr, eind, numflag, xadj, adjncy, stat) result(ierr) Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: ne integer(kind=c_int), intent(in) :: nn integer(kind=c_int), intent(in) :: eptr (ne+1) integer(kind=c_int), intent(in) :: eind (:) integer(kind=c_int), intent(in) :: numflag integer(kind=c_int), intent(out), allocatable :: xadj (:) integer(kind=c_int), intent(out), allocatable :: adjncy (:) integer(kind=c_int), intent(out), optional :: stat Return Value integer(kind=c_int) Subroutines public subroutine import_graph (fname, graph, numflag) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname class( graph_type ), intent(out) :: graph integer, intent(in), optional :: numflag public subroutine export_graph (fname, graph) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname class( graph_type ), intent(in) :: graph public subroutine write_graph (unit, xadj, adjncy, numflag, vwgt, adjwgt, vsize) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit integer, intent(in) :: xadj (:) integer, intent(in) :: adjncy (:) integer, intent(in), optional :: numflag integer, intent(in), optional :: vwgt (:) integer, intent(in), optional :: adjwgt (:) integer, intent(in), optional :: vsize (:) public subroutine read_graph (unit, xadj, adjncy, numflag, vwgt, adjwgt, vsize) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit integer, intent(out), pointer :: xadj (:) integer, intent(out), pointer :: adjncy (:) integer, intent(in), optional :: numflag integer, optional pointer :: vwgt (:) integer, intent(out), optional pointer :: adjwgt (:) integer, intent(out), optional pointer :: vsize (:) public subroutine print_metis_options (opts, unit) Arguments Type Intent Optional Attributes Name integer, intent(in) :: opts (0:) integer, intent(in), optional :: unit","tags":"","loc":"module/metis_oo_interface.html","title":"metis_oo_interface – Fortran METIS Interface"},{"text":"Uses: metis_interface program~~test_partgraphrecursive1~~UsesGraph program~test_partgraphrecursive1 test_PartGraphRecursive1 module~metis_interface metis_interface module~metis_interface->program~test_partgraphrecursive1 iso_c_binding iso_c_binding iso_c_binding->module~metis_interface Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Calls program~~test_partgraphrecursive1~~CallsGraph program~test_partgraphrecursive1 test_PartGraphRecursive1 metis_partgraphrecursive metis_partgraphrecursive program~test_partgraphrecursive1->metis_partgraphrecursive Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Variables nvtxs nedgs xadj adjncy part objval ios Variables Type Attributes Name Initial integer(kind=idx_t), parameter :: nvtxs = 15 integer(kind=idx_t), parameter :: nedgs = 22 integer(kind=idx_t) :: xadj (nvtxs+1) integer(kind=idx_t) :: adjncy (2*nedgs) integer(kind=idx_t) :: part (nvtxs) integer(kind=idx_t) :: objval integer(kind=idx_t) :: ios","tags":"","loc":"program/test_partgraphrecursive1.html","title":"test_PartGraphRecursive1 – Fortran METIS Interface"},{"text":"Uses: iso_c_binding metis_interface program~~test_partmeshnodal1~~UsesGraph program~test_partmeshnodal1 test_PartMeshNodal1 iso_c_binding iso_c_binding iso_c_binding->program~test_partmeshnodal1 module~metis_interface metis_interface iso_c_binding->module~metis_interface module~metis_interface->program~test_partmeshnodal1 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Calls program~~test_partmeshnodal1~~CallsGraph program~test_partmeshnodal1 test_PartMeshNodal1 metis_meshtonodal metis_meshtonodal program~test_partmeshnodal1->metis_meshtonodal metis_free metis_free program~test_partmeshnodal1->metis_free metis_setdefaultoptions metis_setdefaultoptions program~test_partmeshnodal1->metis_setdefaultoptions metis_partmeshnodal metis_partmeshnodal program~test_partmeshnodal1->metis_partmeshnodal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Variables ne nn npel eptr eind epart npart options ios objval c_xadj c_adjncy xadj adjncy Variables Type Attributes Name Initial integer(kind=idx_t), parameter :: ne = 3 integer(kind=idx_t), parameter :: nn = 8 integer(kind=idx_t), parameter :: npel = 4 integer(kind=idx_t) :: eptr (ne+1) integer(kind=idx_t) :: eind (ne*npel) integer(kind=idx_t) :: epart (ne) integer(kind=idx_t) :: npart (nn) integer(kind=idx_t) :: options (0:METIS_NOPTIONS-1) integer(kind=idx_t) :: ios integer(kind=idx_t) :: objval type(c_ptr) :: c_xadj type(c_ptr) :: c_adjncy integer(kind=idx_t), pointer :: xadj (:) => null() integer(kind=idx_t), pointer :: adjncy (:) => null()","tags":"","loc":"program/test_partmeshnodal1.html","title":"test_PartMeshNodal1 – Fortran METIS Interface"},{"text":"Uses: metis_interface program~~test_partgraphkway~~UsesGraph program~test_partgraphkway test_PartGraphKway module~metis_interface metis_interface module~metis_interface->program~test_partgraphkway iso_c_binding iso_c_binding iso_c_binding->module~metis_interface Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Partition a graph specified by a matrix Source: http://people.eecs.berkeley.edu/~demmel/cs267/lecture18/lecture18.html Calls program~~test_partgraphkway~~CallsGraph program~test_partgraphkway test_PartGraphKway metis_partgraphkway metis_partgraphkway program~test_partgraphkway->metis_partgraphkway metis_setdefaultoptions metis_setdefaultoptions program~test_partgraphkway->metis_setdefaultoptions Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Variables npart n m xadj adjncy part options ios objval Variables Type Attributes Name Initial integer(kind=idx_t), parameter :: npart = 3 integer(kind=idx_t), parameter :: n = 8 integer(kind=idx_t), parameter :: m = 10 integer(kind=idx_t) :: xadj (n+1) integer(kind=idx_t) :: adjncy (2*m) integer(kind=idx_t) :: part (n) integer(kind=idx_t) :: options (0:METIS_NOPTIONS-1) integer(kind=idx_t) :: ios integer(kind=idx_t) :: objval","tags":"","loc":"program/test_partgraphkway.html","title":"test_PartGraphKway – Fortran METIS Interface"},{"text":"Uses: metis_interface program~~test_partmeshnodal2~~UsesGraph program~test_partmeshnodal2 test_PartMeshNodal2 module~metis_interface metis_interface module~metis_interface->program~test_partmeshnodal2 iso_c_binding iso_c_binding iso_c_binding->module~metis_interface Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Example of partitioning a mesh composed of 4 quadrilaterals and 9 nodes\n   based upon its nodal graph. Source: https://www.cfd-online.com/Forums/main/112366-using-metis-functions-fortran.html#post404734 Calls program~~test_partmeshnodal2~~CallsGraph program~test_partmeshnodal2 test_PartMeshNodal2 metis_setdefaultoptions metis_setdefaultoptions program~test_partmeshnodal2->metis_setdefaultoptions metis_partmeshnodal metis_partmeshnodal program~test_partmeshnodal2->metis_partmeshnodal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Variables ne nn eptr eind epart npart opts ios objval Variables Type Attributes Name Initial integer(kind=idx_t), parameter :: ne = 4 integer(kind=idx_t), parameter :: nn = 9 integer(kind=idx_t) :: eptr (ne+1) integer(kind=idx_t) :: eind (4*ne) integer(kind=idx_t) :: epart (ne) integer(kind=idx_t) :: npart (nn) integer(kind=idx_t) :: opts (0:METIS_NOPTIONS-1) integer(kind=idx_t) :: ios integer(kind=idx_t) :: objval","tags":"","loc":"program/test_partmeshnodal2.html","title":"test_PartMeshNodal2 – Fortran METIS Interface"},{"text":"Uses: metis_interface program~~test_partgraphrecursive2~~UsesGraph program~test_partgraphrecursive2 test_PartGraphRecursive2 module~metis_interface metis_interface module~metis_interface->program~test_partgraphrecursive2 iso_c_binding iso_c_binding iso_c_binding->module~metis_interface Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Partitioning a graph with non-equal number of edges per node. Calls program~~test_partgraphrecursive2~~CallsGraph program~test_partgraphrecursive2 test_PartGraphRecursive2 metis_partgraphrecursive metis_partgraphrecursive program~test_partgraphrecursive2->metis_partgraphrecursive metis_setdefaultoptions metis_setdefaultoptions program~test_partgraphrecursive2->metis_setdefaultoptions Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Variables n m xadj adjncy part options ios ncon objval Variables Type Attributes Name Initial integer(kind=idx_t) :: n integer(kind=idx_t) :: m integer(kind=idx_t), allocatable :: xadj (:) integer(kind=idx_t), allocatable :: adjncy (:) integer(kind=idx_t), allocatable :: part (:) integer(kind=idx_t) :: options (0:METIS_NOPTIONS-1) integer(kind=idx_t) :: ios integer(kind=idx_t) :: ncon integer(kind=idx_t) :: objval","tags":"","loc":"program/test_partgraphrecursive2.html","title":"test_PartGraphRecursive2 – Fortran METIS Interface"},{"text":"Uses: metis_interface program~~test_nodend~~UsesGraph program~test_nodend test_NodeND module~metis_interface metis_interface module~metis_interface->program~test_nodend iso_c_binding iso_c_binding iso_c_binding->module~metis_interface Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Example of computing a fill-reducing ordering of a sparse matrix Source: http://comp.lang.fortran.narkive.com/uFmDM7Bo/how-to-call-a-metis-subroutine-from-my-fortran-code Calls program~~test_nodend~~CallsGraph program~test_nodend test_NodeND metis_setdefaultoptions metis_setdefaultoptions program~test_nodend->metis_setdefaultoptions metis_nodend metis_nodend program~test_nodend->metis_nodend Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Variables n m xadj adjncy perm iperm options ios Variables Type Attributes Name Initial integer(kind=idx_t), parameter :: n = 15 integer(kind=idx_t), parameter :: m = 22 integer(kind=idx_t) :: xadj (n+1) integer(kind=idx_t) :: adjncy (2*m) integer(kind=idx_t) :: perm (n) integer(kind=idx_t) :: iperm (n) integer(kind=idx_t) :: options (0:METIS_NOPTIONS-1) integer(kind=idx_t) :: ios","tags":"","loc":"program/test_nodend.html","title":"test_NodeND – Fortran METIS Interface"}]}