var tipuesearch = {"pages":[{"text":"Fortran METIS Interface Brief description This is a Fortran interface to the METIS software package for partitioning unstructured graphs, partitioning meshes, and computing fill-reducing orderings\nof sparse matrices. The interface makes use of the C interoperability features available in modern Fortran \n(i.e., Fortran 2003+) and provides a simple and safe way to call the original serial routines. License Further information METIS Home page METIS Manual (PDF) Developer Info Ivan Pribec","tags":"","loc":"index.html","title":" Fortran METIS Interface "},{"text":"This File Depends On sourcefile~~test_partgraphrecursive1.f90~~EfferentGraph sourcefile~test_partgraphrecursive1.f90 test_PartGraphRecursive1.f90 sourcefile~metis_interface.f90 metis_interface.f90 sourcefile~metis_interface.f90->sourcefile~test_partgraphrecursive1.f90 sourcefile~metis_enum.f90 metis_enum.f90 sourcefile~metis_enum.f90->sourcefile~test_partgraphrecursive1.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs test_PartGraphRecursive1 Source Code test_PartGraphRecursive1.f90 Source Code ! https://stackoverflow.com/questions/8155160/metis-with-fortran ! http://glaros.dtc.umn.edu/gkhome/node/799 program test_PartGraphRecursive1 use iso_c_binding , only : c_int use metis_interface , only : METIS_PartGraphRecursive use metis_enum , only : METIS_OK implicit none integer ( c_int ), parameter :: nvtxs = 15 ! number of vertices integer ( c_int ), parameter :: nedgs = 22 ! number of edges integer ( c_int ) :: xadj ( nvtxs + 1 ), adjncy ( 2 * nedgs ) ! adjacency arrays integer ( c_int ) :: part ( nvtxs ) ! partiotion vector integer ( c_int ) :: objval , ios write ( * , '(A)' ) \"TEST METIS_PartGraphRecursive 1\" !  0---1---2---3---4 !  |   |   |   |   | !  5---6---7---8---9 !  |   |   |   |   | ! 10--11--12--13--14 ! Note that we are using C-style numbering! xadj = [ 0 , 2 , 5 , 8 , 11 , 13 , 16 , 20 , 24 , 28 , 31 , 33 , 36 , 39 , 42 , 44 ] adjncy = [ 1 , 5 , 0 , 2 , 6 , 1 , 3 , 7 , 2 , 4 , 8 , 3 , 9 , 0 , 6 , 10 , 1 , 5 , 7 , 11 , 2 , 6 , 8 , 12 , 3 , 7 , 9 , 13 , 4 , 8 , 14 , 5 , 11 , 6 , 10 , 12 , 7 , 11 , 13 , 8 , 12 , 14 , 9 , 13 ] ios = METIS_PartGraphRecursive ( nvtxs , ncon = 1 , xadj = xadj , adjncy = adjncy , nparts = 2 , objval = objval , part = part ) if ( ios /= METIS_OK ) then write ( * , * ) \"METIS_PartGraphRecursive failed with error: \" , ios error stop 1 end if write ( * , '(A,I0)' ) \"objval = \" , objval write ( * , '(A,*(I1,:,1X))' ) \"part = \" , part end program","tags":"","loc":"sourcefile/test_partgraphrecursive1.f90.html","title":"test_PartGraphRecursive1.f90 – Fortran METIS Interface"},{"text":"This File Depends On sourcefile~~test_partmeshnodal1.f90~~EfferentGraph sourcefile~test_partmeshnodal1.f90 test_PartMeshNodal1.f90 sourcefile~metis_interface.f90 metis_interface.f90 sourcefile~metis_interface.f90->sourcefile~test_partmeshnodal1.f90 sourcefile~metis_enum.f90 metis_enum.f90 sourcefile~metis_enum.f90->sourcefile~test_partmeshnodal1.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs test_PartMeshNodal1 Source Code test_PartMeshNodal1.f90 Source Code ! https://stackoverflow.com/questions/20006253/using-metis-libraries-in-fortran-code-the-basics ! http://glaros.dtc.umn.edu/gkhome/node/852 program test_PartMeshNodal1 use , intrinsic :: iso_c_binding , only : c_int , c_ptr , c_f_pointer use metis_interface , only : METIS_SetDefaultOptions , METIS_PartMeshNodal , & METIS_MeshToNodal , METIS_Free , METIS_NOPTIONS use metis_enum , only : METIS_OK , METIS_OPTION_NUMBERING implicit none integer ( c_int ), parameter :: ne = 3 ! number of elements integer ( c_int ), parameter :: nn = 8 ! number of nodes integer ( c_int ), parameter :: npel = 4 ! nodes per element integer ( c_int ) :: eptr ( ne + 1 ) integer ( c_int ) :: eind ( ne * npel ) integer ( c_int ) :: epart ( ne ), npart ( nn ) integer ( c_int ) :: options ( 0 : METIS_NOPTIONS - 1 ) integer ( c_int ) :: ios , objval type ( c_ptr ) :: c_xadj , c_adjncy integer ( c_int ), pointer :: xadj (:) => null (), adjncy (:) => null () write ( * , '(A)' ) \"TEST METIS_PartMeshNodal 1\" ! 0---1---4---6 ! | 0 | 1 | 2 | ! 3---2---5---7 eptr = [ 0 , 4 , 8 , 12 ] eind = [ 0 , 1 , 2 , 3 , 1 , 4 , 5 , 2 , 4 , 6 , 7 , 5 ] ios = METIS_SetDefaultOptions ( options ) if ( ios /= METIS_OK ) then write ( * , * ) \"METIS_SetDefaultOptions failed with error: \" , ios error stop 1 end if options ( METIS_OPTION_NUMBERING ) = 0 ! C-style numbering ios = METIS_PartMeshNodal ( ne , nn , eptr , eind , nparts = 2 , options = options ,& objval = objval , epart = epart , npart = npart ) if ( ios /= METIS_OK ) then write ( * , * ) \"METIS_PartMeshNodal failed with error: \" , ios error stop 1 end if write ( * , '(A,I0)' ) \"objval = \" , objval write ( * , '(A,*(I1,:,1X))' ) \"epart = \" , epart write ( * , '(A,*(I1,:,1X))' ) \"npart = \" , npart ios = METIS_MeshToNodal ( ne , nn , eptr , eind , numflag = 0 , xadj = c_xadj , adjncy = c_adjncy ) if ( ios /= METIS_OK ) then write ( * , * ) \"METIS_MeshToNodal failed with error: \" , ios error stop 1 end if call c_f_pointer ( c_xadj , xadj , shape = [ nn + 1 ]) ! size of adjacency list is one more than number of nodes call c_f_pointer ( c_adjncy , adjncy , shape = [ xadj ( nn + 1 )]) ! size of edge list is in the last element of xadj write ( * , '(A,*(I0,:,1X))' ) \"xadj = \" , xadj write ( * , '(A,*(I1,:,1X))' ) \"adjncy = \" , adjncy ! call write_graph(\"test1.graph\",xadj,adjncy,1) ios = METIS_Free ( c_xadj ); xadj => null () if ( ios /= METIS_OK ) then write ( * , * ) \"METIS_Free failed with error: \" , ios error stop 1 end if ios = METIS_Free ( c_adjncy ); adjncy => null () if ( ios /= METIS_OK ) then write ( * , * ) \"METIS_Free failed with error: \" , ios error stop 1 end if end program","tags":"","loc":"sourcefile/test_partmeshnodal1.f90.html","title":"test_PartMeshNodal1.f90 – Fortran METIS Interface"},{"text":"This File Depends On sourcefile~~test_partgraphkway.f90~~EfferentGraph sourcefile~test_partgraphkway.f90 test_PartGraphKway.f90 sourcefile~metis_interface.f90 metis_interface.f90 sourcefile~metis_interface.f90->sourcefile~test_partgraphkway.f90 sourcefile~metis_enum.f90 metis_enum.f90 sourcefile~metis_enum.f90->sourcefile~test_partgraphkway.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs test_PartGraphKway Source Code test_PartGraphKway.f90 Source Code !>  Partition a graph specified by a matrix ! !   Source: http://people.eecs.berkeley.edu/~demmel/cs267/lecture18/lecture18.html ! program test_PartGraphKway use iso_c_binding , only : c_int use metis_interface , only : METIS_PartGraphKway , METIS_SetDefaultOptions , METIS_NOPTIONS use metis_enum , only : METIS_OPTION_NUMBERING , METIS_OK implicit none integer ( c_int ), parameter :: npart = 3 ! number of partitions integer ( c_int ), parameter :: n = 8 ! number of nodes integer ( c_int ), parameter :: m = 10 ! number of edges integer ( c_int ) :: xadj ( n + 1 ), adjncy ( 2 * m ) ! graph adjacency structure integer ( c_int ) :: perm ( n ), iperm ( n ) ! fill-reducing permutation and inverse permutation integer ( c_int ) :: part ( n ) integer ( c_int ) :: options ( 0 : METIS_NOPTIONS - 1 ), ios , objval write ( * , '(A)' ) \"TEST METIS_PartGraphKway\" !    1  2  3  4  5  6  7  8 !  | a  a  a     a          | 1 !  | a  a     a  a          | 2 !  | b     b        b       | 3 !  |    b     b     b       | 4 !  | a  a           a     a | 5 !  |       b  b  b          | 6 !  |                   c  c | 7 !  |             c     c  c | 8 xadj = [ 1 , 4 , 7 , 9 , 11 , 15 , 18 , 19 , 21 ] adjncy = [ 2 , 3 , 5 ,& 1 , 4 , 5 ,& 1 , 6 ,& 2 , 6 ,& 1 , 2 , 6 , 8 ,& 3 , 4 , 5 ,& 8 ,& 5 , 7 ] ios = METIS_SetDefaultOptions ( options ) if ( ios /= METIS_OK ) then write ( * , * ) \"METIS_SetDefaultOptions failed with error: \" , ios error stop 1 end if options ( METIS_OPTION_NUMBERING ) = 1 ! Fortran-style numbering ios = METIS_PartGraphKway ( n , ncon = 1 , xadj = xadj , adjncy = adjncy , nparts = npart , options = options , objval = objval , part = part ) if ( ios /= METIS_OK ) then write ( * , * ) \"METIS_PartGraphKway failed with error: \" , ios error stop 1 end if write ( * , '(A,I0)' ) \"objval = \" , objval write ( * , '(A,*(I1,:,1X))' ) \"part = \" , part end program","tags":"","loc":"sourcefile/test_partgraphkway.f90.html","title":"test_PartGraphKway.f90 – Fortran METIS Interface"},{"text":"This File Depends On sourcefile~~test_partmeshnodal2.f90~~EfferentGraph sourcefile~test_partmeshnodal2.f90 test_PartMeshNodal2.f90 sourcefile~metis_interface.f90 metis_interface.f90 sourcefile~metis_interface.f90->sourcefile~test_partmeshnodal2.f90 sourcefile~metis_enum.f90 metis_enum.f90 sourcefile~metis_enum.f90->sourcefile~test_partmeshnodal2.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs test_PartMeshNodal2 Source Code test_PartMeshNodal2.f90 Source Code !>  Example of partitioning a mesh composed of 4 quadrilaterals and 9 nodes !   based upon its nodal graph. ! !   Source: https://www.cfd-online.com/Forums/main/112366-using-metis-functions-fortran.html#post404734 ! program test_PartMeshNodal2 use iso_c_binding , only : c_int use metis_interface , only : METIS_SetDefaultOptions , METIS_PartMeshNodal , METIS_NOPTIONS use metis_enum , only : METIS_OPTION_NUMBERING , METIS_OPTION_CONTIG , METIS_OK implicit none integer ( c_int ), parameter :: ne = 4 ! number of elements integer ( c_int ), parameter :: nn = 9 ! number of nodes integer ( c_int ) :: eptr ( ne + 1 ), eind ( 4 * ne ) ! arrays storing mesh structure integer ( c_int ) :: epart ( ne ), npart ( nn ) ! element and node partition vectors integer ( c_int ) :: opts ( 0 : METIS_NOPTIONS - 1 ), ios , objval write ( * , '(A)' ) \"TEST METIS_PartMeshNodal2\" !  1---2---5 !  | 1 | 2 | !  4---3---6 !  | 4 | 3 | !  9---8---7 eptr = [ 1 , 5 , 9 , 13 , 17 ] eind = [ 1 , 2 , 3 , 4 ,& 2 , 5 , 6 , 3 ,& 3 , 6 , 7 , 8 ,& 4 , 3 , 8 , 9 ] ios = METIS_SetDefaultOptions ( opts ) if ( ios /= METIS_OK ) then write ( * , * ) \"METIS_SetDefaultOptions failed with error: \" , ios error stop 1 end if opts ( METIS_OPTION_NUMBERING ) = 1 ! Fortran-style numbering opts ( METIS_OPTION_CONTIG ) = 1 ! Force contigous partitions ! call print_metis_options(opts) ios = METIS_PartMeshNodal ( ne , nn , eptr , eind , nparts = 2 , options = opts , & objval = objval , epart = epart , npart = npart ) if ( ios /= METIS_OK ) then write ( * , * ) \"METIS_PartMeshNodal failed with error: \" , ios error stop 1 end if write ( * , '(A,I0)' ) \"objval = \" , objval write ( * , '(A,*(I1,:,1X))' ) \"epart = \" , epart write ( * , '(A,*(I1,:,1X))' ) \"npart = \" , npart end program","tags":"","loc":"sourcefile/test_partmeshnodal2.f90.html","title":"test_PartMeshNodal2.f90 – Fortran METIS Interface"},{"text":"This File Depends On sourcefile~~test_partgraphrecursive2.f90~~EfferentGraph sourcefile~test_partgraphrecursive2.f90 test_PartGraphRecursive2.f90 sourcefile~metis_interface.f90 metis_interface.f90 sourcefile~metis_interface.f90->sourcefile~test_partgraphrecursive2.f90 sourcefile~metis_enum.f90 metis_enum.f90 sourcefile~metis_enum.f90->sourcefile~test_partgraphrecursive2.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs test_PartGraphRecursive2 Source Code test_PartGraphRecursive2.f90 Source Code !>  Partitioning a graph with non-equal number of edges per node. ! program test_PartGraphRecursive2 use iso_c_binding , only : c_int use metis_interface , only : METIS_PartGraphRecursive , METIS_SetDefaultOptions , METIS_NOPTIONS use metis_enum , only : METIS_OPTION_NUMBERING , METIS_OK integer ( c_int ) :: n , m integer ( c_int ), allocatable :: xadj (:), adjncy (:), part (:) integer ( c_int ) :: options ( 0 : METIS_NOPTIONS - 1 ), ios , ncon , objval write ( * , '(A)' ) \"TEST METIS_PartGraphRecursive 2\" !   1---5 !   |\\ / \\ !   | 3   6 !   |/ \\ / \\ !   2---4---7 xadj = [ 1 , 4 , 7 , 11 , 15 , 18 , 21 , 23 ] adjncy = [ 5 , 3 , 2 , 1 , 3 , 4 , 5 , 4 , 2 , 1 , 2 , 3 , 6 , 7 , 1 , 3 , 6 , 5 , 4 , 7 , 6 , 4 ] n = size ( xadj ) - 1 m = size ( adjncy ) / 2 write ( * , '(A,I0)' ) \"n = \" , n write ( * , '(A,I0)' ) \"m = \" , m ios = METIS_SetDefaultOptions ( options ) if ( ios /= METIS_OK ) then write ( * , * ) \"METIS_SetDefaultOptions failed with error: \" , ios error stop 1 end if options ( METIS_OPTION_NUMBERING ) = 1 ! Fortran-style numbering ncon = 1 allocate ( part ( n )) ios = METIS_PartGraphRecursive ( n , ncon , xadj , adjncy ,& nparts = 2 , objval = objval , part = part , options = options ) if ( ios /= METIS_OK ) then write ( * , * ) \"METIS_PartGraphKway failed with error: \" , ios error stop 1 end if write ( * , '(A,I0)' ) \"objval = \" , objval write ( * , '(A,*(I1,:,1X))' ) \"part = \" , part end program","tags":"","loc":"sourcefile/test_partgraphrecursive2.f90.html","title":"test_PartGraphRecursive2.f90 – Fortran METIS Interface"},{"text":"This File Depends On sourcefile~~test_nodend.f90~~EfferentGraph sourcefile~test_nodend.f90 test_NodeND.f90 sourcefile~metis_interface.f90 metis_interface.f90 sourcefile~metis_interface.f90->sourcefile~test_nodend.f90 sourcefile~metis_enum.f90 metis_enum.f90 sourcefile~metis_enum.f90->sourcefile~test_nodend.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs test_NodeND Source Code test_NodeND.f90 Source Code !>  Example of computing a fill-reducing ordering of a sparse matrix ! !   Source: http://comp.lang.fortran.narkive.com/uFmDM7Bo/how-to-call-a-metis-subroutine-from-my-fortran-code ! program test_NodeND use iso_c_binding , only : c_int use metis_interface , only : METIS_SetDefaultOptions , METIS_NodeND , METIS_NOPTIONS use metis_enum , only : METIS_OK , METIS_OPTION_NUMBERING implicit none integer ( c_int ), parameter :: n = 15 ! number of vertices integer ( c_int ), parameter :: m = 22 ! number of edges integer ( c_int ) :: xadj ( n + 1 ), adjncy ( 2 * m ) ! graph adjacency structure integer ( c_int ) :: perm ( n ), iperm ( n ) ! fill-reducing permutation and inverse permutation integer ( c_int ) :: options ( 0 : METIS_NOPTIONS - 1 ), ios write ( * , '(A)' ) \"TEST METIS_NodeND\" !  1---2---3---4---5 !  |   |   |   |   | !  6---7---8---9---10 !  |   |   |   |   | !  11--12--13--14--15 xadj = [ 1 , 3 , 6 , 9 , 12 , 14 , 17 , 21 , 25 , 29 , 32 , 34 , 37 , 40 , 43 , 45 ] adjncy = [ 2 , 6 , 1 , 3 , 7 , 2 , 4 , 8 , 3 , 5 , 9 , 4 , 10 , 1 , 7 , 11 , 2 , 6 , & 8 , 12 , 3 , 7 , 9 , 13 , 4 , 8 , 10 , 14 , 5 , 9 , 15 , 6 , 12 , 7 , 11 , 13 , & 8 , 12 , 14 , 9 , 13 , 15 , 10 , 14 ] ios = METIS_SetDefaultOptions ( options ) if ( ios /= METIS_OK ) then write ( * , * ) \"METIS_SetDefaultOptions failed with error: \" , ios error stop 1 end if options ( METIS_OPTION_NUMBERING ) = 1 ! Fortran-style numbering ios = METIS_NodeND ( n , xadj , adjncy , options = options , perm = perm , iperm = iperm ) if ( ios /= METIS_OK ) then write ( * , * ) \"METIS_NodeND failed with error: \" , ios error stop 1 end if write ( * , '(A,*(I2,:,1X))' ) \"perm  = \" , perm write ( * , '(A,*(I2,:,1X))' ) \"iperm = \" , iperm end program","tags":"","loc":"sourcefile/test_nodend.f90.html","title":"test_NodeND.f90 – Fortran METIS Interface"},{"text":"Files Dependent On This One sourcefile~~metis_interface.f90~~AfferentGraph sourcefile~metis_interface.f90 metis_interface.f90 sourcefile~test_partgraphrecursive1.f90 test_PartGraphRecursive1.f90 sourcefile~metis_interface.f90->sourcefile~test_partgraphrecursive1.f90 sourcefile~test_partmeshnodal2.f90 test_PartMeshNodal2.f90 sourcefile~metis_interface.f90->sourcefile~test_partmeshnodal2.f90 sourcefile~test_partgraphkway.f90 test_PartGraphKway.f90 sourcefile~metis_interface.f90->sourcefile~test_partgraphkway.f90 sourcefile~test_partgraphrecursive2.f90 test_PartGraphRecursive2.f90 sourcefile~metis_interface.f90->sourcefile~test_partgraphrecursive2.f90 sourcefile~test_nodend.f90 test_NodeND.f90 sourcefile~metis_interface.f90->sourcefile~test_nodend.f90 sourcefile~test_partmeshnodal1.f90 test_PartMeshNodal1.f90 sourcefile~metis_interface.f90->sourcefile~test_partmeshnodal1.f90 sourcefile~metis_oo_interface.f90 metis_oo_interface.f90 sourcefile~metis_interface.f90->sourcefile~metis_oo_interface.f90 sourcefile~metis_tests.f90 metis_tests.f90 sourcefile~metis_interface.f90->sourcefile~metis_tests.f90 sourcefile~metis_io.f90 metis_io.f90 sourcefile~metis_interface.f90->sourcefile~metis_io.f90 sourcefile~metis_io.f90->sourcefile~metis_tests.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules metis_interface Source Code metis_interface.f90 Source Code ! metis_interface.f90 -- Fortran METIS Interface ! ! Copyright (C) 2018 Ivan Pribec <ivan.pribec@gmail.com> ! ! This software may be modified and distributed under the terms ! of the MIT license.  See the LICENSE file for details. !***************************************************************************************** !> author: Ivan Pribec !  date: 7/2018 !  license: MIT ! ! A Fortran interface to the METIS graph partitioning library. ! module metis_interface use iso_c_binding , only : c_int , c_double , c_ptr implicit none private ! Graph partitioning routines public :: METIS_PartGraphRecursive public :: METIS_PartGraphKway ! Mesh partitioning routines public :: METIS_PartMeshDual public :: METIS_PartMeshNodal ! Sparse matrix reordering routines public :: METIS_NodeND ! Mesh-to-graph conversion routines public :: METIS_MeshToDual public :: METIS_MeshToNodal ! Utility routines public :: METIS_SetDefaultOptions public :: METIS_Free ! Constants integer , parameter , public :: METIS_NOPTIONS = 40 !! Number of METIS options. ! ! METIS' API ! ! http://glaros.dtc.umn.edu/gkhome/node/877 interface ! ! Graph partitioning routines ! !***************************************************************************************** !> This function is used to partition a graph into `nparts` parts using recursive bisection. ! !  If `tpwgt` is present, the *target partition weight* for the `i`-th partition and `j`-th constraint should !  be specified at `tpwgts(i*ncon+j)` (the numbering for both partitions and constraints starts from 0). !  For each constraint, the sum of the `tpwgts`entries must be 1.0. ! !  The following options are valid: <br /> !  `METIS_OPTION_CTYPE`, `METIS_OPTION_IPTYPE`, `METIS_OPTION_RTYPE`, !  `METIS_OPTION_NO2HOP`, `METIS_OPTION_NCUTS`, `METIS_OPTION_NITER`, !  `METIS_OPTION_SEED`, `METIS_OPTION_UFACTOR`, `METIS_OPTION_NUMBERING`, !  `METIS_OPTION_DBGLVL` ! function METIS_PartGraphRecursive ( nvtxs , ncon , xadj , adjncy ,& vwgt , vsize , adjwgt , nparts , tpwgts , ubvec , options , objval , part ) result ( ierr ) bind ( C , name = \"METIS_PartGraphRecursive\" ) import c_int , c_double , METIS_NOPTIONS ! Parameters integer ( c_int ), intent ( in ) :: nvtxs !! The number of vertices in the graph. integer ( c_int ), intent ( in ) :: ncon !! The number of balancing constraints. It should be atleast 1. integer ( c_int ), intent ( in ), dimension ( * ) :: xadj , adjncy !! The adjacency structure of the graph as described in section 5.5 of the [manual](http://glaros.dtc.umn.edu/gkhome/fetch/sw/metis/manual.pdf). integer ( c_int ), intent ( in ), dimension ( * ), optional :: vwgt ! NULL !! The weights of the vertices as described in Section 5.5 of the [manual](http://glaros.dtc.umn.edu/gkhome/fetch/sw/metis/manual.pdf). integer ( c_int ), intent ( in ), dimension ( * ), optional :: vsize ! NULL !! The size of the vertices for computing the total communication volume as described in section 5.7 of the [manual](http://glaros.dtc.umn.edu/gkhome/fetch/sw/metis/manual.pdf). integer ( c_int ), intent ( in ), dimension ( * ), optional :: adjwgt ! NULL !! The weights of the edges as describe in Section 5.5 of the [manual](http://glaros.dtc.umn.edu/gkhome/fetch/sw/metis/manual.pdf). integer ( c_int ) , intent ( in ) :: nparts !! The number of parts to partition the graph. real ( c_double ), intent ( in ), optional :: tpwgts ( nparts * ncon ) !! An array of size `nparts*ncon` that specifies the desired weight for each partition and constraint. !! If not present, the graph is divided equally among the partitions. More in the description. real ( c_double ), intent ( in ), optional :: ubvec ( ncon ) !! An array of size `ncon` that specifies the allowed load imbalance for each constraint. !! For the `i`-th partition and `j`-th constraint the allowed weight is the `ubvec(j)*tpwgts(i*ncon+j)` !! fraction of the `j`-th's constraint total weight. If not present, the load imbalance !! tolerance is 1.001 (for `ncon = 1`) or 1.01 (for `ncon > 1`). integer ( c_int ), intent ( in ), optional :: options ( METIS_NOPTIONS ) !! An array of options as described in Section 5.4 of the METIS manual. See description for valid options. integer ( c_int ), intent ( out ) :: objval !! Upon successful completion, this variable stores the edge-cut or the total communication volume of the partitioning !! solution. The value returned depends on the partitioning's objective function. integer ( c_int ), intent ( out ) :: part ( nvtxs ) !! This is a vector of size `nvtxs` that upon successful completion stores the partition vector of the graph. !! The numbering of this vector starts from either 0 or 1, depending on the value of `options(METIS_OPTION_NUMBERING)`. ! Returns integer ( c_int ) :: ierr !! `METIS_OK` - Indicates that the function returned normally.<br /> !! `METIS_ERROR_INPUT` - Indicates an input error.<br /> !! `METIS_ERROR_MEMORY` - Indicates that it could not allocate the required memory.<br /> !! `METIS_ERROR` - Indicates some other type of error. end function !***************************************************************************************** !***************************************************************************************** !> This function is used to partition a graph into `nparts` parts using multilevel k-way partitioning. ! !  If `tpwgt` is present, the *target partition weight* for the `i`-th partition and `j`-th constraint should !  be specified at `tpwgts(i*ncon+j)` (the numbering for both partitions and constraints starts from 0). !  For each constraint, the sum of the `tpwgts`entries must be 1.0. ! !  The following options are valid: <br /> !  `METIS_OPTION_OBJTYPE`, `METIS_OPTION_CTYPE`, `METIS_OPTION_IPTYPE`, !  `METIS_OPTION_RTYPE`, `METIS_OPTION_NO2HOP`, `METIS_OPTION_NCUTS`, !  `METIS_OPTION_NITER`, `METIS_OPTION_UFACTOR`, `METIS_OPTION_MINCONN`, !  `METIS_OPTION_CONTIG`, `METIS_OPTION_SEED`, `METIS_OPTION_NUMBERING`, !  `METIS_OPTION_DBGLVL` ! function METIS_PartGraphKway ( nvtxs , ncon , xadj , adjncy ,& vwgt , vsize , adjwgt , nparts , tpwgts , ubvec , options , objval , part ) result ( ierr ) bind ( C , name = \"METIS_PartGraphKway\" ) import c_int , c_double , METIS_NOPTIONS ! Parameters integer ( c_int ), intent ( in ) :: nvtxs !! The number of vertices in the graph. integer ( c_int ), intent ( in ) :: ncon !! The number of balancing constraints. It should be at least 1. integer ( c_int ), intent ( in ), dimension ( * ) :: xadj , adjncy !! The adjacency structure of the graph as described in section 5.5 of the [manual](http://glaros.dtc.umn.edu/gkhome/fetch/sw/metis/manual.pdf). integer ( c_int ), intent ( in ), dimension ( * ), optional :: vwgt !! The weights of the vertices as described in Section 5.5 of the [manual](http://glaros.dtc.umn.edu/gkhome/fetch/sw/metis/manual.pdf). integer ( c_int ), intent ( in ), dimension ( * ), optional :: vsize !! The size of the vertices for computing the total communication volume as described in section 5.7 of the [manual](http://glaros.dtc.umn.edu/gkhome/fetch/sw/metis/manual.pdf). integer ( c_int ), intent ( in ), dimension ( * ), optional :: adjwgt !! The weights of the edges as describe in Section 5.5 of the [manual](http://glaros.dtc.umn.edu/gkhome/fetch/sw/metis/manual.pdf). integer ( c_int ), intent ( in ) :: nparts !! The number of parts to partition the graph. real ( c_double ), intent ( in ), optional :: tpwgts ( nparts * ncon ) !! An array of size `nparts*ncon` that specifies the desired weight for each partition and constraint. !! If not present, the graph is divided equally among the partitions. More in the description. real ( c_double ), intent ( in ), optional :: ubvec ( ncon ) !! An array of size `ncon` that specifiew the allowed load imbalance for each constraint. !! For the `i`-th partition and `j`-th constraint the allowed weight is the `ubvec(j)*tpwgts(i*ncon+j)` !! fraction of the `j`-th's constraint total weight. If not present, the load imbalance !! tolerance is 1.001 (for `ncon == 1`) or 1.01 (for `ncon > 1`). integer ( c_int ), intent ( in ), optional :: options ( METIS_NOPTIONS ) !! An array of options as described in Section 5.4 of the [manual](http://glaros.dtc.umn.edu/gkhome/fetch/sw/metis/manual.pdf). See description for valid options. integer ( c_int ), intent ( out ) :: objval !! Upon successful completion, this variable stores the edge-cut or the total communication volume of the partitioning !! solution. The value returned depends on the partitioning's objective function. integer ( c_int ), intent ( out ) :: part ( nvtxs ) !! This is a vector of size `nvtxs` that upon successful completion stores the partition vector of the graph. !! The numbering of this vector starts from either 0 or 1, depending on the value of `options(METIS_OPTION_NUMBERING)`. ! Returns integer ( c_int ) :: ierr !! `METIS_OK` - Indicates that the function returned normally.<br /> !! `METIS_ERROR_INPUT` - Indicates an input error.<br /> !! `METIS_ERROR_MEMORY` - Indicates that it could not allocate the required memory.<br /> !! `METIS_ERROR` - Indicates some other type of error. end function !***************************************************************************************** ! ! Mesh partitioning routines ! !***************************************************************************************** !> This function is used to partition a mesh into `nparts` parts based on a partitioning of the mesh's dual graph. ! !  The following options are valid: <br /> !  `METIS_OPTION_PTYPE`, `METIS_OPTION_OBJTYPE`, `METIS_OPTION_CTYPE`, !  `METIS_OPTION_IPTYPE`, `METIS_OPTION_RTYPE`, `METIS_OPTION_NCUTS`, !  `METIS_OPTION_NITER`, `METIS_OPTION_SEED`, `METIS_OPTION_UFACTOR`, !  `METIS_OPTION_NUMBERING`, `METIS_OPTION_DBGLVL` ! function METIS_PartMeshDual ( ne , nn , eptr , eind , vwgt , vsize , ncommon , & nparts , tpwgts , options , objval , epart , npart ) result ( ierr ) bind ( C , name = \"METIS_PartMeshDual\" ) import c_int , METIS_NOPTIONS integer ( c_int ), intent ( in ) :: ne !! The number of elements in the mesh. integer ( c_int ), intent ( in ) :: nn !! The number of nodes in the mesh. integer ( c_int ), intent ( in ), dimension ( * ) :: eptr , eind !! The pair of arrays storing the mesh as described in Section 5.6 of the [manual](http://glaros.dtc.umn.edu/gkhome/fetch/sw/metis/manual.pdf). integer ( c_int ), intent ( in ), optional :: vwgt ( ne ) !! An array of size `ne` specifying the weights of the elements. If not present, !! all elements have an equal weight. integer ( c_int ), intent ( in ), optional :: vsize ( ne ) !! An array of size `ne` specifying the size of the elements that is used !! for computing the total comunication volume as described in Section 5.7 of the  [manual](http://glaros.dtc.umn.edu/gkhome/fetch/sw/metis/manual.pdf). !! If not present, the objective is cut or all elements have an equal size. integer ( c_int ), intent ( in ) :: ncommon integer ( c_int ), intent ( in ) :: nparts !! The number of parts to partition the mesh. integer ( c_int ), intent ( in ), optional :: tpwgts ( nparts ) !! An array of size `nparts` that specifies the desired weight for each partition. The *target !! partition weight* for the `i`-th partition is specified at `tpwgts(i)` (the numbering for the !! partitions starts from 0). The sum of the `tpwgts` entries must be 1.0. <br /> If not present, the graph !! is divided equally among the partitions. integer ( c_int ), intent ( in ), optional :: options ( METIS_NOPTIONS ) !! An array of options as described in Section 5.4 of the [manual](http://glaros.dtc.umn.edu/gkhome/fetch/sw/metis/manual.pdf). See description for valid options. integer ( c_int ), intent ( out ) :: objval !! Upon successful completion, this variable stores either the edgecut or the total communication !! volume of the dual graph's partitioning. integer ( c_int ), intent ( out ) :: epart ( ne ) !! A vector of size `ne` that upon successful completion stores the partition vector for the elements !! of the mesh. The numbering of this vector starts from either 0 or 1, depending on the value of !! `options(METIS_OPTION_NUMBERING)`. integer ( c_int ), intent ( out ) :: npart ( nn ) !! A vector of size `nn` that upon successful completion stores the partition vector for the nodes !! of the mesh. The numbering of this vector starts from either 0 or 1, depending on the value of !! `options(METIS_OPTION_NUMBERING)`. ! Returns integer ( c_int ) :: ierr !! `METIS_OK` - Indicates that the function returned normally.<br /> !! `METIS_ERROR_INPUT` - Indicates an input error.<br /> !! `METIS_ERROR_MEMORY` - Indicates that it could not allocate the required memory.<br /> !! `METIS_ERROR` - Indicates some other type of error. end function !***************************************************************************************** !***************************************************************************************** !> This function us used to partition a mesh into `nparts` parts based on a !  partitioning of the mesh's nodal graph. ! !  The following options are valid: <br /> !  `METIS_OPTION_PTYPE`, `METIS_OPTION_OBJTYPE`, `METIS_OPTION_CTYPE`, !  `METIS_OPTION_IPTYPE`, `METIS_OPTION_RTYPE`, `METIS_OPTION_NCUTS`, !  `METIS_OPTION_NITER`, `METIS_OPTION_SEED`, `METIS_OPTION_UFACTOR`, !  `METIS_OPTION_NUMBERING`, `METIS_OPTION_DBGLVL` ! function METIS_PartMeshNodal ( ne , nn , eptr , eind , vwgt , vsize , & nparts , tpwgts , options , objval , epart , npart ) result ( ierr ) bind ( C , name = \"METIS_PartMeshNodal\" ) import c_int , METIS_NOPTIONS integer ( c_int ), intent ( in ) :: ne !! The number of elements in the mesh. integer ( c_int ), intent ( in ) :: nn !! The number of nodes in the mesh. integer ( c_int ), intent ( in ), dimension ( * ) :: eptr , eind !! The pair of arrays storing the mesh as described in Section 5.6 of the [manual](http://glaros.dtc.umn.edu/gkhome/fetch/sw/metis/manual.pdf). integer ( c_int ), intent ( in ), optional :: vwgt ( nn ) !! An array of size `nn` specifying weights of the nodes. If not passed, all nodes have an equal weight. integer ( c_int ), intent ( in ), optional :: vsize ( nn ) !! An array of size `nn` specifying the size of the nodes that is used for computing the !! total comunication volume as described in Section 5.7 of the [manual](http://glaros.dtc.umn.edu/gkhome/fetch/sw/metis/manual.pdf). If not passed, !! the objective is cut or all nodes have an equal size. integer ( c_int ), intent ( in ) :: nparts !! The number of parts to partition the mesh. integer ( c_int ), intent ( in ), optional :: tpwgts ( nparts ) !! An array of size `nparts` that specifies the desired weight for each partition. The *target !! partition weight* for the `i`-th partition is specified at `tpwgts(i)` (the numbering for the !! partitions starts from 0). The sum of the `tpwgts` entries must be 1.0. If not passed, the graph !! is divided equally among the partitions. integer ( c_int ), intent ( in ), optional :: options ( METIS_NOPTIONS ) !! An array of options as described in Section 5.4 of the [manual](http://glaros.dtc.umn.edu/gkhome/fetch/sw/metis/manual.pdf). See description for valid options. integer ( c_int ), intent ( out ) :: objval !! Upon successful completion, this variable stores either the edgecut or the total communication !! volume of the nodal graph's partitioning. integer ( c_int ), intent ( out ) :: epart ( ne ) !! A vector of size `ne` that upon successful completion stores the partition vector for the elements !! of the mesh. The numbering of this vector starts from either 0 or 1, depending on the value of !! `options(METIS_OPTION_NUMBERING)`. integer ( c_int ), intent ( out ) :: npart ( nn ) !! A vector of size `nn` that upon successful completion stores the partition vector for the nodes !! of the mesh. The numbering of this vector starts from either 0 or 1, depending on the value of !! `options(METIS_OPTION_NUMBERING)`. ! Returns integer ( c_int ) :: ierr !! `METIS_OK` - Indicates that the function returned normally.<br /> !! `METIS_ERROR_INPUT` - Indicates an input error.<br /> !! `METIS_ERROR_MEMORY` - Indicates that it could not allocate the required memory.<br /> !! `METIS_ERROR` - Indicates some other type of error. end function !***************************************************************************************** ! ! Sparse Matrix Reordering Routines ! !***************************************************************************************** !> This function computes fill reducing orderings of sparse matrices using the !  multilevel nested dissection algorithm. ! !  Let A be the original matrix and A' be the permuted matrix. The arrays !  `perm` and `iperm` are defined as follows. Row (column) `i` of A' is the !  `perm(i)` row (column) of A, and row (column) `i` of A is the `iperm(i)` !  row (column) of A'. the numbering of this vector starts from either 0 or 1, !  depending on the value of `options(METIS_OPTION_NUMBERING)`. ! !  If the graph is weighted, meaning `vgwt` was provided, the nested dissection ordering computes !  vertex separators that minimize the sum of the weights of the vertices on the separators. ! !  The following options are valid: <br /> !  `METIS_OPTION_CTYPE`, `METIS_OPTION_RTYPE`, `METIS_OPTION_NO2HOP`, !  `METIS_OPTION_NSEPS`, `METIS_OPTION_NITER`, `METIS_OPTION_UFACTOR`, !  `METIS_OPTION_COMPRESS`, `METIS_OPTION_CCORDER`, `METIS_OPTION_SEED`, !  `METIS_OPTION_PFACTOR`, `METIS_OPTION_NUMBERING`, `METIS_OPTION_DBGLVL` ! !#Example ! The code below generates the nodal graph of the following mesh: !```Fortran !integer(c_int), parameter :: n = 15, m = 22 !integer(c_int) :: xadj(n+1), adjncy(2*m) !integer(c_int) :: perm(n), iperm(n) !integer(c_int) :: options(0:39), ierr ! !xadj = [1,3,6,9,12,14,17,21,25,29,32,34,37,40,43,45] !adjncy = [2,6,1,3,7,2,4,8,3,5,9,4,10,1,7,11,2,6, & !                  8,12,3,7,9,13,4,8,10,14,5,9,15,6,12,7,11,13, & !                  8,12,14,9,13,15,10,14] ! !ierr = METIS_SetDefaultOptions(options) !options(18) = 1 ! !ierr = METIS_NodeND(n,xadj,adjncy,options=options,perm=perm,iperm=iperm) !end !``` function METIS_NodeND ( nvtxs , xadj , adjncy , vwgt , options , perm , iperm ) result ( ierr ) bind ( C , name = \"METIS_NodeND\" ) import c_int , METIS_NOPTIONS ! Parameters integer ( c_int ), intent ( in ) :: nvtxs !! The number of vertices in the graph. integer ( c_int ), intent ( in ), dimension ( * ) :: xadj , adjncy !! The adjacency structure of the graph as described in Section 5.5 of the [manual](http://glaros.dtc.umn.edu/gkhome/fetch/sw/metis/manual.pdf). integer ( c_int ), intent ( in ), optional :: vwgt ( nvtxs ) !! An array of size `nvtxs` specifying the weights of the vertices. integer ( c_int ), intent ( in ), optional :: options ( METIS_NOPTIONS ) !! This is the array of options as described in Section 5.4 of the [manual](http://glaros.dtc.umn.edu/gkhome/fetch/sw/metis/manual.pdf). See description for valid options. integer ( c_int ), intent ( out ) :: perm ( nvtxs ), iperm ( nvtxs ) !! Vectors of size `nvtxs`. Upon successful completion, they store the fill-reducing !! permutation and inverse-permutation. More in the description. ! Returns integer ( c_int ) :: ierr !! `METIS_OK` - Indicates that the function returned normally.<br /> !! `METIS_ERROR_INPUT` - Indicates an input error.<br /> !! `METIS_ERROR_MEMORY` - Indicates that it could not allocate the required memory.<br /> !! `METIS_ERROR` - Indicates some other type of error. end function !***************************************************************************************** ! ! Mesh-to-graph conversion routines ! !***************************************************************************************** !> This function is used to generate the dual graph of a mesh. ! !@note ! To use the returned arrays `xadj` and `adjncy`, these must be first converted from ! a C pointer to a Fortran pointer using the subroutine `c_f_pointer(cptr,fptr,shape)` ! that assigns the target of the C pointer `cptr` to the Fortran pointer `fptr` and ! specifies its shape. The `shape` is an integer rank-one array, storing the size `ne+1` ! in case of the dual graph. The size of the new `adjncy` array is stored in the ! last element of `xadj` when using C-style numbering. An example is shown below. !@endnote ! !@warning ! Memory for the returned arrays `xadj` and `adjncy` is allocated by METIS' API in C ! using the standard `malloc` function. It is the responsibility of the application to free ! this memory by calling `free`. Therefore, METIS provides the [[METIS_Free]] function that is a wrapper to ! C's `free`function. !@endwarning ! !# Example ! The code below generates the nodal graph of the following mesh: ! __image__ !```Fortran !use iso_c_binding, only : c_int, c_ptr, c_f_pointer !integer(c_int), parameter :: ne = 3, nn = 8, npel = 4 !integer(c_int) :: ierr, eptr(ne+1), eind(ne*npel), numflag, ncommon !type(c_ptr) :: xadj, adjncy !integer(c_int), dimension(:), pointer :: fxadj => null(), fadjncy => null() ! !numflag = 0 ! C-style numbering !ncommon = 2 ! 2 common nodes per edge !eptr = [0,4,8,12] !eind = [0,1,2,3,1,4,5,2,4,6,7,5] ! note four nodes per element ! !ierr = METIS_MeshToDual(ne,nn,eptr,eind,ncommon,numflag,xadj,adjncy) !call c_f_pointer(xadj,fxadj,shape=[ne+1]) ! xadj is of the size ne+1 !call c_f_pointer(adjncy,fadjncy,shape=[fxadj(ne+1)]) ! last value in xadj is the size of adjncy ! ! !... use values in fxadj and fadjncy ... ! !call METIS_Free(xadj) !call METIS_Free(adjncy) !end !``` function METIS_MeshToDual ( ne , nn , eptr , eind , ncommon , numflag , xadj , adjncy ) result ( ierr ) bind ( C , name = \"METIS_MeshToDual\" ) import c_int , c_ptr ! Parameters integer ( c_int ), intent ( in ) :: ne !! The number of elements in the mesh. integer ( c_int ), intent ( in ) :: nn !! The number of nodes in the mesh. integer ( c_int ), intent ( in ), dimension ( * ) :: eptr , eind !! The pair of arrays storing the mesh as described in Section 5.6 of the [manual](http://glaros.dtc.umn.edu/gkhome/fetch/sw/metis/manual.pdf). integer ( c_int ), intent ( in ) :: ncommon !! The number of common nodes that two elements must have in order to put !! an edge between them in the dual graph. integer ( c_int ), intent ( in ) :: numflag !! Used to indicate which numbering scheme is used for `eptr` and `eind`. !! The possible values are: <br /> !! 0 - C-style numbering is assumed that starts from 0 <br /> !! 1 - Fortran-style numbering is assumed that starts from 1 type ( c_ptr ), intent ( out ) :: xadj , adjncy !! These arrays store the adjacency structure of the generated dual graph. !! The format of the adjacency structure is described in Section 5.5 of the [manual](http://glaros.dtc.umn.edu/gkhome/fetch/sw/metis/manual.pdf). ! Returns integer ( c_int ) :: ierr !! `METIS_OK` - Indicates that the function returned normally.<br /> !! `METIS_ERROR_INPUT` - Indicates an input error.<br /> !! `METIS_ERROR_MEMORY` - Indicates that it could not allocate the required memory.<br /> !! `METIS_ERROR` - Indicates some other type of error. end function !***************************************************************************************** !***************************************************************************************** !> This function is used to generate the nodal graph of a mesh. ! !@note ! To use the returned arrays `xadj` and `adjncy`, these must be first converted from ! a C pointer to a Fortran pointer using the subroutine `c_f_pointer(cptr,fptr,shape)` ! that assigns the target of the C pointer `cptr` to the Fortran pointer `fptr` and ! specifies its shape. The `shape` is an integer rank-one array, storing the size `nn+1` ! in case of the nodal graph. The size of the new `adjncy` array is stored in the ! last element of `xadj` when using C-style numbering. An example is shown below. !@endnote ! !@warning ! Memory for the returned arrays `xadj` and `adjncy` is allocated by METIS' API in C ! using the standard `malloc` function. It is the responsibility of the application to free ! this memory by calling `free`. Therefore, METIS provides the [[METIS_Free]] function that is a wrapper to ! C's `free`function. !@endwarning ! !# Example ! The code below generates the nodal graph of the following mesh: ! __image__ !```Fortran !use iso_c_binding, only : c_int, c_ptr, c_f_pointer !integer(c_int), parameter :: ne = 3, nn = 8, npel = 4 !integer(c_int) :: ierr, eptr(ne+1), eind(ne*npel), numflag !type(c_ptr) :: xadj, adjncy !integer(c_int), dimension(:), pointer :: fxadj => null(), fadjncy => null() ! !numflag = 0 ! C-style numbering !eptr = [0,4,8,12] !eind = [0,1,2,3,1,4,5,2,4,6,7,5] ! note four nodes per element ! !ierr = METIS_MeshToNodal(ne,nn,eptr,eind,numflag,xadj,adjncy) !call c_f_pointer(xadj,fxadj,shape=[nn+1]) ! xadj is of the size nn+1 !call c_f_pointer(adjncy,fadjncy,shape=[fxadj(nn+1)]) ! last value in xadj is the size of adjncy ! ! !... use values in fxadj and fadjncy ... ! !call METIS_Free(xadj) !call METIS_Free(adjncy) !end !``` function METIS_MeshToNodal ( ne , nn , eptr , eind , numflag , xadj , adjncy ) result ( ierr ) bind ( C , name = \"METIS_MeshToNodal\" ) import c_int , c_ptr ! Parameters integer ( c_int ), intent ( in ) :: ne !! The number of elements in the mesh. integer ( c_int ), intent ( in ) :: nn !! The number of nodes in the mesh. integer ( c_int ), intent ( in ), dimension ( * ) :: eptr , eind !! The pair of arrays storing the mesh as described in Section 5.6 of the [manual](http://glaros.dtc.umn.edu/gkhome/fetch/sw/metis/manual.pdf). integer ( c_int ), intent ( in ) :: numflag !! Used to indicate which numbering scheme is used for `eptr` and `eind`. !! The possible values are: <br /> !! 0 - C-style numbering is assumed that starts from 0 <br /> !! 1 - Fortran-style numbering is assumed that starts from 1 type ( c_ptr ), intent ( out ) :: xadj , adjncy !! These arrays store the adjacency structure of the generated dual graph. !! The format of the adjacency structure is described in Section 5.5 of the [manual](http://glaros.dtc.umn.edu/gkhome/fetch/sw/metis/manual.pdf). ! Returns integer ( c_int ) :: ierr !! `METIS_OK` - Indicates that the function returned normally.<br /> !! `METIS_ERROR_INPUT` - Indicates an input error.<br /> !! `METIS_ERROR_MEMORY` - Indicates that it could not allocate the required memory.<br /> !! `METIS_ERROR` - Indicates some other type of error. end function !***************************************************************************************** ! ! Utility routines ! !***************************************************************************************** !> Initializes the options array into its default values. ! !@note ! The passed array `options` must have the size `METIS_NOPTIONS` (40). ! To be able to use the parameters in the [[metis_enum]] module it is recommended to use ! zero-based indexing for the options array: !```Fortran !integer(c_int) :: opts(0:39) !``` !@endnote ! !# Examples ! To set Fortran style index-numbering use: !```Fortran !integer :: opts(0:39) ! !call METIS_SetDefaultOptions(opts) !opts(17) = 1 ! Fortran-style index numbering !``` ! ! Other options can be changed using parameters from the [[metis_enum]] module. !```Fortran !use metis_interface, only : METIS_SetDefaultOptions !use metis_enum, only : METIS_OPTION_DBGLVL, METIS_DBG_INFO !integer :: opts(0:39) ! !call METIS_SetDefaultOptions(opts) !opts(METIS_OPTION_DBGLVL) = METIS_DBG_INFO ! Show various diagnostic messages !end !``` function METIS_SetDefaultOptions ( options ) result ( ierr ) bind ( C , name = \"METIS_SetDefaultOptions\" ) import c_int , METIS_NOPTIONS ! Parameters integer ( c_int ), intent ( out ) :: options ( METIS_NOPTIONS ) !! The array of options that will be initialized. ! Returns integer ( c_int ) :: ierr !! `METIS_OK` - Indicates that the function returned normally. end function !***************************************************************************************** !***************************************************************************************** !> Frees the memory that was allocated by either the [[METIS_MeshToDual]] or the !  [[METIS_MeshToNodal]] routines for returning the dual or nodal graph of a mesh. ! !@warning Memory deallocation should always happen on the same side it was allocated! ! Also check the descriptions of the above-mentioned routines. ! !# Example ! !```Fortran ! type(c_ptr) :: xadj(:),adjncy(:) ! ! call METIS_MeshToNodal(...,xadj,adjncy) ! ! ! xadj and adjncy should be deallocated on the C side! ;) ! call METIS_Free(xadj) ! call METIS_Free(adjncy) !``` function METIS_Free ( ptr ) result ( ierr ) bind ( C , name = \"METIS_Free\" ) import c_int , c_ptr ! Parameters type ( c_ptr ), value :: ptr !! The pointer to be freed. This pointer should be one of the `xadj` or `adjncy` !! arrays returned by METIS' API routines. ! Returns integer ( c_int ) :: ierr !! `METIS_OK` - Indicates that the function returned normally. end function !***************************************************************************************** end interface end module !*****************************************************************************************","tags":"","loc":"sourcefile/metis_interface.f90.html","title":"metis_interface.f90 – Fortran METIS Interface"},{"text":"Modules parmetis_interface Source Code parmetis_interface.f90 Source Code ! parmetis_interface.f90 -- Fortran METIS Interface ! ! Copyright (C) 2018 Ivan Pribec <ivan.pribec@gmail.com> ! ! This software may be modified and distributed under the terms ! of the MIT license.  See the LICENSE file for details. ! http://glaros.dtc.umn.edu/gkhome/metis/parmetis/download ! http://glaros.dtc.umn.edu/gkhome/fetch/sw/parmetis/manual.pdf module parmetis_interface implicit none private ! Graph Partitioning public :: ParMETIS_V3_PartKway public :: ParMETIS_V3_PartGeomKway public :: ParMETIS_V3_PartGeom ( public :: ParMETIS_V3_PartMeshKway ! Graph Repartitioning public :: ParMETIS_V3_AdaptiveRepart ! Partitioning Refinement public :: ParMETIS_V3_RefineKway ! Fill-reducing Orderings public :: ParMETIS_V3_NodeND public :: ParMETIS_V32_NodeND ! Mesh to Graph Translation public :: ParMETIS_V32_Mesh2Dual interface ! ! Graph Partitioning ! function ParMETIS_V3_PartKway ( vtxdist , xadj , adjncy , vwgt , adjwgt , wgtflag , & numflag , ncon , nparts , tpwgts , ubvec , options , & edgecut , part , comm ) result ( ierr ) bind ( C , name = \"ParMETIS_V3_PartKway\" ) end function function ParMETIS_V3_PartGeomKway ( vtxdist , xadj , adjncy , vwgt , adjwgt , wgtflag , & numflag , ndims , xyz , ncon , nparts , tpwgts , & ubvec , options , edgecut , part , comm ) result ( ierr ) bind ( C , name = \"ParMETIS_V3_PartGeomKway\" ) end function function ParMETIS_V3_PartGeom ( vtxdist , ndims , xyz , part , comm ) result ( ierr ) bind ( C , name = \"ParMETIS_V3_PartGeom\" ) end function function ParMETIS_V3_PartMeshKway ( elmdist , eptr , eind , elmwgt , wgtflag , numflag , & ncon , ncommon , nparts , tpwgts , ubvec , & options , edgecut , part , comm ) result ( ierr ) bind ( C , name = \"ParMETIS_V3_PartMeshKway\" ) end function ! ! Graph Repartitioning ! function ParMETIS_V3_AdaptiveRepart ( vtxdist , xadj , adjncy , vwgt , vsize , adjwgt , & wgtflag , numflag , ncon , nparts , tpwgts , ubvec , & itr , options , edgecut , part , comm ) result ( ierr ) bind ( C , name = \"ParMETIS_V3_AdaptiveRepart\" ) ! ! Partitioning Refinement ! function ParMETIS_V3_RefineKway ( vtxdist , xadj , adjncy , vwgt , adjwgt , wgtflag , & numflag , ncon , nparts , tpwgts , ubvec , options , & edgecut , part , comm ) result ( ierr ) bind ( C , name = \"ParMETIS_V3_RefineKway\" ) ! ! Fill-reducing Orderings ! function ParMETIS_V3_NodeND ( vtxdist , xadj , adjncy , numflag , options , order , & sizes , comm ) result ( ierr ) bind ( C , name = \"ParMETIS_V3_NodeND\" ) end function function ParMETIS_V32_NodeND ( vtxdist , xadj , adjncy , vwgt , numflag , mtype , & rtype , p_nseps , s_nseps , ubfrac , seed , dbglvl , & order , sizes , comm ) result ( ierr ) bind ( C , name = \"ParMETIS_V32_NodeND\" ) end function ! ! Mesh to Graph Translation ! function ParMETIS_V32_Mesh2Dual ( elmdist , eptr , eind , numflag , ncommon , & xadj , adjncy , comm ) result ( ierr ) bind ( C , name = \"ParMETIS_V32_Mesh2Dual\" ) integer ( c_int ), intent ( in ) :: elmdist integer ( c_int ), intent ( in ) :: eptr , einf integer ( c_int ), intent ( in ) :: numflag integer ( c_int ), intent ( in ) :: ncommon type ( c_ptr ), intent ( out ) :: xadj , adjncy type ( c_ptr ), intent ( in ) :: comm end function end interface end module","tags":"","loc":"sourcefile/parmetis_interface.f90.html","title":"parmetis_interface.f90 – Fortran METIS Interface"},{"text":"Files Dependent On This One sourcefile~~metis_enum.f90~~AfferentGraph sourcefile~metis_enum.f90 metis_enum.f90 sourcefile~test_partgraphrecursive1.f90 test_PartGraphRecursive1.f90 sourcefile~metis_enum.f90->sourcefile~test_partgraphrecursive1.f90 sourcefile~test_partmeshnodal2.f90 test_PartMeshNodal2.f90 sourcefile~metis_enum.f90->sourcefile~test_partmeshnodal2.f90 sourcefile~test_partgraphkway.f90 test_PartGraphKway.f90 sourcefile~metis_enum.f90->sourcefile~test_partgraphkway.f90 sourcefile~test_partgraphrecursive2.f90 test_PartGraphRecursive2.f90 sourcefile~metis_enum.f90->sourcefile~test_partgraphrecursive2.f90 sourcefile~test_nodend.f90 test_NodeND.f90 sourcefile~metis_enum.f90->sourcefile~test_nodend.f90 sourcefile~test_partmeshnodal1.f90 test_PartMeshNodal1.f90 sourcefile~metis_enum.f90->sourcefile~test_partmeshnodal1.f90 sourcefile~metis_oo_interface.f90 metis_oo_interface.f90 sourcefile~metis_enum.f90->sourcefile~metis_oo_interface.f90 sourcefile~metis_tests.f90 metis_tests.f90 sourcefile~metis_enum.f90->sourcefile~metis_tests.f90 sourcefile~metis_io.f90 metis_io.f90 sourcefile~metis_enum.f90->sourcefile~metis_io.f90 sourcefile~metis_io.f90->sourcefile~metis_tests.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules metis_enum Source Code metis_enum.f90 Source Code ! metis_enum.f90 -- Fortran METIS Interface ! ! Copyright (C) 2018 Ivan Pribec <ivan.pribec@gmail.com> ! ! This software may be modified and distributed under the terms ! of the MIT license.  See the LICENSE file for details. module metis_enum implicit none public ! ! Enum type definitions ! ! Return codes integer , parameter :: METIS_OK = 1 !! Returned normally. integer , parameter :: METIS_ERROR_INPUT = - 2 !! Returned due to erroneous inputs and/or options. integer , parameter :: METIS_ERROR_MEMORY = - 3 !! Returned due to insufficient memory. integer , parameter :: METIS_ERROR = - 4 !! Return status: some other type of error. ! Operation type codes ! integer, parameter :: METIS_OP_PMETIS = 0 ! integer, parameter :: METIS_OP_KMETIS = 1 ! integer, parameter :: METIS_OP_OMETIS = 2 ! Options codes (i.e., `options`) integer , parameter :: METIS_OPTION_PTYPE = 0 !! Specifies the partitioning method. integer , parameter :: METIS_OPTION_OBJTYPE = 1 !! Specifies the type of objective. integer , parameter :: METIS_OPTION_CTYPE = 2 !! Specifies the matching scheme to be used during coarsening. integer , parameter :: METIS_OPTION_IPTYPE = 3 !! Determines the algorithm used during initial partitioning. integer , parameter :: METIS_OPTION_RTYPE = 4 !! Determines the algorithm used for refinement. integer , parameter :: METIS_OPTION_DBGLVL = 5 !! Specifies the amount of progress/debugging information will be printed. integer , parameter :: METIS_OPTION_NITER = 6 !! Specifies the number of iterations for the refinement algorithm. integer , parameter :: METIS_OPTION_NCUTS = 7 !! Specifies the number of different partitionings that it will compute. integer , parameter :: METIS_OPTION_SEED = 8 !! Specifies the seed for the random number generator. integer , parameter :: METIS_OPTION_NO2HOP = 9 !! Specifies that the coarsening will not perform any 2–hop matchings when the standard matching approach fails to sufficiently coarsen the graph. integer , parameter :: METIS_OPTION_MINCONN = 10 !! Specifies that the partitioning routines should try to minimize the maximum degree of the subdomain graph. integer , parameter :: METIS_OPTION_CONTIG = 11 !! Specifies that the partitioning routines should try to produce partitions that are contigous. integer , parameter :: METIS_OPTION_COMPRESS = 12 !! Specifies that the graph should be compressed by combining together vertices that have identical adjacency lists. integer , parameter :: METIS_OPTION_CCORDER = 13 !! Specifies if the connected components of the graph should first be identifies and ordered separately. integer , parameter :: METIS_OPTION_PFACTOR = 14 !! Specifies the minimum degree of the vertices that will be ordered last. integer , parameter :: METIS_OPTION_NSEPS = 15 !! Specifies the number of different separators that it will compute at each level of nested dissection. integer , parameter :: METIS_OPTION_UFACTOR = 16 !! Specifies the maximum allowed load imbalance among the partitions. integer , parameter :: METIS_OPTION_NUMBERING = 17 !! Used to indicate which numbering scheme is used for the adjacency structure of a graph or the element-node structure of a mesh ! Partitioning Schemes integer , parameter :: METIS_PTYPE_RB = 0 !! Multilevel recursive bisectioning. integer , parameter :: METIS_PTYPE_KWAY = 1 !! Multilevel k-way partitioning. ! Graph types for meshes ! integer, parameter :: METIS_GTYPE_DUAL  = 0 ! integer, parameter :: METIS_GTYPE_NODAL = 1 ! Coarsening Schemes integer , parameter :: METIS_CTYPE_RM = 0 !! Random matching. integer , parameter :: METIS_CTYPE_SHEM = 1 !! Sorted heavy-edge matching. ! Initial partitioning schemes integer , parameter :: METIS_IPTYPE_GROW = 0 !! Grows a bisection using a greedy strategy. integer , parameter :: METIS_IPTYPE_RANDOM = 1 !! Computes a bisection at random followed by a refinement. integer , parameter :: METIS_IPTYPE_EDGE = 2 !! Derives a separator form an edge cut. integer , parameter :: METIS_IPTYPE_NODE = 3 !! Grows a bisection using a greedy node-based strategy. integer , parameter :: METIS_IPTYPE_METISRB = 4 ! Refinement schemes integer , parameter :: METIS_RTYPE_FM = 0 !! FM-based cut refinement. integer , parameter :: METIS_RTYPE_GREEDY = 1 !! Greedy-based cut and volume refinement. integer , parameter :: METIS_RTYPE_SEP2SIDED = 2 !! Two-sided node FM refinement. integer , parameter :: METIS_RTYPE_SEP1SIDED = 3 !! One-sided node FM refinement. ! Debug Levels integer , parameter :: METIS_DBG_INFO = 1 !! Shows various diagnostic messages. integer , parameter :: METIS_DBG_TIME = 2 !! Perform timing analysis. integer , parameter :: METIS_DBG_COARSEN = 4 !! Show the coarsening progress. integer , parameter :: METIS_DBG_REFINE = 8 !! Show the refinement progress. integer , parameter :: METIS_DBG_IPART = 16 !! Show info on initial partitioning. integer , parameter :: METIS_DBG_MOVEINFO = 32 !! Show info on vertex moves during refinement. integer , parameter :: METIS_DBG_SEPINFO = 64 !! Show info on vertex moves during sep refinement. integer , parameter :: METIS_DBG_CONNINFO = 128 !! Show info on minimization of subdomain connectivity. integer , parameter :: METIS_DBG_CONTIGINFO = 256 !! Show info on elimination of connected components. integer , parameter :: METIS_DBG_MEMORY = 2048 !! Show info related to wspace allocation. ! Types of objectives integer , parameter :: METIS_OBJTYPE_CUT = 0 !! Edge-cut minimization. integer , parameter :: METIS_OBJTYPE_VOL = 1 !! Total communication volume minimization. integer , parameter :: METIS_OBJTYPE_NODE = 2 end module","tags":"","loc":"sourcefile/metis_enum.f90.html","title":"metis_enum.f90 – Fortran METIS Interface"},{"text":"This File Depends On sourcefile~~metis_io.f90~~EfferentGraph sourcefile~metis_io.f90 metis_io.f90 sourcefile~metis_interface.f90 metis_interface.f90 sourcefile~metis_interface.f90->sourcefile~metis_io.f90 sourcefile~metis_enum.f90 metis_enum.f90 sourcefile~metis_enum.f90->sourcefile~metis_io.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~metis_io.f90~~AfferentGraph sourcefile~metis_io.f90 metis_io.f90 sourcefile~metis_tests.f90 metis_tests.f90 sourcefile~metis_io.f90->sourcefile~metis_tests.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules metis_io Source Code metis_io.f90 Source Code ! metis_io.f90 -- Fortran METIS Interface ! ! Copyright (C) 2018 Ivan Pribec <ivan.pribec@gmail.com> ! ! This software may be modified and distributed under the terms ! of the MIT license.  See the LICENSE file for details. module metis_io use metis_interface use metis_enum implicit none public type :: MetisGraph integer :: nvtxs , nedgs integer , allocatable :: xadj (:), adjncy (:) end type contains subroutine write_graph ( fname , xadj , adjncy , numflag ) character ( len =* ), intent ( in ) :: fname integer , intent ( in ) :: xadj (:) integer , intent ( in ) :: adjncy (:) integer , intent ( in ) :: numflag integer :: unit , i , j print * , \"[write_graph] adjncy = \" , adjncy open ( newunit = unit , file = fname ) if ( numflag == 0 ) then write ( unit , * ) size ( xadj ) - 1 , size ( adjncy ) / 2 do i = 1 , size ( xadj ) - 1 write ( unit , * ) ( adjncy ( j ), j = xadj ( i ) + 1 , xadj ( i + 1 )) end do else write ( unit , * ) size ( xadj ) - 1 , size ( adjncy ) / 2 do i = 1 , size ( xadj ) - 1 write ( unit , * ) ( adjncy ( j ), j = xadj ( i ), xadj ( i + 1 ) - 1 ) end do end if close ( unit ) end subroutine logical function whitechar ( char ) ! white character ! returns .true. if char is space (32) or tab (9), .false. otherwise character , intent ( in ) :: char if ( iachar ( char ) == 32 . or . iachar ( char ) == 9 ) then whitechar = . true . else whitechar = . false . end if end function integer function count_columns ( unit , stat ) result ( ncol ) integer , intent ( in ) :: unit integer , intent ( out ) :: stat character ( len = 1 ) :: c logical :: lastwhite ncol = 0 lastwhite = . true . do read ( unit , '(a)' , advance = 'no' , iostat = stat ) c if ( stat /= 0 ) exit if ( lastwhite . and . . not . whitechar ( c )) ncol = ncol + 1 lastwhite = whitechar ( c ) end do end function subroutine load_graph ( this , fname , numflag ) type ( MetisGraph ), intent ( out ) :: this character ( len =* ), intent ( in ) :: fname integer , intent ( in ) :: numflag character ( len = 1 ) :: c integer :: unit , ncol , ios , i , rowcol , j logical :: lastwhite character ( len = 3 ) :: fmt integer :: n , m , ncon , ifmt integer , allocatable :: xadj (:), adjncy (:) integer , allocatable :: vsize (:), vwgt (:), adjwgt (:) integer , allocatable :: tmp (:) open ( newunit = unit , file = fname , status = 'old' ) ! determine number of columns in first row of file ncol = 0 lastwhite = . true . do read ( unit , '(a)' , advance = 'no' , iostat = ios ) c if ( ios /= 0 ) exit if ( lastwhite . and . . not . whitechar ( c )) ncol = ncol + 1 lastwhite = whitechar ( c ) end do ! back to start of file rewind ( unit ) ! read header line select case ( ncol ) case ( 2 ) fmt = \"000\" ncon = 0 read ( unit , * , iostat = ios ) n , m case ( 3 ) ncon = 0 read ( unit , * , iostat = ios ) n , m , fmt case ( 4 ) read ( unit , * , iostat = ios ) n , m , fmt , ncon case default write ( * , * ) \"[load_graph]: incorrect file\" stop end select read ( fmt , '(I3)' , iostat = ios ) ifmt print * , n , m , fmt , ncon print * , \"ifmt = \" , ifmt ! allocate vertex adjacency structures allocate ( xadj ( n + 1 )) allocate ( adjncy ( 2 * m )) ! perform bit-tests to check for weights and sizes if ( btest ( ifmt , 0 )) allocate ( adjwgt ( 2 * m )) if ( btest ( ifmt , 1 )) then if ( ncon == 0 ) then ncol = 4 ! implicit fourth column with 1 constraint ncon = 1 ! case for fmt = \"*1*\" and ncon is not specified end if if ( ncon > 0 ) then allocate ( vwgt ( n * ncon )) else print * , \"[load_graph] ncon has not been specified\" stop end if end if if ( btest ( ifmt , 2 )) allocate ( vsize ( n )) print * , \"allocated vertex sizes\" , allocated ( vsize ) print * , \"allocated vertex weights\" , allocated ( vwgt ) print * , \"allocated edge weights\" , allocated ( adjwgt ) xadj ( 1 ) = 0 select case ( ncol ) case ( 2 ) ! only connectivity, fmt = \"000\" do i = 1 , n rowcol = count_columns ( unit , stat = ios ) ! print *, \"rowcol = \", rowcol xadj ( i + 1 ) = xadj ( i ) + rowcol backspace ( unit , iostat = ios ) read ( unit , * ) adjncy ( xadj ( i ) + 1 : xadj ( i + 1 )) ! print *, (adjncy(j),j=xadj(i)+1, xadj(i+1)) end do case ( 3 ) ! edge weights or vertex sizes select case ( fmt ) case ( \"001\" ) do i = 1 , n rowcol = count_columns ( unit , stat = ios ) backspace ( unit , iostat = ios ) ! print *, \"rowcol = \", rowcol xadj ( i + 1 ) = xadj ( i ) + rowcol / 2 if ( allocated ( tmp )) deallocate ( tmp ) allocate ( tmp ( rowcol )) read ( unit , * ) tmp adjncy ( xadj ( i ) + 1 : xadj ( i + 1 )) = tmp ( 1 :: 2 ) adjwgt ( xadj ( i ) + 1 : xadj ( i + 1 )) = tmp ( 2 :: 2 ) end do case ( \"101\" ) do i = 1 , n rowcol = count_columns ( unit , stat = ios ) - 1 backspace ( unit , iostat = ios ) ! print *, \"rowcol = \", rowcol xadj ( i + 1 ) = xadj ( i ) + rowcol / 2 if ( allocated ( tmp )) deallocate ( tmp ) allocate ( tmp ( rowcol )) read ( unit , * ) vsize ( i ), tmp adjncy ( xadj ( i ) + 1 : xadj ( i + 1 )) = tmp ( 1 :: 2 ) adjwgt ( xadj ( i ) + 1 : xadj ( i + 1 )) = tmp ( 2 :: 2 ) end do case ( \"100\" ) do i = 1 , n rowcol = count_columns ( unit , stat = ios ) - 1 ! print *, \"rowcol = \", rowcol xadj ( i + 1 ) = xadj ( i ) + rowcol backspace ( unit , iostat = ios ) read ( unit , * ) vsize ( i ), ( adjncy ( j ), j = xadj ( i ) + 1 , xadj ( i + 1 )) ! print *, (adjncy(j),j=xadj(i)+1, xadj(i+1)) end do case default print * , \"should not be here\" stop end select case ( 4 ) ! vertex weights and constraint select case ( fmt ) case ( '010' ) do i = 1 , n rowcol = count_columns ( unit , stat = ios ) - ncon print * , ncon , rowcol xadj ( i + 1 ) = xadj ( i ) + rowcol backspace ( unit , iostat = ios ) read ( unit , * ) vwgt (( i - 1 ) * ncon + 1 :( i - 1 ) * ncon + ncon ), adjncy ( xadj ( i ) + 1 : xadj ( i + 1 )) end do case ( '011' ) do i = 1 , n rowcol = ( count_columns ( unit , stat = ios ) - ncon ) / 2 print * , ncon , rowcol backspace ( unit , iostat = ios ) xadj ( i + 1 ) = xadj ( i ) + rowcol if ( allocated ( tmp )) deallocate ( tmp ) allocate ( tmp ( 2 * rowcol )) read ( unit , * ) vwgt (( i - 1 ) * ncon + 1 :( i - 1 ) * ncon + ncon ), tmp adjncy ( xadj ( i ) + 1 : xadj ( i + 1 )) = tmp ( 1 :: 2 ) adjwgt ( xadj ( i ) + 1 : xadj ( i + 1 )) = tmp ( 2 :: 2 ) end do case ( '110' ) do i = 1 , n rowcol = count_columns ( unit , stat = ios ) - 1 - ncon print * , ncon , rowcol xadj ( i + 1 ) = xadj ( i ) + rowcol backspace ( unit , iostat = ios ) read ( unit , * ) vsize ( i ), vwgt (( i - 1 ) * ncon + 1 :( i - 1 ) * ncon + ncon ), adjncy ( xadj ( i ) + 1 : xadj ( i + 1 )) end do case ( '111' ) do i = 1 , n rowcol = ( count_columns ( unit , stat = ios ) - 1 - ncon ) / 2 print * , ncon , rowcol backspace ( unit , iostat = ios ) xadj ( i + 1 ) = xadj ( i ) + rowcol if ( allocated ( tmp )) deallocate ( tmp ) allocate ( tmp ( 2 * rowcol )) read ( unit , * ) vsize ( i ), vwgt (( i - 1 ) * ncon + 1 :( i - 1 ) * ncon + ncon ), tmp adjncy ( xadj ( i ) + 1 : xadj ( i + 1 )) = tmp ( 1 :: 2 ) adjwgt ( xadj ( i ) + 1 : xadj ( i + 1 )) = tmp ( 2 :: 2 ) end do case default print * , \"should not be here\" stop end select ! fmt case default print * , \"[load_graph] error\" stop end select ! ncol this % nvtxs = n this % nedgs = m this % xadj = xadj if ( numflag == 0 ) then this % adjncy = adjncy else this % adjncy = adjncy + 1 end if ! print *, \"xadj = \", xadj ! print *, \"adjncy = \",adjncy ! print *, \"edge weights = \", adjwgt ! print *, \"vsize = \", vsize ! print *, \"vertex weights = \", vwgt close ( unit ) end subroutine subroutine print_metis_options ( opts , unit ) use iso_fortran_env , only : output_unit integer , intent ( in ) :: opts ( 0 :) integer , intent ( in ), optional :: unit integer :: i , unit_ unit_ = output_unit ! standard output if ( present ( unit )) unit_ = unit do i = 0 , METIS_NOPTIONS - 1 write ( unit_ , '(\"Option \",I2,\":\",I3)' ) i , opts ( i ) end do end subroutine subroutine ForMETIS_MeshToNodal ( ne , nn , eptr , eind , numflag , xadj , adjncy , stat ) use iso_c_binding , only : c_int , c_ptr , c_f_pointer integer , intent ( in ) :: ne integer , intent ( in ) :: nn integer , intent ( in ) :: eptr ( ne + 1 ) integer , intent ( in ) :: eind (:) integer , intent ( in ) :: numflag integer , intent ( out ), allocatable :: xadj (:) integer , intent ( out ), allocatable :: adjncy (:) integer , intent ( out ) :: stat type ( c_ptr ) :: xadj_ , adjncy_ integer ( c_int ), pointer :: fxadj (:) => null (), fadjncy (:) => null () stat = METIS_MeshToNodal ( ne , nn , eptr , eind , numflag , xadj_ , adjncy_ ) if ( stat < 0 ) return call c_f_pointer ( xadj_ , fxadj , shape = [ nn + 1 ]) select case ( numflag ) case ( 0 ) call c_f_pointer ( adjncy_ , fadjncy , shape = [ fxadj ( nn + 1 )]) case ( 1 ) call c_f_pointer ( adjncy_ , fadjncy , shape = [ fxadj ( nn + 1 ) - 1 ]) end select ! xadj => fxadj allocate ( xadj ( size ( fxadj ))) xadj = fxadj allocate ( adjncy ( size ( fadjncy )), stat = stat ) adjncy = fadjncy stat = METIS_Free ( xadj_ ); ! if (stat < 0) return stat = METIS_Free ( adjncy_ ) ! if (stat < 0) return end subroutine end module","tags":"","loc":"sourcefile/metis_io.f90.html","title":"metis_io.f90 – Fortran METIS Interface"},{"text":"This File Depends On sourcefile~~metis_oo_interface.f90~~EfferentGraph sourcefile~metis_oo_interface.f90 metis_oo_interface.f90 sourcefile~metis_interface.f90 metis_interface.f90 sourcefile~metis_interface.f90->sourcefile~metis_oo_interface.f90 sourcefile~metis_enum.f90 metis_enum.f90 sourcefile~metis_enum.f90->sourcefile~metis_oo_interface.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules metis_oo_interface Source Code metis_oo_interface.f90 Source Code ! metis_oo_interface.f90 -- Fortran METIS Interface ! ! Copyright (C) 2018 Ivan Pribec <ivan.pribec@gmail.com> ! ! This software may be modified and distributed under the terms ! of the MIT license.  See the LICENSE file for details. module metis_oo_interface use metis_enum use metis_interface implicit none public :: graph_type public :: export_graph type :: graph_type integer :: nvxts !! Number of vertices. integer :: nedgs !! Number of edges. integer , pointer :: xadj (:) => null () integer , pointer :: adjncy (:) => null () integer :: numflag = 1 !! Numbering style. integer :: ncon integer , pointer :: vwgt (:) => null () integer , pointer :: adjwgt (:) => null () integer , pointer :: vsize (:) => null () end type contains subroutine import_graph ( fname , graph , numflag ) character ( len =* ), intent ( in ) :: fname class ( graph_type ), intent ( out ) :: graph integer , intent ( in ), optional :: numflag integer :: unit , ios if ( present ( numflag )) graph % numflag = numflag open ( newunit = unit , file = fname , status = 'old' , iostat = ios ) call read_graph ( unit , graph % xadj , graph % adjncy , numflag = graph % numflag , vwgt = graph % vwgt , & adjwgt = graph % adjwgt , vsize = graph % vsize ) print * , graph % adjncy graph % nvxts = size ( graph % xadj ) - 1 graph % nedgs = size ( graph % adjncy ) / 2 close ( unit ) end subroutine subroutine export_graph ( fname , graph ) character ( len =* ), intent ( in ) :: fname class ( graph_type ), intent ( in ) :: graph integer :: unit open ( newunit = unit , file = fname ) call write_graph ( unit , graph % xadj , graph % adjncy , graph % numflag , & graph % vwgt , graph % adjwgt , graph % vsize ) close ( unit ) end subroutine subroutine write_graph ( unit , xadj , adjncy , numflag , vwgt , adjwgt , vsize ) integer , intent ( in ) :: unit integer , intent ( in ) :: xadj (:) integer , intent ( in ) :: adjncy (:) integer , intent ( in ), optional :: numflag integer , intent ( in ), optional :: vwgt (:) integer , intent ( in ), optional :: adjwgt (:) integer , intent ( in ), optional :: vsize (:) integer :: nvxts , nedgs , ncon , numflag_ , i , j , fmt character ( len = 3 ) :: cfmt character ( len = 11 ) :: fstring fstring = '(*(i0,:,x))' ! Format string for graph output numflag_ = 1 ! Assume Fortran numbering by default if ( present ( numflag )) numflag_ = numflag ! Get number of vertices and edges nvxts = size ( xadj ) - 1 nedgs = size ( adjncy ) / 2 ! Format specifier fmt = 0 if ( present ( adjwgt )) fmt = ibset ( fmt , 0 ) if ( present ( vwgt )) fmt = ibset ( fmt , 1 ) if ( present ( vsize )) fmt = ibset ( fmt , 2 ) ! Number of constraints ncon = 0 if ( btest ( fmt , 1 )) ncon = size ( vwgt ) / nvxts ! Write header line if ( fmt > 0 ) then ! Write fmt to character string write ( cfmt , '(b3.3)' ) fmt if ( btest ( fmt , 1 )) then if ( ncon > 1 ) write ( unit , '(i0,1x,i0,1x,a3,1x,i0)' ) nvxts , nedgs , cfmt , ncon else write ( unit , '(i0,1x,i0,1x,a3)' ) nvxts , nedgs , cfmt end if else write ( unit , '(i0,1x,i0)' ) nvxts , nedgs end if select case ( fmt ) case ( b '000' ) do i = 1 , nvxts ! v1 v2 v3 ... write ( unit , fstring ) ( adjncy ( j ), j = xadj ( i ), xadj ( i + 1 ) - 1 ) end do case ( b '001' ) ! edge weights do i = 1 , nvxts ! v1 e1 v2 e2 ... write ( unit , fstring ) ( adjncy ( j ), adjwgt ( j ), j = xadj ( i ), xadj ( i + 1 ) - 1 ) end do case ( b '010' ) ! vertex weights do i = 1 , nvxts ! w1 w2 ... wncon v1 v2 v3 ... write ( unit , fstring ) vwgt (( i - 1 ) * ncon + 1 :( i - 1 ) * ncon + ncon ),( adjncy ( j ), j = xadj ( i ), xadj ( i + 1 ) - 1 ) end do case ( b '100' ) ! vertex sizes do i = 1 , nvxts write ( unit , fstring ) vsize ( i ), ( adjncy ( j ), j = xadj ( i ), xadj ( i + 1 ) - 1 ) end do case ( b '011' ) do i = 1 , nvxts write ( unit , fstring ) vwgt (( i - 1 ) * ncon + 1 :( i - 1 ) * ncon + ncon ), ( adjncy ( j ), adjwgt ( j ), j = xadj ( i ), xadj ( i + 1 ) - 1 ) end do case ( b '110' ) do i = 1 , nvxts write ( unit , fstring ) vsize ( i ), vwgt (( i - 1 ) * ncon + 1 :( i - 1 ) * ncon + ncon ),( adjncy ( j ), j = xadj ( i ), xadj ( i + 1 ) - 1 ) end do case ( b '101' ) do i = 1 , nvxts write ( unit , fstring ) vsize ( i ), ( adjncy ( j ), adjwgt ( j ), j = xadj ( i ), xadj ( i + 1 ) - 1 ) end do case ( b '111' ) do i = 1 , nvxts write ( unit , fstring ) vsize ( i ), vwgt (( i - 1 ) * ncon + 1 :( i - 1 ) * ncon + ncon ), ( adjncy ( j ), adjwgt ( j ), j = xadj ( i ), xadj ( i + 1 ) - 1 ) end do case default write ( * , * ) '[write_graph] Error occured' end select end subroutine logical function whitechar ( char ) ! white character ! returns .true. if char is space (32) or tab (9), .false. otherwise character , intent ( in ) :: char if ( iachar ( char ) == 32 . or . iachar ( char ) == 9 ) then whitechar = . true . else whitechar = . false . end if end function integer function count_columns ( unit , stat ) result ( ncol ) integer , intent ( in ) :: unit integer , intent ( out ) :: stat character ( len = 1 ) :: c logical :: lastwhite ncol = 0 lastwhite = . true . do read ( unit , '(a)' , advance = 'no' , iostat = stat ) c if ( stat /= 0 ) exit if ( lastwhite . and . . not . whitechar ( c )) ncol = ncol + 1 lastwhite = whitechar ( c ) end do backspace ( unit , iostat = stat ) end function subroutine read_graph ( unit , xadj , adjncy , numflag , vwgt , adjwgt , vsize ) implicit none integer , intent ( in ) :: unit integer , intent ( out ), pointer :: xadj (:) integer , intent ( out ), pointer :: adjncy (:) integer , intent ( in ), optional :: numflag integer , pointer , optional :: vwgt (:) integer , intent ( out ), pointer , optional :: adjwgt (:) integer , intent ( out ), pointer , optional :: vsize (:) character ( len = 1 ) :: c integer :: ncol , ios , i , rowcol , j logical :: lastwhite character ( len = 3 ) :: cfmt integer :: nvtxs , nedgs , ncon , fmt , numflag_ numflag_ = 1 ! Assume Fortran numbering by default if ( present ( numflag )) numflag_ = numflag ! Determine number of columns in header line ncol = 0 lastwhite = . true . do read ( unit , '(a)' , advance = 'no' , iostat = ios ) c ! if (iachar(c) == 37) then !     read(unit,*) ! skipline !     print *, \"Skipped line\" !     cycle ! end if if ( ios /= 0 ) exit if ( lastwhite . and . . not . whitechar ( c )) ncol = ncol + 1 lastwhite = whitechar ( c ) end do print * , \"Number of columns in header = \" , ncol rewind ( unit ) ! do !     read(unit,'(a)',iostat=ios) c !     if (iachar(c) == 37) then !         print *, \"Skipped line\" !         cycle !     else !         backspace(unit) !         exit !     end if ! end do ! Parse values in header line ncon = 1 cfmt = '000' select case ( ncol ) case ( 2 ) read ( unit , * , iostat = ios ) nvtxs , nedgs case ( 3 ) read ( unit , * , iostat = ios ) nvtxs , nedgs , cfmt case ( 4 ) read ( unit , * , iostat = ios ) nvtxs , nedgs , cfmt , ncon print * , \"hello\" case default write ( * , * ) \"[load_graph]: incorrect file\" stop end select read ( cfmt , '(b3.3)' ) fmt print * , nvtxs , nedgs , cfmt , ncon write ( * , '(A,B3.3)' ) \"fmt = \" , fmt ! Allocate necessary space allocate ( xadj ( nvtxs + 1 )) allocate ( adjncy ( 2 * nedgs )) if ( btest ( fmt , 0 )) allocate ( adjwgt ( 2 * nedgs )) if ( btest ( fmt , 1 )) allocate ( vwgt ( nvtxs * ncon )) if ( btest ( fmt , 2 )) allocate ( vsize ( nvtxs )) write ( * , * ) associated ( vsize ), associated ( vwgt ), associated ( adjwgt ) ! stop xadj ( 1 ) = 0 select case ( fmt ) case ( b '000' ) do i = 1 , nvtxs rowcol = count_columns ( unit , stat = ios ) xadj ( i + 1 ) = xadj ( i ) + rowcol read ( unit , * ) adjncy ( xadj ( i ) + 1 : xadj ( i + 1 )) end do case ( b '001' ) do i = 1 , nvtxs rowcol = count_columns ( unit , stat = ios ) / 2 xadj ( i + 1 ) = xadj ( i ) + rowcol read ( unit , * ) ( adjncy ( j ), adjwgt ( j ), j = xadj ( i ) + 1 , xadj ( i + 1 )) end do case ( b '010' ) do i = 1 , nvtxs rowcol = count_columns ( unit , stat = ios ) - ncon xadj ( i + 1 ) = xadj ( i ) + rowcol read ( unit , * ) vwgt (( i - 1 ) * ncon + 1 :( i - 1 ) * ncon + ncon ), adjncy ( xadj ( i ) + 1 : xadj ( i + 1 )) end do case ( b '100' ) do i = 1 , nvtxs rowcol = count_columns ( unit , stat = ios ) - 1 xadj ( i + 1 ) = xadj ( i ) + rowcol read ( unit , * ) vsize ( i ), adjncy ( xadj ( i ) + 1 : xadj ( i + 1 )) end do case ( b '011' ) do i = 1 , nvtxs rowcol = ( count_columns ( unit , stat = ios ) - ncon ) / 2 xadj ( i + 1 ) = xadj ( i ) + rowcol read ( unit , * ) vwgt (( i - 1 ) * ncon + 1 :( i - 1 ) * ncon + ncon ), ( adjncy ( j ), adjwgt ( j ), j = xadj ( i ) + 1 , xadj ( i + 1 )) end do case ( b '110' ) do i = 1 , nvtxs rowcol = count_columns ( unit , stat = ios ) - 1 - ncon xadj ( i + 1 ) = xadj ( i ) + rowcol read ( unit , * ) vsize ( i ), vwgt (( i - 1 ) * ncon + 1 :( i - 1 ) * ncon + ncon ), adjncy ( xadj ( i ) + 1 : xadj ( i + 1 )) end do case ( b '101' ) do i = 1 , nvtxs rowcol = ( count_columns ( unit , stat = ios ) - 1 ) / 2 xadj ( i + 1 ) = xadj ( i ) + rowcol read ( unit , * ) vsize ( i ), ( adjncy ( j ), adjwgt ( j ), j = xadj ( i ) + 1 , xadj ( i + 1 )) end do case ( b '111' ) do i = 1 , nvtxs rowcol = ( count_columns ( unit , stat = ios ) - 1 - ncon ) / 2 xadj ( i + 1 ) = xadj ( i ) + rowcol read ( unit , * ) vsize ( i ), vwgt (( i - 1 ) * ncon + 1 :( i - 1 ) * ncon + ncon ), ( adjncy ( j ), adjwgt ( j ), j = xadj ( i ) + 1 , xadj ( i + 1 )) end do case default print * , \"[read_graph] should not be here\" stop end select if ( numflag_ == 0 ) then adjncy = adjncy - 1 else xadj = xadj + 1 end if end subroutine end module","tags":"","loc":"sourcefile/metis_oo_interface.f90.html","title":"metis_oo_interface.f90 – Fortran METIS Interface"},{"text":"This File Depends On sourcefile~~metis_tests.f90~~EfferentGraph sourcefile~metis_tests.f90 metis_tests.f90 sourcefile~metis_interface.f90 metis_interface.f90 sourcefile~metis_interface.f90->sourcefile~metis_tests.f90 sourcefile~metis_io.f90 metis_io.f90 sourcefile~metis_interface.f90->sourcefile~metis_io.f90 sourcefile~metis_io.f90->sourcefile~metis_tests.f90 sourcefile~metis_enum.f90 metis_enum.f90 sourcefile~metis_enum.f90->sourcefile~metis_tests.f90 sourcefile~metis_enum.f90->sourcefile~metis_io.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs test_fmetis Modules metis_tests Source Code metis_tests.f90 Source Code ! metis_tests.f90 -- Fortran METIS Interface ! ! Copyright (C) 2018 Ivan Pribec <ivan.pribec@gmail.com> ! ! This software may be modified and distributed under the terms ! of the MIT license.  See the LICENSE file for details. module metis_tests use metis_interface use metis_io implicit none private public :: test1 , test2 , test3 , test4 contains ! https://stackoverflow.com/questions/20006253/using-metis-libraries-in-fortran-code-the-basics ! http://glaros.dtc.umn.edu/gkhome/node/852 subroutine test1 () use , intrinsic :: iso_c_binding , only : c_int , c_ptr , c_f_pointer integer , parameter :: nel = 3 ! number of elements integer , parameter :: nnds = 8 ! number of nodes integer , parameter :: npel = 4 ! nodes per element integer :: eptr ( nel + 1 ) integer :: eind ( nel * npel ) integer :: epart ( nel ), npart ( nnds ) integer ( c_int ) :: options ( 0 : METIS_NOPTIONS - 1 ) integer :: ios , objval type ( c_ptr ) :: xadj , adjncy integer ( c_int ), pointer :: fxadj (:) => null (), fadjncy (:) => null () integer , allocatable :: new_xadj (:), new_adjncy (:) print * , \"TEST 1\" ! 0---1---4---6 ! : 0 : 1 : 2 : ! 3---2---5---7 eptr = [ 0 , 4 , 8 , 12 ] eind = [ 0 , 1 , 2 , 3 , 1 , 4 , 5 , 2 , 4 , 6 , 7 , 5 ] ! Element 1 has nodes 0 1 2 3 ! Element 2 has nodes 1 4 5 2 ios = METIS_SetDefaultOptions ( options ) options ( 17 ) = 0 ios = METIS_PartMeshNodal ( nel , nnds , eptr , eind , nparts = 2 , options = options ,& objval = objval , epart = epart , npart = npart ) print * , \"ios = \" , ios print * , \"objval = \" , objval print * , \"npart = \" , npart print * , \"epart = \" , epart call ForMETIS_MeshToNodal ( nel , nnds , eptr , eind , 0 , new_xadj , new_adjncy , ios ) print * , \"new_xadj = \" , new_xadj print * , \"new_adjncy = \" , new_adjncy ios = METIS_MeshToNodal ( nel , nnds , eptr , eind , 0 , xadj , adjncy ) ! print *, \"xadj = \", xadj ! print *, \"adjncy = \", adjncy call c_f_pointer ( xadj , fxadj , shape = [ nnds + 1 ]) call c_f_pointer ( adjncy , fadjncy , shape = [ fxadj ( nnds + 1 )]) print * , \"size=\" , size ( fxadj ), \"fxadj = \" , fxadj print * , \"fadjncy = \" , fadjncy call write_graph ( \"test1.graph\" , fxadj , fadjncy , 1 ) ios = METIS_Free ( xadj ) ! print *, \"xadj = \", xadj ! print *, \"fxadj = \", fxadj ! ios = METIS_Free(adjncy) end subroutine ! https://stackoverflow.com/questions/8155160/metis-with-fortran ! http://glaros.dtc.umn.edu/gkhome/node/799 subroutine test2 () use , intrinsic :: iso_c_binding , only : c_int integer , parameter :: nvtxs = 15 integer , parameter :: nedgs = 22 integer :: xadj ( nvtxs + 1 ), adjncy ( 2 * nedgs ) integer :: objval , part ( nvtxs ), ios print * , \"TEST 2\" xadj = [ 0 , 2 , 5 , 8 , 11 , 13 , 16 , 20 , 24 , 28 , 31 , 33 , 36 , 39 , 42 , 44 ] adjncy = [ 1 , 5 , 0 , 2 , 6 , 1 , 3 , 7 , 2 , 4 , 8 , 3 , 9 , 0 , 6 , 10 , 1 , 5 , 7 , 11 , 2 , 6 , 8 , 12 , 3 , 7 , 9 , 13 , 4 , 8 , 14 , 5 , 11 , 6 , 10 , 12 , 7 , 11 , 13 , 8 , 12 , 14 , 9 , 13 ] ! options(18) = 0 ! C-style indexing ios = METIS_PartGraphRecursive ( nvtxs , ncon = 1 , xadj = xadj , adjncy = adjncy , nparts = 2 , objval = objval , part = part ) print * , \"ios = \" , ios print * , \"objval = \" , objval print * , \"part = \" , part end subroutine ! http://comp.lang.fortran.narkive.com/uFmDM7Bo/how-to-call-a-metis-subroutine-from-my-fortran-code subroutine test3 () !  1---2---3---4---5 !  |   |   |   |   | !  6---7---8---9---10 !  |   |   |   |   | !  11--12--13--14--15 integer , parameter :: n = 15 integer , parameter :: m = 22 integer :: xadj ( n + 1 ), adjncy ( 2 * m ) integer :: perm ( n ), iperm ( n ) integer :: options ( 0 : 40 ), ios print * , \"TEST 3\" xadj = [ 1 , 3 , 6 , 9 , 12 , 14 , 17 , 21 , 25 , 29 , 32 , 34 , 37 , 40 , 43 , 45 ] adjncy = [ 2 , 6 , 1 , 3 , 7 , 2 , 4 , 8 , 3 , 5 , 9 , 4 , 10 , 1 , 7 , 11 , 2 , 6 , & 8 , 12 , 3 , 7 , 9 , 13 , 4 , 8 , 10 , 14 , 5 , 9 , 15 , 6 , 12 , 7 , 11 , 13 , & 8 , 12 , 14 , 9 , 13 , 15 , 10 , 14 ] ios = METIS_SetDefaultOptions ( options ) options ( 17 ) = 1 ios = METIS_NodeND ( n , xadj , adjncy , options = options , perm = perm , iperm = iperm ) print * , \"ios = \" , ios print * , \"perm = \" , perm print * , \"iperm = \" , iperm end subroutine ! https://www.cfd-online.com/Forums/main/112366-using-metis-functions-fortran.html subroutine test4 !  1---2---5 !  | 1 | 2 | !  4---3---6 !  | 4 | 3 | !  9---8---7 integer , parameter :: ne = 4 integer , parameter :: nn = 9 integer :: eptr ( ne + 1 ), eind ( 4 * ne ) integer :: epart ( ne ), npart ( nn ) integer :: opts ( 0 : 39 ), ios , objval print * , \"TEST 4\" eptr = [ 1 , 5 , 9 , 13 , 17 ] eind = [ 1 , 2 , 3 , 4 , 2 , 5 , 6 , 3 , 3 , 6 , 7 , 8 , 4 , 3 , 8 , 9 ] ios = METIS_SetDefaultOptions ( opts ) opts ( 17 ) = 1 opts ( METIS_OPTION_CONTIG ) = 1 call print_options ( opts ) ios = METIS_PartMeshDual ( ne , nn , eptr , eind , ncommon = 2 , nparts = 2 , options = opts , & objval = objval , epart = epart , npart = npart ) ! ios = METIS_PartMeshNodal(ne,nn,eptr,eind,nparts=2,options=opts, & ! objval=objval,epart=epart,npart=npart) print * , \"ios = \" , ios print * , \"objval = \" , objval print * , \"epart = \" , epart print * , \"npart = \" , npart end subroutine end module program test_fmetis use iso_c_binding use metis_interface use metis_enum use metis_io type ( MetisGraph ) :: mgraph integer , allocatable :: xadj (:), adjncy (:), part (:) integer ( c_int ) :: options ( 40 ), ios , ncon , objval xadj = [ 0 , 3 , 6 , 10 , 14 , 17 , 20 , 22 ] adjncy = [ 5 , 3 , 2 , 1 , 3 , 4 , 5 , 4 , 2 , 1 , 2 , 3 , 6 , 7 , 1 , 3 , 6 , 5 , 4 , 7 , 6 , 4 ] - 1 print * , \"n = \" , size ( xadj ) - 1 print * , \"2*m = \" , size ( adjncy ) call write_graph ( \"example.graph\" , xadj , adjncy , 0 ) ! call load_graph(mgraph,\"../graphs/4elt.graph\",numflag=0) call load_graph ( mgraph , \"example.graph\" , numflag = 0 ) print * , mgraph % nvtxs print * , mgraph % nedgs print * , mgraph % xadj print * , mgraph % adjncy ! call write_graph(\"print.graph\",) ios = METIS_SetDefaultOptions ( options ) options ( 18 ) = 0 print * , \"ios = \" , ios allocate ( part ( mgraph % nvtxs )) ncon = 1 ios = METIS_PartGraphKway ( mgraph % nvtxs , ncon , mgraph % xadj , mgraph % adjncy ,& nparts = 2 , objval = objval , part = part , options = options ) print * , \"ios = \" , ios print * , \"objval = \" , objval print * , \"part = \" , part write ( * , * ) call test1 print * , \" \" call test2 print * , \" \" call test3 print * , \" \" call test4 end program","tags":"","loc":"sourcefile/metis_tests.f90.html","title":"metis_tests.f90 – Fortran METIS Interface"},{"text":"type, public :: MetisGraph Variables nvtxs nedgs xadj adjncy Components Type Visibility Attributes Name Initial integer, public :: nvtxs integer, public :: nedgs integer, public, allocatable :: xadj (:) integer, public, allocatable :: adjncy (:)","tags":"","loc":"type/metisgraph.html","title":"MetisGraph – Fortran METIS Interface "},{"text":"type, public :: graph_type Variables nvxts nedgs xadj adjncy numflag ncon vwgt adjwgt vsize Components Type Visibility Attributes Name Initial integer, public :: nvxts Number of vertices. integer, public :: nedgs Number of edges. integer, public, pointer :: xadj (:) => null() integer, public, pointer :: adjncy (:) => null() integer, public :: numflag = 1 Numbering style. integer, public :: ncon integer, public, pointer :: vwgt (:) => null() integer, public, pointer :: adjwgt (:) => null() integer, public, pointer :: vsize (:) => null()","tags":"","loc":"type/graph_type.html","title":"graph_type – Fortran METIS Interface "},{"text":"interface Called By interface~~metis_partgraphrecursive~~CalledByGraph interface~metis_partgraphrecursive METIS_PartGraphRecursive proc~test2 test2 proc~test2->interface~metis_partgraphrecursive Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public function METIS_PartGraphRecursive(nvtxs, ncon, xadj, adjncy, vwgt, vsize, adjwgt, nparts, tpwgts, ubvec, options, objval, part) result(ierr) bind(C,name=\"METIS_PartGraphRecursive\") Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: nvtxs The number of vertices in the graph. integer(kind=c_int), intent(in) :: ncon The number of balancing constraints. It should be atleast 1. integer(kind=c_int), intent(in), dimension(*) :: xadj The adjacency structure of the graph as described in section 5.5 of the manual . integer(kind=c_int), intent(in), dimension(*) :: adjncy The adjacency structure of the graph as described in section 5.5 of the manual . integer(kind=c_int), intent(in), optional dimension(*) :: vwgt The weights of the vertices as described in Section 5.5 of the manual . integer(kind=c_int), intent(in), optional dimension(*) :: vsize The size of the vertices for computing the total communication volume as described in section 5.7 of the manual . integer(kind=c_int), intent(in), optional dimension(*) :: adjwgt The weights of the edges as describe in Section 5.5 of the manual . integer(kind=c_int), intent(in) :: nparts The number of parts to partition the graph. real(kind=c_double), intent(in), optional :: tpwgts (nparts*ncon) An array of size nparts*ncon that specifies the desired weight for each partition and constraint.\n If not present, the graph is divided equally among the partitions. More in the description. real(kind=c_double), intent(in), optional :: ubvec (ncon) An array of size ncon that specifies the allowed load imbalance for each constraint. \n For the i -th partition and j -th constraint the allowed weight is the ubvec(j)*tpwgts(i*ncon+j) fraction of the j -th's constraint total weight. If not present, the load imbalance\n tolerance is 1.001 (for ncon = 1 ) or 1.01 (for ncon > 1 ). integer(kind=c_int), intent(in), optional :: options (METIS_NOPTIONS) An array of options as described in Section 5.4 of the METIS manual. See description for valid options. integer(kind=c_int), intent(out) :: objval Upon successful completion, this variable stores the edge-cut or the total communication volume of the partitioning\n solution. The value returned depends on the partitioning's objective function. integer(kind=c_int), intent(out) :: part (nvtxs) This is a vector of size nvtxs that upon successful completion stores the partition vector of the graph.\n The numbering of this vector starts from either 0 or 1, depending on the value of options(METIS_OPTION_NUMBERING) . Return Value integer(kind=c_int) METIS_OK - Indicates that the function returned normally. METIS_ERROR_INPUT - Indicates an input error. METIS_ERROR_MEMORY - Indicates that it could not allocate the required memory. METIS_ERROR - Indicates some other type of error. Description This function is used to partition a graph into nparts parts using recursive bisection. If tpwgt is present, the target partition weight for the i -th partition and j -th constraint should\n  be specified at tpwgts(i*ncon+j) (the numbering for both partitions and constraints starts from 0).\n  For each constraint, the sum of the tpwgts entries must be 1.0. The following options are valid: METIS_OPTION_CTYPE , METIS_OPTION_IPTYPE , METIS_OPTION_RTYPE , METIS_OPTION_NO2HOP , METIS_OPTION_NCUTS , METIS_OPTION_NITER , METIS_OPTION_SEED , METIS_OPTION_UFACTOR , METIS_OPTION_NUMBERING , METIS_OPTION_DBGLVL","tags":"","loc":"interface/metis_partgraphrecursive.html","title":"METIS_PartGraphRecursive – Fortran METIS Interface"},{"text":"interface Called By interface~~metis_partgraphkway~~CalledByGraph interface~metis_partgraphkway METIS_PartGraphKway program~test_fmetis test_fmetis program~test_fmetis->interface~metis_partgraphkway Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public function METIS_PartGraphKway(nvtxs, ncon, xadj, adjncy, vwgt, vsize, adjwgt, nparts, tpwgts, ubvec, options, objval, part) result(ierr) bind(C,name=\"METIS_PartGraphKway\") Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: nvtxs The number of vertices in the graph. integer(kind=c_int), intent(in) :: ncon The number of balancing constraints. It should be at least 1. integer(kind=c_int), intent(in), dimension(*) :: xadj The adjacency structure of the graph as described in section 5.5 of the manual . integer(kind=c_int), intent(in), dimension(*) :: adjncy The adjacency structure of the graph as described in section 5.5 of the manual . integer(kind=c_int), intent(in), optional dimension(*) :: vwgt The weights of the vertices as described in Section 5.5 of the manual . integer(kind=c_int), intent(in), optional dimension(*) :: vsize The size of the vertices for computing the total communication volume as described in section 5.7 of the manual . integer(kind=c_int), intent(in), optional dimension(*) :: adjwgt The weights of the edges as describe in Section 5.5 of the manual . integer(kind=c_int), intent(in) :: nparts The number of parts to partition the graph. real(kind=c_double), intent(in), optional :: tpwgts (nparts*ncon) An array of size nparts*ncon that specifies the desired weight for each partition and constraint.\n If not present, the graph is divided equally among the partitions. More in the description. real(kind=c_double), intent(in), optional :: ubvec (ncon) An array of size ncon that specifiew the allowed load imbalance for each constraint. \n For the i -th partition and j -th constraint the allowed weight is the ubvec(j)*tpwgts(i*ncon+j) fraction of the j -th's constraint total weight. If not present, the load imbalance\n tolerance is 1.001 (for ncon == 1 ) or 1.01 (for ncon > 1 ). integer(kind=c_int), intent(in), optional :: options (METIS_NOPTIONS) An array of options as described in Section 5.4 of the manual . See description for valid options. integer(kind=c_int), intent(out) :: objval Upon successful completion, this variable stores the edge-cut or the total communication volume of the partitioning\n solution. The value returned depends on the partitioning's objective function. integer(kind=c_int), intent(out) :: part (nvtxs) This is a vector of size nvtxs that upon successful completion stores the partition vector of the graph.\n The numbering of this vector starts from either 0 or 1, depending on the value of options(METIS_OPTION_NUMBERING) . Return Value integer(kind=c_int) METIS_OK - Indicates that the function returned normally. METIS_ERROR_INPUT - Indicates an input error. METIS_ERROR_MEMORY - Indicates that it could not allocate the required memory. METIS_ERROR - Indicates some other type of error. Description This function is used to partition a graph into nparts parts using multilevel k-way partitioning. If tpwgt is present, the target partition weight for the i -th partition and j -th constraint should\n  be specified at tpwgts(i*ncon+j) (the numbering for both partitions and constraints starts from 0).\n  For each constraint, the sum of the tpwgts entries must be 1.0. The following options are valid: METIS_OPTION_OBJTYPE , METIS_OPTION_CTYPE , METIS_OPTION_IPTYPE , METIS_OPTION_RTYPE , METIS_OPTION_NO2HOP , METIS_OPTION_NCUTS , METIS_OPTION_NITER , METIS_OPTION_UFACTOR , METIS_OPTION_MINCONN , METIS_OPTION_CONTIG , METIS_OPTION_SEED , METIS_OPTION_NUMBERING , METIS_OPTION_DBGLVL","tags":"","loc":"interface/metis_partgraphkway.html","title":"METIS_PartGraphKway – Fortran METIS Interface"},{"text":"interface Called By interface~~metis_partmeshdual~~CalledByGraph interface~metis_partmeshdual METIS_PartMeshDual proc~test4 test4 proc~test4->interface~metis_partmeshdual Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public function METIS_PartMeshDual(ne, nn, eptr, eind, vwgt, vsize, ncommon, nparts, tpwgts, options, objval, epart, npart) result(ierr) bind(C,name=\"METIS_PartMeshDual\") Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: ne The number of elements in the mesh. integer(kind=c_int), intent(in) :: nn The number of nodes in the mesh. integer(kind=c_int), intent(in), dimension(*) :: eptr The pair of arrays storing the mesh as described in Section 5.6 of the manual . integer(kind=c_int), intent(in), dimension(*) :: eind The pair of arrays storing the mesh as described in Section 5.6 of the manual . integer(kind=c_int), intent(in), optional :: vwgt (ne) An array of size ne specifying the weights of the elements. If not present,\n all elements have an equal weight. integer(kind=c_int), intent(in), optional :: vsize (ne) An array of size ne specifying the size of the elements that is used\n for computing the total comunication volume as described in Section 5.7 of the manual .\n If not present, the objective is cut or all elements have an equal size. integer(kind=c_int), intent(in) :: ncommon integer(kind=c_int), intent(in) :: nparts The number of parts to partition the mesh. integer(kind=c_int), intent(in), optional :: tpwgts (nparts) An array of size nparts that specifies the desired weight for each partition. The target\n partition weight for the i -th partition is specified at tpwgts(i) (the numbering for the \n partitions starts from 0). The sum of the tpwgts entries must be 1.0. If not present, the graph\n is divided equally among the partitions. integer(kind=c_int), intent(in), optional :: options (METIS_NOPTIONS) An array of options as described in Section 5.4 of the manual . See description for valid options. integer(kind=c_int), intent(out) :: objval Upon successful completion, this variable stores either the edgecut or the total communication\n volume of the dual graph's partitioning. integer(kind=c_int), intent(out) :: epart (ne) A vector of size ne that upon successful completion stores the partition vector for the elements\n of the mesh. The numbering of this vector starts from either 0 or 1, depending on the value of options(METIS_OPTION_NUMBERING) . integer(kind=c_int), intent(out) :: npart (nn) A vector of size nn that upon successful completion stores the partition vector for the nodes \n of the mesh. The numbering of this vector starts from either 0 or 1, depending on the value of options(METIS_OPTION_NUMBERING) . Return Value integer(kind=c_int) METIS_OK - Indicates that the function returned normally. METIS_ERROR_INPUT - Indicates an input error. METIS_ERROR_MEMORY - Indicates that it could not allocate the required memory. METIS_ERROR - Indicates some other type of error. Description This function is used to partition a mesh into nparts parts based on a partitioning of the mesh's dual graph. The following options are valid: METIS_OPTION_PTYPE , METIS_OPTION_OBJTYPE , METIS_OPTION_CTYPE , METIS_OPTION_IPTYPE , METIS_OPTION_RTYPE , METIS_OPTION_NCUTS , METIS_OPTION_NITER , METIS_OPTION_SEED , METIS_OPTION_UFACTOR , METIS_OPTION_NUMBERING , METIS_OPTION_DBGLVL","tags":"","loc":"interface/metis_partmeshdual.html","title":"METIS_PartMeshDual – Fortran METIS Interface"},{"text":"interface Called By interface~~metis_partmeshnodal~~CalledByGraph interface~metis_partmeshnodal METIS_PartMeshNodal proc~test1 test1 proc~test1->interface~metis_partmeshnodal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public function METIS_PartMeshNodal(ne, nn, eptr, eind, vwgt, vsize, nparts, tpwgts, options, objval, epart, npart) result(ierr) bind(C,name=\"METIS_PartMeshNodal\") Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: ne The number of elements in the mesh. integer(kind=c_int), intent(in) :: nn The number of nodes in the mesh. integer(kind=c_int), intent(in), dimension(*) :: eptr The pair of arrays storing the mesh as described in Section 5.6 of the manual . integer(kind=c_int), intent(in), dimension(*) :: eind The pair of arrays storing the mesh as described in Section 5.6 of the manual . integer(kind=c_int), intent(in), optional :: vwgt (nn) An array of size nn specifying weights of the nodes. If not passed, all nodes have an equal weight. integer(kind=c_int), intent(in), optional :: vsize (nn) An array of size nn specifying the size of the nodes that is used for computing the\n total comunication volume as described in Section 5.7 of the manual . If not passed,\n the objective is cut or all nodes have an equal size. integer(kind=c_int), intent(in) :: nparts The number of parts to partition the mesh. integer(kind=c_int), intent(in), optional :: tpwgts (nparts) An array of size nparts that specifies the desired weight for each partition. The target\n partition weight for the i -th partition is specified at tpwgts(i) (the numbering for the \n partitions starts from 0). The sum of the tpwgts entries must be 1.0. If not passed, the graph\n is divided equally among the partitions. integer(kind=c_int), intent(in), optional :: options (METIS_NOPTIONS) An array of options as described in Section 5.4 of the manual . See description for valid options. integer(kind=c_int), intent(out) :: objval Upon successful completion, this variable stores either the edgecut or the total communication\n volume of the nodal graph's partitioning. integer(kind=c_int), intent(out) :: epart (ne) A vector of size ne that upon successful completion stores the partition vector for the elements\n of the mesh. The numbering of this vector starts from either 0 or 1, depending on the value of options(METIS_OPTION_NUMBERING) . integer(kind=c_int), intent(out) :: npart (nn) A vector of size nn that upon successful completion stores the partition vector for the nodes \n of the mesh. The numbering of this vector starts from either 0 or 1, depending on the value of options(METIS_OPTION_NUMBERING) . Return Value integer(kind=c_int) METIS_OK - Indicates that the function returned normally. METIS_ERROR_INPUT - Indicates an input error. METIS_ERROR_MEMORY - Indicates that it could not allocate the required memory. METIS_ERROR - Indicates some other type of error. Description This function us used to partition a mesh into nparts parts based on a \n  partitioning of the mesh's nodal graph. The following options are valid: METIS_OPTION_PTYPE , METIS_OPTION_OBJTYPE , METIS_OPTION_CTYPE , METIS_OPTION_IPTYPE , METIS_OPTION_RTYPE , METIS_OPTION_NCUTS , METIS_OPTION_NITER , METIS_OPTION_SEED , METIS_OPTION_UFACTOR , METIS_OPTION_NUMBERING , METIS_OPTION_DBGLVL","tags":"","loc":"interface/metis_partmeshnodal.html","title":"METIS_PartMeshNodal – Fortran METIS Interface"},{"text":"interface Called By interface~~metis_nodend~~CalledByGraph interface~metis_nodend METIS_NodeND proc~test3 test3 proc~test3->interface~metis_nodend Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public function METIS_NodeND(nvtxs, xadj, adjncy, vwgt, options, perm, iperm) result(ierr) bind(C,name=\"METIS_NodeND\") Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: nvtxs The number of vertices in the graph. integer(kind=c_int), intent(in), dimension(*) :: xadj The adjacency structure of the graph as described in Section 5.5 of the manual . integer(kind=c_int), intent(in), dimension(*) :: adjncy The adjacency structure of the graph as described in Section 5.5 of the manual . integer(kind=c_int), intent(in), optional :: vwgt (nvtxs) An array of size nvtxs specifying the weights of the vertices. integer(kind=c_int), intent(in), optional :: options (METIS_NOPTIONS) This is the array of options as described in Section 5.4 of the manual . See description for valid options. integer(kind=c_int), intent(out) :: perm (nvtxs) Vectors of size nvtxs . Upon successful completion, they store the fill-reducing\n permutation and inverse-permutation. More in the description. integer(kind=c_int), intent(out) :: iperm (nvtxs) Vectors of size nvtxs . Upon successful completion, they store the fill-reducing\n permutation and inverse-permutation. More in the description. Return Value integer(kind=c_int) METIS_OK - Indicates that the function returned normally. METIS_ERROR_INPUT - Indicates an input error. METIS_ERROR_MEMORY - Indicates that it could not allocate the required memory. METIS_ERROR - Indicates some other type of error. Description This function computes fill reducing orderings of sparse matrices using the\n  multilevel nested dissection algorithm. Let A be the original matrix and A' be the permuted matrix. The arrays perm and iperm are defined as follows. Row (column) i of A' is the perm(i) row (column) of A, and row (column) i of A is the iperm(i) row (column) of A'. the numbering of this vector starts from either 0 or 1,\n  depending on the value of options(METIS_OPTION_NUMBERING) . If the graph is weighted, meaning vgwt was provided, the nested dissection ordering computes\n  vertex separators that minimize the sum of the weights of the vertices on the separators. The following options are valid: METIS_OPTION_CTYPE , METIS_OPTION_RTYPE , METIS_OPTION_NO2HOP , METIS_OPTION_NSEPS , METIS_OPTION_NITER , METIS_OPTION_UFACTOR , METIS_OPTION_COMPRESS , METIS_OPTION_CCORDER , METIS_OPTION_SEED , METIS_OPTION_PFACTOR , METIS_OPTION_NUMBERING , METIS_OPTION_DBGLVL Example The code below generates the nodal graph of the following mesh: integer ( c_int ), parameter :: n = 15 , m = 22 integer ( c_int ) :: xadj ( n + 1 ), adjncy ( 2 * m ) integer ( c_int ) :: perm ( n ), iperm ( n ) integer ( c_int ) :: options ( 0 : 39 ), ierr xadj = [ 1 , 3 , 6 , 9 , 12 , 14 , 17 , 21 , 25 , 29 , 32 , 34 , 37 , 40 , 43 , 45 ] adjncy = [ 2 , 6 , 1 , 3 , 7 , 2 , 4 , 8 , 3 , 5 , 9 , 4 , 10 , 1 , 7 , 11 , 2 , 6 , & 8 , 12 , 3 , 7 , 9 , 13 , 4 , 8 , 10 , 14 , 5 , 9 , 15 , 6 , 12 , 7 , 11 , 13 , & 8 , 12 , 14 , 9 , 13 , 15 , 10 , 14 ] ierr = METIS_SetDefaultOptions ( options ) options ( 18 ) = 1 ierr = METIS_NodeND ( n , xadj , adjncy , options = options , perm = perm , iperm = iperm ) end","tags":"","loc":"interface/metis_nodend.html","title":"METIS_NodeND – Fortran METIS Interface"},{"text":"interface public function METIS_MeshToDual(ne, nn, eptr, eind, ncommon, numflag, xadj, adjncy) result(ierr) bind(C,name=\"METIS_MeshToDual\") Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: ne The number of elements in the mesh. integer(kind=c_int), intent(in) :: nn The number of nodes in the mesh. integer(kind=c_int), intent(in), dimension(*) :: eptr The pair of arrays storing the mesh as described in Section 5.6 of the manual . integer(kind=c_int), intent(in), dimension(*) :: eind The pair of arrays storing the mesh as described in Section 5.6 of the manual . integer(kind=c_int), intent(in) :: ncommon The number of common nodes that two elements must have in order to put\n an edge between them in the dual graph. integer(kind=c_int), intent(in) :: numflag Used to indicate which numbering scheme is used for eptr and eind . \n The possible values are: 0 - C-style numbering is assumed that starts from 0 1 - Fortran-style numbering is assumed that starts from 1 type(c_ptr), intent(out) :: xadj These arrays store the adjacency structure of the generated dual graph. \n The format of the adjacency structure is described in Section 5.5 of the manual . type(c_ptr), intent(out) :: adjncy These arrays store the adjacency structure of the generated dual graph. \n The format of the adjacency structure is described in Section 5.5 of the manual . Return Value integer(kind=c_int) METIS_OK - Indicates that the function returned normally. METIS_ERROR_INPUT - Indicates an input error. METIS_ERROR_MEMORY - Indicates that it could not allocate the required memory. METIS_ERROR - Indicates some other type of error. Description This function is used to generate the dual graph of a mesh. Note To use the returned arrays xadj and adjncy , these must be first converted from\n a C pointer to a Fortran pointer using the subroutine c_f_pointer(cptr,fptr,shape) that assigns the target of the C pointer cptr to the Fortran pointer fptr and\n specifies its shape. The shape is an integer rank-one array, storing the size ne+1 in case of the dual graph. The size of the new adjncy array is stored in the \n last element of xadj when using C-style numbering. An example is shown below. Warning Memory for the returned arrays xadj and adjncy is allocated by METIS' API in C\n using the standard malloc function. It is the responsibility of the application to free\n this memory by calling free . Therefore, METIS provides the METIS_Free function that is a wrapper to\n C's free function. Example The code below generates the nodal graph of the following mesh: image use iso_c_binding , only : c_int , c_ptr , c_f_pointer integer ( c_int ), parameter :: ne = 3 , nn = 8 , npel = 4 integer ( c_int ) :: ierr , eptr ( ne + 1 ), eind ( ne * npel ), numflag , ncommon type ( c_ptr ) :: xadj , adjncy integer ( c_int ), dimension (:), pointer :: fxadj => null (), fadjncy => null () numflag = 0 ! C-style numbering ncommon = 2 ! 2 common nodes per edge eptr = [ 0 , 4 , 8 , 12 ] eind = [ 0 , 1 , 2 , 3 , 1 , 4 , 5 , 2 , 4 , 6 , 7 , 5 ] ! note four nodes per element ierr = METIS_MeshToDual ( ne , nn , eptr , eind , ncommon , numflag , xadj , adjncy ) call c_f_pointer ( xadj , fxadj , shape = [ ne + 1 ]) ! xadj is of the size ne+1 call c_f_pointer ( adjncy , fadjncy , shape = [ fxadj ( ne + 1 )]) ! last value in xadj is the size of adjncy !... use values in fxadj and fadjncy ... call METIS_Free ( xadj ) call METIS_Free ( adjncy ) end","tags":"","loc":"interface/metis_meshtodual.html","title":"METIS_MeshToDual – Fortran METIS Interface"},{"text":"interface Called By interface~~metis_meshtonodal~~CalledByGraph interface~metis_meshtonodal METIS_MeshToNodal proc~formetis_meshtonodal ForMETIS_MeshToNodal proc~formetis_meshtonodal->interface~metis_meshtonodal proc~test1 test1 proc~test1->interface~metis_meshtonodal proc~test1->proc~formetis_meshtonodal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public function METIS_MeshToNodal(ne, nn, eptr, eind, numflag, xadj, adjncy) result(ierr) bind(C,name=\"METIS_MeshToNodal\") Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: ne The number of elements in the mesh. integer(kind=c_int), intent(in) :: nn The number of nodes in the mesh. integer(kind=c_int), intent(in), dimension(*) :: eptr The pair of arrays storing the mesh as described in Section 5.6 of the manual . integer(kind=c_int), intent(in), dimension(*) :: eind The pair of arrays storing the mesh as described in Section 5.6 of the manual . integer(kind=c_int), intent(in) :: numflag Used to indicate which numbering scheme is used for eptr and eind .\n The possible values are: 0 - C-style numbering is assumed that starts from 0 1 - Fortran-style numbering is assumed that starts from 1 type(c_ptr), intent(out) :: xadj These arrays store the adjacency structure of the generated dual graph. \n The format of the adjacency structure is described in Section 5.5 of the manual . type(c_ptr), intent(out) :: adjncy These arrays store the adjacency structure of the generated dual graph. \n The format of the adjacency structure is described in Section 5.5 of the manual . Return Value integer(kind=c_int) METIS_OK - Indicates that the function returned normally. METIS_ERROR_INPUT - Indicates an input error. METIS_ERROR_MEMORY - Indicates that it could not allocate the required memory. METIS_ERROR - Indicates some other type of error. Description This function is used to generate the nodal graph of a mesh. Note To use the returned arrays xadj and adjncy , these must be first converted from\n a C pointer to a Fortran pointer using the subroutine c_f_pointer(cptr,fptr,shape) that assigns the target of the C pointer cptr to the Fortran pointer fptr and\n specifies its shape. The shape is an integer rank-one array, storing the size nn+1 in case of the nodal graph. The size of the new adjncy array is stored in the \n last element of xadj when using C-style numbering. An example is shown below. Warning Memory for the returned arrays xadj and adjncy is allocated by METIS' API in C\n using the standard malloc function. It is the responsibility of the application to free\n this memory by calling free . Therefore, METIS provides the METIS_Free function that is a wrapper to\n C's free function. Example The code below generates the nodal graph of the following mesh: image use iso_c_binding , only : c_int , c_ptr , c_f_pointer integer ( c_int ), parameter :: ne = 3 , nn = 8 , npel = 4 integer ( c_int ) :: ierr , eptr ( ne + 1 ), eind ( ne * npel ), numflag type ( c_ptr ) :: xadj , adjncy integer ( c_int ), dimension (:), pointer :: fxadj => null (), fadjncy => null () numflag = 0 ! C-style numbering eptr = [ 0 , 4 , 8 , 12 ] eind = [ 0 , 1 , 2 , 3 , 1 , 4 , 5 , 2 , 4 , 6 , 7 , 5 ] ! note four nodes per element ierr = METIS_MeshToNodal ( ne , nn , eptr , eind , numflag , xadj , adjncy ) call c_f_pointer ( xadj , fxadj , shape = [ nn + 1 ]) ! xadj is of the size nn+1 call c_f_pointer ( adjncy , fadjncy , shape = [ fxadj ( nn + 1 )]) ! last value in xadj is the size of adjncy !... use values in fxadj and fadjncy ... call METIS_Free ( xadj ) call METIS_Free ( adjncy ) end","tags":"","loc":"interface/metis_meshtonodal.html","title":"METIS_MeshToNodal – Fortran METIS Interface"},{"text":"interface Called By interface~~metis_setdefaultoptions~~CalledByGraph interface~metis_setdefaultoptions METIS_SetDefaultOptions proc~test1 test1 proc~test1->interface~metis_setdefaultoptions program~test_fmetis test_fmetis program~test_fmetis->interface~metis_setdefaultoptions proc~test3 test3 proc~test3->interface~metis_setdefaultoptions proc~test4 test4 proc~test4->interface~metis_setdefaultoptions Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public function METIS_SetDefaultOptions(options) result(ierr) bind(C,name=\"METIS_SetDefaultOptions\") Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(out) :: options (METIS_NOPTIONS) The array of options that will be initialized. Return Value integer(kind=c_int) METIS_OK - Indicates that the function returned normally. Description Initializes the options array into its default values. Note The passed array options must have the size METIS_NOPTIONS (40).\n To be able to use the parameters in the metis_enum module it is recommended to use\n zero-based indexing for the options array: integer ( c_int ) :: opts ( 0 : 39 ) Examples To set Fortran style index-numbering use: integer :: opts ( 0 : 39 ) call METIS_SetDefaultOptions ( opts ) opts ( 17 ) = 1 ! Fortran-style index numbering Other options can be changed using parameters from the metis_enum module. use metis_interface , only : METIS_SetDefaultOptions use metis_enum , only : METIS_OPTION_DBGLVL , METIS_DBG_INFO integer :: opts ( 0 : 39 ) call METIS_SetDefaultOptions ( opts ) opts ( METIS_OPTION_DBGLVL ) = METIS_DBG_INFO ! Show various diagnostic messages end","tags":"","loc":"interface/metis_setdefaultoptions.html","title":"METIS_SetDefaultOptions – Fortran METIS Interface"},{"text":"interface Called By interface~~metis_free~~CalledByGraph interface~metis_free METIS_Free proc~formetis_meshtonodal ForMETIS_MeshToNodal proc~formetis_meshtonodal->interface~metis_free proc~test1 test1 proc~test1->interface~metis_free proc~test1->proc~formetis_meshtonodal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public function METIS_Free(ptr) result(ierr) bind(C,name=\"METIS_Free\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: ptr The pointer to be freed. This pointer should be one of the xadj or adjncy arrays returned by METIS' API routines. Return Value integer(kind=c_int) METIS_OK - Indicates that the function returned normally. Description Frees the memory that was allocated by either the METIS_MeshToDual or the METIS_MeshToNodal routines for returning the dual or nodal graph of a mesh. Warning Memory deallocation should always happen on the same side it was allocated!\n Also check the descriptions of the above-mentioned routines. Example type ( c_ptr ) :: xadj (:), adjncy (:) call METIS_MeshToNodal (..., xadj , adjncy ) ! xadj and adjncy should be deallocated on the C side! ;) call METIS_Free ( xadj ) call METIS_Free ( adjncy )","tags":"","loc":"interface/metis_free.html","title":"METIS_Free – Fortran METIS Interface"},{"text":"interface public function ParMETIS_V3_PartKway(vtxdist, xadj, adjncy, vwgt, adjwgt, wgtflag, numflag, ncon, nparts, tpwgts, ubvec, options, edgecut, part, comm) result(ierr) bind(C,name=\"ParMETIS_V3_PartKway\") Arguments Type Intent Optional Attributes Name real :: vtxdist real :: xadj real :: adjncy real :: vwgt real :: adjwgt real :: wgtflag integer :: numflag integer :: ncon integer :: nparts real :: tpwgts real :: ubvec real :: options real :: edgecut real :: part real :: comm Return Value integer","tags":"","loc":"interface/parmetis_v3_partkway.html","title":"ParMETIS_V3_PartKway – Fortran METIS Interface"},{"text":"interface public function ParMETIS_V3_PartGeomKway(vtxdist, xadj, adjncy, vwgt, adjwgt, wgtflag, numflag, ndims, xyz, ncon, nparts, tpwgts, ubvec, options, edgecut, part, comm) result(ierr) bind(C,name=\"ParMETIS_V3_PartGeomKway\") Arguments Type Intent Optional Attributes Name real :: vtxdist real :: xadj real :: adjncy real :: vwgt real :: adjwgt real :: wgtflag integer :: numflag integer :: ndims real :: xyz integer :: ncon integer :: nparts real :: tpwgts real :: ubvec real :: options real :: edgecut real :: part real :: comm Return Value integer","tags":"","loc":"interface/parmetis_v3_partgeomkway.html","title":"ParMETIS_V3_PartGeomKway – Fortran METIS Interface"},{"text":"interface public function ParMETIS_V3_PartMeshKway(elmdist, eptr, eind, elmwgt, wgtflag, numflag, ncon, ncommon, nparts, tpwgts, ubvec, options, edgecut, part, comm) result(ierr) bind(C,name=\"ParMETIS_V3_PartMeshKway\") Arguments Type Intent Optional Attributes Name real :: elmdist real :: eptr real :: eind real :: elmwgt real :: wgtflag integer :: numflag integer :: ncon integer :: ncommon integer :: nparts real :: tpwgts real :: ubvec real :: options real :: edgecut real :: part real :: comm Return Value integer","tags":"","loc":"interface/parmetis_v3_partmeshkway.html","title":"ParMETIS_V3_PartMeshKway – Fortran METIS Interface"},{"text":"interface public function ParMETIS_V3_AdaptiveRepart(vtxdist, xadj, adjncy, vwgt, vsize, adjwgt, wgtflag, numflag, ncon, nparts, tpwgts, ubvec, itr, options, edgecut, part, comm) result(ierr) bind(C,name=\"ParMETIS_V3_AdaptiveRepart\") Arguments Type Intent Optional Attributes Name real :: vtxdist real :: xadj real :: adjncy real :: vwgt real :: vsize real :: adjwgt real :: wgtflag integer :: numflag integer :: ncon integer :: nparts real :: tpwgts real :: ubvec integer :: itr real :: options real :: edgecut real :: part real :: comm Return Value integer","tags":"","loc":"interface/parmetis_v3_adaptiverepart.html","title":"ParMETIS_V3_AdaptiveRepart – Fortran METIS Interface"},{"text":"interface public function ParMETIS_V32_NodeND(vtxdist, xadj, adjncy, vwgt, numflag, mtype, rtype, p_nseps, s_nseps, ubfrac, seed, dbglvl, order, sizes, comm) result(ierr) bind(C,name=\"ParMETIS_V32_NodeND\") Arguments Type Intent Optional Attributes Name real :: vtxdist real :: xadj real :: adjncy real :: vwgt integer :: numflag integer :: mtype real :: rtype real :: p_nseps real :: s_nseps real :: ubfrac real :: seed real :: dbglvl real :: order real :: sizes real :: comm Return Value integer","tags":"","loc":"interface/parmetis_v32_nodend.html","title":"ParMETIS_V32_NodeND – Fortran METIS Interface"},{"text":"interface public function ParMETIS_V32_Mesh2Dual(elmdist, eptr, eind, numflag, ncommon, xadj, adjncy, comm) result(ierr) bind(C,name=\"ParMETIS_V32_Mesh2Dual\") Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: elmdist integer(kind=c_int), intent(in) :: eptr real :: eind integer(kind=c_int), intent(in) :: numflag integer(kind=c_int), intent(in) :: ncommon type(c_ptr), intent(out) :: xadj type(c_ptr), intent(out) :: adjncy type(c_ptr), intent(in) :: comm Return Value integer","tags":"","loc":"interface/parmetis_v32_mesh2dual.html","title":"ParMETIS_V32_Mesh2Dual – Fortran METIS Interface"},{"text":"public function whitechar(char) Arguments Type Intent Optional Attributes Name character, intent(in) :: char Return Value logical Called By proc~~whitechar~~CalledByGraph proc~whitechar whitechar proc~count_columns count_columns proc~count_columns->proc~whitechar proc~load_graph load_graph proc~load_graph->proc~whitechar proc~load_graph->proc~count_columns program~test_fmetis test_fmetis program~test_fmetis->proc~load_graph Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/whitechar.html","title":"whitechar – Fortran METIS Interface"},{"text":"public function count_columns(unit, stat) result(ncol) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit integer, intent(out) :: stat Return Value integer Calls proc~~count_columns~~CallsGraph proc~count_columns count_columns proc~whitechar whitechar proc~count_columns->proc~whitechar Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~count_columns~~CalledByGraph proc~count_columns count_columns proc~load_graph load_graph proc~load_graph->proc~count_columns program~test_fmetis test_fmetis program~test_fmetis->proc~load_graph Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/count_columns.html","title":"count_columns – Fortran METIS Interface"},{"text":"public subroutine write_graph(fname, xadj, adjncy, numflag) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname integer, intent(in) :: xadj (:) integer, intent(in) :: adjncy (:) integer, intent(in) :: numflag Called By proc~~write_graph~~CalledByGraph proc~write_graph write_graph proc~test1 test1 proc~test1->proc~write_graph program~test_fmetis test_fmetis program~test_fmetis->proc~write_graph Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/write_graph.html","title":"write_graph – Fortran METIS Interface"},{"text":"public subroutine load_graph(this, fname, numflag) Arguments Type Intent Optional Attributes Name type( MetisGraph ), intent(out) :: this character(len=*), intent(in) :: fname integer, intent(in) :: numflag Calls proc~~load_graph~~CallsGraph proc~load_graph load_graph proc~whitechar whitechar proc~load_graph->proc~whitechar proc~count_columns count_columns proc~load_graph->proc~count_columns proc~count_columns->proc~whitechar Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~load_graph~~CalledByGraph proc~load_graph load_graph program~test_fmetis test_fmetis program~test_fmetis->proc~load_graph Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/load_graph.html","title":"load_graph – Fortran METIS Interface"},{"text":"public subroutine print_metis_options(opts, unit) Uses: iso_fortran_env proc~~print_metis_options~~UsesGraph proc~print_metis_options print_metis_options iso_fortran_env iso_fortran_env iso_fortran_env->proc~print_metis_options Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Arguments Type Intent Optional Attributes Name integer, intent(in) :: opts (0:) integer, intent(in), optional :: unit","tags":"","loc":"proc/print_metis_options.html","title":"print_metis_options – Fortran METIS Interface"},{"text":"public subroutine ForMETIS_MeshToNodal(ne, nn, eptr, eind, numflag, xadj, adjncy, stat) Uses: iso_c_binding proc~~formetis_meshtonodal~~UsesGraph proc~formetis_meshtonodal ForMETIS_MeshToNodal iso_c_binding iso_c_binding iso_c_binding->proc~formetis_meshtonodal Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Arguments Type Intent Optional Attributes Name integer, intent(in) :: ne integer, intent(in) :: nn integer, intent(in) :: eptr (ne+1) integer, intent(in) :: eind (:) integer, intent(in) :: numflag integer, intent(out), allocatable :: xadj (:) integer, intent(out), allocatable :: adjncy (:) integer, intent(out) :: stat Calls proc~~formetis_meshtonodal~~CallsGraph proc~formetis_meshtonodal ForMETIS_MeshToNodal interface~metis_meshtonodal METIS_MeshToNodal proc~formetis_meshtonodal->interface~metis_meshtonodal interface~metis_free METIS_Free proc~formetis_meshtonodal->interface~metis_free Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~formetis_meshtonodal~~CalledByGraph proc~formetis_meshtonodal ForMETIS_MeshToNodal proc~test1 test1 proc~test1->proc~formetis_meshtonodal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/formetis_meshtonodal.html","title":"ForMETIS_MeshToNodal – Fortran METIS Interface"},{"text":"public function whitechar(char) Arguments Type Intent Optional Attributes Name character, intent(in) :: char Return Value logical Called By proc~~whitechar~2~~CalledByGraph proc~whitechar~2 whitechar proc~count_columns~2 count_columns proc~count_columns~2->proc~whitechar~2 proc~read_graph read_graph proc~read_graph->proc~whitechar~2 proc~read_graph->proc~count_columns~2 proc~import_graph import_graph proc~import_graph->proc~read_graph Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/whitechar~2.html","title":"whitechar – Fortran METIS Interface"},{"text":"public function count_columns(unit, stat) result(ncol) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit integer, intent(out) :: stat Return Value integer Calls proc~~count_columns~2~~CallsGraph proc~count_columns~2 count_columns proc~whitechar~2 whitechar proc~count_columns~2->proc~whitechar~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~count_columns~2~~CalledByGraph proc~count_columns~2 count_columns proc~read_graph read_graph proc~read_graph->proc~count_columns~2 proc~import_graph import_graph proc~import_graph->proc~read_graph Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/count_columns~2.html","title":"count_columns – Fortran METIS Interface"},{"text":"public subroutine import_graph(fname, graph, numflag) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname class( graph_type ), intent(out) :: graph integer, intent(in), optional :: numflag Calls proc~~import_graph~~CallsGraph proc~import_graph import_graph proc~read_graph read_graph proc~import_graph->proc~read_graph proc~count_columns~2 count_columns proc~read_graph->proc~count_columns~2 proc~whitechar~2 whitechar proc~read_graph->proc~whitechar~2 proc~count_columns~2->proc~whitechar~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/import_graph.html","title":"import_graph – Fortran METIS Interface"},{"text":"public subroutine export_graph(fname, graph) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname class( graph_type ), intent(in) :: graph Calls proc~~export_graph~~CallsGraph proc~export_graph export_graph proc~write_graph~2 write_graph proc~export_graph->proc~write_graph~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/export_graph.html","title":"export_graph – Fortran METIS Interface"},{"text":"public subroutine write_graph(unit, xadj, adjncy, numflag, vwgt, adjwgt, vsize) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit integer, intent(in) :: xadj (:) integer, intent(in) :: adjncy (:) integer, intent(in), optional :: numflag integer, intent(in), optional :: vwgt (:) integer, intent(in), optional :: adjwgt (:) integer, intent(in), optional :: vsize (:) Called By proc~~write_graph~2~~CalledByGraph proc~write_graph~2 write_graph proc~export_graph export_graph proc~export_graph->proc~write_graph~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/write_graph~2.html","title":"write_graph – Fortran METIS Interface"},{"text":"public subroutine read_graph(unit, xadj, adjncy, numflag, vwgt, adjwgt, vsize) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit integer, intent(out), pointer :: xadj (:) integer, intent(out), pointer :: adjncy (:) integer, intent(in), optional :: numflag integer, optional pointer :: vwgt (:) integer, intent(out), optional pointer :: adjwgt (:) integer, intent(out), optional pointer :: vsize (:) Calls proc~~read_graph~~CallsGraph proc~read_graph read_graph proc~count_columns~2 count_columns proc~read_graph->proc~count_columns~2 proc~whitechar~2 whitechar proc~read_graph->proc~whitechar~2 proc~count_columns~2->proc~whitechar~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~read_graph~~CalledByGraph proc~read_graph read_graph proc~import_graph import_graph proc~import_graph->proc~read_graph Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/read_graph.html","title":"read_graph – Fortran METIS Interface"},{"text":"public subroutine test1() Uses: iso_c_binding proc~~test1~~UsesGraph proc~test1 test1 iso_c_binding iso_c_binding iso_c_binding->proc~test1 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Arguments None Calls proc~~test1~~CallsGraph proc~test1 test1 interface~metis_setdefaultoptions METIS_SetDefaultOptions proc~test1->interface~metis_setdefaultoptions interface~metis_partmeshnodal METIS_PartMeshNodal proc~test1->interface~metis_partmeshnodal interface~metis_meshtonodal METIS_MeshToNodal proc~test1->interface~metis_meshtonodal proc~write_graph write_graph proc~test1->proc~write_graph proc~formetis_meshtonodal ForMETIS_MeshToNodal proc~test1->proc~formetis_meshtonodal interface~metis_free METIS_Free proc~test1->interface~metis_free proc~formetis_meshtonodal->interface~metis_meshtonodal proc~formetis_meshtonodal->interface~metis_free Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/test1.html","title":"test1 – Fortran METIS Interface"},{"text":"public subroutine test2() Uses: iso_c_binding proc~~test2~~UsesGraph proc~test2 test2 iso_c_binding iso_c_binding iso_c_binding->proc~test2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Arguments None Calls proc~~test2~~CallsGraph proc~test2 test2 interface~metis_partgraphrecursive METIS_PartGraphRecursive proc~test2->interface~metis_partgraphrecursive Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/test2.html","title":"test2 – Fortran METIS Interface"},{"text":"public subroutine test3() Arguments None Calls proc~~test3~~CallsGraph proc~test3 test3 interface~metis_setdefaultoptions METIS_SetDefaultOptions proc~test3->interface~metis_setdefaultoptions interface~metis_nodend METIS_NodeND proc~test3->interface~metis_nodend Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/test3.html","title":"test3 – Fortran METIS Interface"},{"text":"public subroutine test4() Arguments None Calls proc~~test4~~CallsGraph proc~test4 test4 interface~metis_setdefaultoptions METIS_SetDefaultOptions proc~test4->interface~metis_setdefaultoptions interface~metis_partmeshdual METIS_PartMeshDual proc~test4->interface~metis_partmeshdual print_options print_options proc~test4->print_options Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/test4.html","title":"test4 – Fortran METIS Interface"},{"text":"Uses: iso_c_binding module~~metis_interface~~UsesGraph module~metis_interface metis_interface iso_c_binding iso_c_binding iso_c_binding->module~metis_interface Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. A Fortran interface to the METIS graph partitioning library. Used By module~~metis_interface~~UsedByGraph module~metis_interface metis_interface module~metis_tests metis_tests module~metis_interface->module~metis_tests program~test_partgraphrecursive2 test_PartGraphRecursive2 module~metis_interface->program~test_partgraphrecursive2 program~test_partmeshnodal1 test_PartMeshNodal1 module~metis_interface->program~test_partmeshnodal1 program~test_partgraphrecursive1 test_PartGraphRecursive1 module~metis_interface->program~test_partgraphrecursive1 program~test_nodend test_NodeND module~metis_interface->program~test_nodend module~metis_io metis_io module~metis_interface->module~metis_io program~test_partmeshnodal2 test_PartMeshNodal2 module~metis_interface->program~test_partmeshnodal2 module~metis_oo_interface metis_oo_interface module~metis_interface->module~metis_oo_interface program~test_partgraphkway test_PartGraphKway module~metis_interface->program~test_partgraphkway program~test_fmetis test_fmetis module~metis_interface->program~test_fmetis module~metis_io->module~metis_tests module~metis_io->program~test_fmetis Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables METIS_NOPTIONS Interfaces METIS_PartGraphRecursive METIS_PartGraphKway METIS_PartMeshDual METIS_PartMeshNodal METIS_NodeND METIS_MeshToDual METIS_MeshToNodal METIS_SetDefaultOptions METIS_Free Variables Type Visibility Attributes Name Initial integer, public, parameter :: METIS_NOPTIONS = 40 Number of METIS options. Interfaces interface public function METIS_PartGraphRecursive (nvtxs, ncon, xadj, adjncy, vwgt, vsize, adjwgt, nparts, tpwgts, ubvec, options, objval, part) result(ierr) bind(C,name=\"METIS_PartGraphRecursive\") This function is used to partition a graph into nparts parts using recursive bisection. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: nvtxs The number of vertices in the graph. integer(kind=c_int), intent(in) :: ncon The number of balancing constraints. It should be atleast 1. integer(kind=c_int), intent(in), dimension(*) :: xadj The adjacency structure of the graph as described in section 5.5 of the manual . integer(kind=c_int), intent(in), dimension(*) :: adjncy The adjacency structure of the graph as described in section 5.5 of the manual . integer(kind=c_int), intent(in), optional dimension(*) :: vwgt The weights of the vertices as described in Section 5.5 of the manual . integer(kind=c_int), intent(in), optional dimension(*) :: vsize The size of the vertices for computing the total communication volume as described in section 5.7 of the manual . integer(kind=c_int), intent(in), optional dimension(*) :: adjwgt The weights of the edges as describe in Section 5.5 of the manual . integer(kind=c_int), intent(in) :: nparts The number of parts to partition the graph. real(kind=c_double), intent(in), optional :: tpwgts (nparts*ncon) An array of size nparts*ncon that specifies the desired weight for each partition and constraint.\n If not present, the graph is divided equally among the partitions. More in the description. real(kind=c_double), intent(in), optional :: ubvec (ncon) An array of size ncon that specifies the allowed load imbalance for each constraint. \n For the i -th partition and j -th constraint the allowed weight is the ubvec(j)*tpwgts(i*ncon+j) fraction of the j -th's constraint total weight. If not present, the load imbalance\n tolerance is 1.001 (for ncon = 1 ) or 1.01 (for ncon > 1 ). integer(kind=c_int), intent(in), optional :: options (METIS_NOPTIONS) An array of options as described in Section 5.4 of the METIS manual. See description for valid options. integer(kind=c_int), intent(out) :: objval Upon successful completion, this variable stores the edge-cut or the total communication volume of the partitioning\n solution. The value returned depends on the partitioning's objective function. integer(kind=c_int), intent(out) :: part (nvtxs) This is a vector of size nvtxs that upon successful completion stores the partition vector of the graph.\n The numbering of this vector starts from either 0 or 1, depending on the value of options(METIS_OPTION_NUMBERING) . Return Value integer(kind=c_int) METIS_OK - Indicates that the function returned normally. METIS_ERROR_INPUT - Indicates an input error. METIS_ERROR_MEMORY - Indicates that it could not allocate the required memory. METIS_ERROR - Indicates some other type of error. interface public function METIS_PartGraphKway (nvtxs, ncon, xadj, adjncy, vwgt, vsize, adjwgt, nparts, tpwgts, ubvec, options, objval, part) result(ierr) bind(C,name=\"METIS_PartGraphKway\") This function is used to partition a graph into nparts parts using multilevel k-way partitioning. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: nvtxs The number of vertices in the graph. integer(kind=c_int), intent(in) :: ncon The number of balancing constraints. It should be at least 1. integer(kind=c_int), intent(in), dimension(*) :: xadj The adjacency structure of the graph as described in section 5.5 of the manual . integer(kind=c_int), intent(in), dimension(*) :: adjncy The adjacency structure of the graph as described in section 5.5 of the manual . integer(kind=c_int), intent(in), optional dimension(*) :: vwgt The weights of the vertices as described in Section 5.5 of the manual . integer(kind=c_int), intent(in), optional dimension(*) :: vsize The size of the vertices for computing the total communication volume as described in section 5.7 of the manual . integer(kind=c_int), intent(in), optional dimension(*) :: adjwgt The weights of the edges as describe in Section 5.5 of the manual . integer(kind=c_int), intent(in) :: nparts The number of parts to partition the graph. real(kind=c_double), intent(in), optional :: tpwgts (nparts*ncon) An array of size nparts*ncon that specifies the desired weight for each partition and constraint.\n If not present, the graph is divided equally among the partitions. More in the description. real(kind=c_double), intent(in), optional :: ubvec (ncon) An array of size ncon that specifiew the allowed load imbalance for each constraint. \n For the i -th partition and j -th constraint the allowed weight is the ubvec(j)*tpwgts(i*ncon+j) fraction of the j -th's constraint total weight. If not present, the load imbalance\n tolerance is 1.001 (for ncon == 1 ) or 1.01 (for ncon > 1 ). integer(kind=c_int), intent(in), optional :: options (METIS_NOPTIONS) An array of options as described in Section 5.4 of the manual . See description for valid options. integer(kind=c_int), intent(out) :: objval Upon successful completion, this variable stores the edge-cut or the total communication volume of the partitioning\n solution. The value returned depends on the partitioning's objective function. integer(kind=c_int), intent(out) :: part (nvtxs) This is a vector of size nvtxs that upon successful completion stores the partition vector of the graph.\n The numbering of this vector starts from either 0 or 1, depending on the value of options(METIS_OPTION_NUMBERING) . Return Value integer(kind=c_int) METIS_OK - Indicates that the function returned normally. METIS_ERROR_INPUT - Indicates an input error. METIS_ERROR_MEMORY - Indicates that it could not allocate the required memory. METIS_ERROR - Indicates some other type of error. interface public function METIS_PartMeshDual (ne, nn, eptr, eind, vwgt, vsize, ncommon, nparts, tpwgts, options, objval, epart, npart) result(ierr) bind(C,name=\"METIS_PartMeshDual\") This function is used to partition a mesh into nparts parts based on a partitioning of the mesh's dual graph. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: ne The number of elements in the mesh. integer(kind=c_int), intent(in) :: nn The number of nodes in the mesh. integer(kind=c_int), intent(in), dimension(*) :: eptr The pair of arrays storing the mesh as described in Section 5.6 of the manual . integer(kind=c_int), intent(in), dimension(*) :: eind The pair of arrays storing the mesh as described in Section 5.6 of the manual . integer(kind=c_int), intent(in), optional :: vwgt (ne) An array of size ne specifying the weights of the elements. If not present,\n all elements have an equal weight. integer(kind=c_int), intent(in), optional :: vsize (ne) An array of size ne specifying the size of the elements that is used\n for computing the total comunication volume as described in Section 5.7 of the manual .\n If not present, the objective is cut or all elements have an equal size. integer(kind=c_int), intent(in) :: ncommon integer(kind=c_int), intent(in) :: nparts The number of parts to partition the mesh. integer(kind=c_int), intent(in), optional :: tpwgts (nparts) An array of size nparts that specifies the desired weight for each partition. The target\n partition weight for the i -th partition is specified at tpwgts(i) (the numbering for the \n partitions starts from 0). The sum of the tpwgts entries must be 1.0. If not present, the graph\n is divided equally among the partitions. integer(kind=c_int), intent(in), optional :: options (METIS_NOPTIONS) An array of options as described in Section 5.4 of the manual . See description for valid options. integer(kind=c_int), intent(out) :: objval Upon successful completion, this variable stores either the edgecut or the total communication\n volume of the dual graph's partitioning. integer(kind=c_int), intent(out) :: epart (ne) A vector of size ne that upon successful completion stores the partition vector for the elements\n of the mesh. The numbering of this vector starts from either 0 or 1, depending on the value of options(METIS_OPTION_NUMBERING) . integer(kind=c_int), intent(out) :: npart (nn) A vector of size nn that upon successful completion stores the partition vector for the nodes \n of the mesh. The numbering of this vector starts from either 0 or 1, depending on the value of options(METIS_OPTION_NUMBERING) . Return Value integer(kind=c_int) METIS_OK - Indicates that the function returned normally. METIS_ERROR_INPUT - Indicates an input error. METIS_ERROR_MEMORY - Indicates that it could not allocate the required memory. METIS_ERROR - Indicates some other type of error. interface public function METIS_PartMeshNodal (ne, nn, eptr, eind, vwgt, vsize, nparts, tpwgts, options, objval, epart, npart) result(ierr) bind(C,name=\"METIS_PartMeshNodal\") This function us used to partition a mesh into nparts parts based on a \n  partitioning of the mesh's nodal graph. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: ne The number of elements in the mesh. integer(kind=c_int), intent(in) :: nn The number of nodes in the mesh. integer(kind=c_int), intent(in), dimension(*) :: eptr The pair of arrays storing the mesh as described in Section 5.6 of the manual . integer(kind=c_int), intent(in), dimension(*) :: eind The pair of arrays storing the mesh as described in Section 5.6 of the manual . integer(kind=c_int), intent(in), optional :: vwgt (nn) An array of size nn specifying weights of the nodes. If not passed, all nodes have an equal weight. integer(kind=c_int), intent(in), optional :: vsize (nn) An array of size nn specifying the size of the nodes that is used for computing the\n total comunication volume as described in Section 5.7 of the manual . If not passed,\n the objective is cut or all nodes have an equal size. integer(kind=c_int), intent(in) :: nparts The number of parts to partition the mesh. integer(kind=c_int), intent(in), optional :: tpwgts (nparts) An array of size nparts that specifies the desired weight for each partition. The target\n partition weight for the i -th partition is specified at tpwgts(i) (the numbering for the \n partitions starts from 0). The sum of the tpwgts entries must be 1.0. If not passed, the graph\n is divided equally among the partitions. integer(kind=c_int), intent(in), optional :: options (METIS_NOPTIONS) An array of options as described in Section 5.4 of the manual . See description for valid options. integer(kind=c_int), intent(out) :: objval Upon successful completion, this variable stores either the edgecut or the total communication\n volume of the nodal graph's partitioning. integer(kind=c_int), intent(out) :: epart (ne) A vector of size ne that upon successful completion stores the partition vector for the elements\n of the mesh. The numbering of this vector starts from either 0 or 1, depending on the value of options(METIS_OPTION_NUMBERING) . integer(kind=c_int), intent(out) :: npart (nn) A vector of size nn that upon successful completion stores the partition vector for the nodes \n of the mesh. The numbering of this vector starts from either 0 or 1, depending on the value of options(METIS_OPTION_NUMBERING) . Return Value integer(kind=c_int) METIS_OK - Indicates that the function returned normally. METIS_ERROR_INPUT - Indicates an input error. METIS_ERROR_MEMORY - Indicates that it could not allocate the required memory. METIS_ERROR - Indicates some other type of error. interface public function METIS_NodeND (nvtxs, xadj, adjncy, vwgt, options, perm, iperm) result(ierr) bind(C,name=\"METIS_NodeND\") This function computes fill reducing orderings of sparse matrices using the\n  multilevel nested dissection algorithm. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: nvtxs The number of vertices in the graph. integer(kind=c_int), intent(in), dimension(*) :: xadj The adjacency structure of the graph as described in Section 5.5 of the manual . integer(kind=c_int), intent(in), dimension(*) :: adjncy The adjacency structure of the graph as described in Section 5.5 of the manual . integer(kind=c_int), intent(in), optional :: vwgt (nvtxs) An array of size nvtxs specifying the weights of the vertices. integer(kind=c_int), intent(in), optional :: options (METIS_NOPTIONS) This is the array of options as described in Section 5.4 of the manual . See description for valid options. integer(kind=c_int), intent(out) :: perm (nvtxs) Vectors of size nvtxs . Upon successful completion, they store the fill-reducing\n permutation and inverse-permutation. More in the description. integer(kind=c_int), intent(out) :: iperm (nvtxs) Vectors of size nvtxs . Upon successful completion, they store the fill-reducing\n permutation and inverse-permutation. More in the description. Return Value integer(kind=c_int) METIS_OK - Indicates that the function returned normally. METIS_ERROR_INPUT - Indicates an input error. METIS_ERROR_MEMORY - Indicates that it could not allocate the required memory. METIS_ERROR - Indicates some other type of error. interface public function METIS_MeshToDual (ne, nn, eptr, eind, ncommon, numflag, xadj, adjncy) result(ierr) bind(C,name=\"METIS_MeshToDual\") This function is used to generate the dual graph of a mesh. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: ne The number of elements in the mesh. integer(kind=c_int), intent(in) :: nn The number of nodes in the mesh. integer(kind=c_int), intent(in), dimension(*) :: eptr The pair of arrays storing the mesh as described in Section 5.6 of the manual . integer(kind=c_int), intent(in), dimension(*) :: eind The pair of arrays storing the mesh as described in Section 5.6 of the manual . integer(kind=c_int), intent(in) :: ncommon The number of common nodes that two elements must have in order to put\n an edge between them in the dual graph. integer(kind=c_int), intent(in) :: numflag Used to indicate which numbering scheme is used for eptr and eind . \n The possible values are: 0 - C-style numbering is assumed that starts from 0 1 - Fortran-style numbering is assumed that starts from 1 type(c_ptr), intent(out) :: xadj These arrays store the adjacency structure of the generated dual graph. \n The format of the adjacency structure is described in Section 5.5 of the manual . type(c_ptr), intent(out) :: adjncy These arrays store the adjacency structure of the generated dual graph. \n The format of the adjacency structure is described in Section 5.5 of the manual . Return Value integer(kind=c_int) METIS_OK - Indicates that the function returned normally. METIS_ERROR_INPUT - Indicates an input error. METIS_ERROR_MEMORY - Indicates that it could not allocate the required memory. METIS_ERROR - Indicates some other type of error. interface public function METIS_MeshToNodal (ne, nn, eptr, eind, numflag, xadj, adjncy) result(ierr) bind(C,name=\"METIS_MeshToNodal\") This function is used to generate the nodal graph of a mesh. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: ne The number of elements in the mesh. integer(kind=c_int), intent(in) :: nn The number of nodes in the mesh. integer(kind=c_int), intent(in), dimension(*) :: eptr The pair of arrays storing the mesh as described in Section 5.6 of the manual . integer(kind=c_int), intent(in), dimension(*) :: eind The pair of arrays storing the mesh as described in Section 5.6 of the manual . integer(kind=c_int), intent(in) :: numflag Used to indicate which numbering scheme is used for eptr and eind .\n The possible values are: 0 - C-style numbering is assumed that starts from 0 1 - Fortran-style numbering is assumed that starts from 1 type(c_ptr), intent(out) :: xadj These arrays store the adjacency structure of the generated dual graph. \n The format of the adjacency structure is described in Section 5.5 of the manual . type(c_ptr), intent(out) :: adjncy These arrays store the adjacency structure of the generated dual graph. \n The format of the adjacency structure is described in Section 5.5 of the manual . Return Value integer(kind=c_int) METIS_OK - Indicates that the function returned normally. METIS_ERROR_INPUT - Indicates an input error. METIS_ERROR_MEMORY - Indicates that it could not allocate the required memory. METIS_ERROR - Indicates some other type of error. interface public function METIS_SetDefaultOptions (options) result(ierr) bind(C,name=\"METIS_SetDefaultOptions\") Initializes the options array into its default values. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(out) :: options (METIS_NOPTIONS) The array of options that will be initialized. Return Value integer(kind=c_int) METIS_OK - Indicates that the function returned normally. interface public function METIS_Free (ptr) result(ierr) bind(C,name=\"METIS_Free\") Frees the memory that was allocated by either the METIS_MeshToDual or the METIS_MeshToNodal routines for returning the dual or nodal graph of a mesh. Arguments Type Intent Optional Attributes Name type(c_ptr), value :: ptr The pointer to be freed. This pointer should be one of the xadj or adjncy arrays returned by METIS' API routines. Return Value integer(kind=c_int) METIS_OK - Indicates that the function returned normally.","tags":"","loc":"module/metis_interface.html","title":"metis_interface – Fortran METIS Interface"},{"text":"Interfaces ParMETIS_V3_PartKway ParMETIS_V3_PartGeomKway ParMETIS_V3_PartMeshKway ParMETIS_V3_AdaptiveRepart ParMETIS_V32_NodeND ParMETIS_V32_Mesh2Dual Interfaces interface public function ParMETIS_V3_PartKway (vtxdist, xadj, adjncy, vwgt, adjwgt, wgtflag, numflag, ncon, nparts, tpwgts, ubvec, options, edgecut, part, comm) result(ierr) bind(C,name=\"ParMETIS_V3_PartKway\") Arguments Type Intent Optional Attributes Name real :: vtxdist real :: xadj real :: adjncy real :: vwgt real :: adjwgt real :: wgtflag integer :: numflag integer :: ncon integer :: nparts real :: tpwgts real :: ubvec real :: options real :: edgecut real :: part real :: comm Return Value integer interface public function ParMETIS_V3_PartGeomKway (vtxdist, xadj, adjncy, vwgt, adjwgt, wgtflag, numflag, ndims, xyz, ncon, nparts, tpwgts, ubvec, options, edgecut, part, comm) result(ierr) bind(C,name=\"ParMETIS_V3_PartGeomKway\") Arguments Type Intent Optional Attributes Name real :: vtxdist real :: xadj real :: adjncy real :: vwgt real :: adjwgt real :: wgtflag integer :: numflag integer :: ndims real :: xyz integer :: ncon integer :: nparts real :: tpwgts real :: ubvec real :: options real :: edgecut real :: part real :: comm Return Value integer interface public function ParMETIS_V3_PartMeshKway (elmdist, eptr, eind, elmwgt, wgtflag, numflag, ncon, ncommon, nparts, tpwgts, ubvec, options, edgecut, part, comm) result(ierr) bind(C,name=\"ParMETIS_V3_PartMeshKway\") Arguments Type Intent Optional Attributes Name real :: elmdist real :: eptr real :: eind real :: elmwgt real :: wgtflag integer :: numflag integer :: ncon integer :: ncommon integer :: nparts real :: tpwgts real :: ubvec real :: options real :: edgecut real :: part real :: comm Return Value integer interface public function ParMETIS_V3_AdaptiveRepart (vtxdist, xadj, adjncy, vwgt, vsize, adjwgt, wgtflag, numflag, ncon, nparts, tpwgts, ubvec, itr, options, edgecut, part, comm) result(ierr) bind(C,name=\"ParMETIS_V3_AdaptiveRepart\") Arguments Type Intent Optional Attributes Name real :: vtxdist real :: xadj real :: adjncy real :: vwgt real :: vsize real :: adjwgt real :: wgtflag integer :: numflag integer :: ncon integer :: nparts real :: tpwgts real :: ubvec integer :: itr real :: options real :: edgecut real :: part real :: comm Return Value integer interface public function ParMETIS_V32_NodeND (vtxdist, xadj, adjncy, vwgt, numflag, mtype, rtype, p_nseps, s_nseps, ubfrac, seed, dbglvl, order, sizes, comm) result(ierr) bind(C,name=\"ParMETIS_V32_NodeND\") Arguments Type Intent Optional Attributes Name real :: vtxdist real :: xadj real :: adjncy real :: vwgt integer :: numflag integer :: mtype real :: rtype real :: p_nseps real :: s_nseps real :: ubfrac real :: seed real :: dbglvl real :: order real :: sizes real :: comm Return Value integer interface public function ParMETIS_V32_Mesh2Dual (elmdist, eptr, eind, numflag, ncommon, xadj, adjncy, comm) result(ierr) bind(C,name=\"ParMETIS_V32_Mesh2Dual\") Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: elmdist integer(kind=c_int), intent(in) :: eptr real :: eind integer(kind=c_int), intent(in) :: numflag integer(kind=c_int), intent(in) :: ncommon type(c_ptr), intent(out) :: xadj type(c_ptr), intent(out) :: adjncy type(c_ptr), intent(in) :: comm Return Value integer","tags":"","loc":"module/parmetis_interface.html","title":"parmetis_interface – Fortran METIS Interface"},{"text":"Used By module~~metis_enum~~UsedByGraph module~metis_enum metis_enum program~test_partgraphrecursive2 test_PartGraphRecursive2 module~metis_enum->program~test_partgraphrecursive2 program~test_partmeshnodal1 test_PartMeshNodal1 module~metis_enum->program~test_partmeshnodal1 program~test_partgraphrecursive1 test_PartGraphRecursive1 module~metis_enum->program~test_partgraphrecursive1 program~test_nodend test_NodeND module~metis_enum->program~test_nodend module~metis_io metis_io module~metis_enum->module~metis_io program~test_partmeshnodal2 test_PartMeshNodal2 module~metis_enum->program~test_partmeshnodal2 module~metis_oo_interface metis_oo_interface module~metis_enum->module~metis_oo_interface program~test_partgraphkway test_PartGraphKway module~metis_enum->program~test_partgraphkway program~test_fmetis test_fmetis module~metis_enum->program~test_fmetis module~metis_io->program~test_fmetis module~metis_tests metis_tests module~metis_io->module~metis_tests Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables METIS_OK METIS_ERROR_INPUT METIS_ERROR_MEMORY METIS_ERROR METIS_OPTION_PTYPE METIS_OPTION_OBJTYPE METIS_OPTION_CTYPE METIS_OPTION_IPTYPE METIS_OPTION_RTYPE METIS_OPTION_DBGLVL METIS_OPTION_NITER METIS_OPTION_NCUTS METIS_OPTION_SEED METIS_OPTION_NO2HOP METIS_OPTION_MINCONN METIS_OPTION_CONTIG METIS_OPTION_COMPRESS METIS_OPTION_CCORDER METIS_OPTION_PFACTOR METIS_OPTION_NSEPS METIS_OPTION_UFACTOR METIS_OPTION_NUMBERING METIS_PTYPE_RB METIS_PTYPE_KWAY METIS_CTYPE_RM METIS_CTYPE_SHEM METIS_IPTYPE_GROW METIS_IPTYPE_RANDOM METIS_IPTYPE_EDGE METIS_IPTYPE_NODE METIS_IPTYPE_METISRB METIS_RTYPE_FM METIS_RTYPE_GREEDY METIS_RTYPE_SEP2SIDED METIS_RTYPE_SEP1SIDED METIS_DBG_INFO METIS_DBG_TIME METIS_DBG_COARSEN METIS_DBG_REFINE METIS_DBG_IPART METIS_DBG_MOVEINFO METIS_DBG_SEPINFO METIS_DBG_CONNINFO METIS_DBG_CONTIGINFO METIS_DBG_MEMORY METIS_OBJTYPE_CUT METIS_OBJTYPE_VOL METIS_OBJTYPE_NODE Variables Type Visibility Attributes Name Initial integer, public, parameter :: METIS_OK = 1 Returned normally. integer, public, parameter :: METIS_ERROR_INPUT = -2 Returned due to erroneous inputs and/or options. integer, public, parameter :: METIS_ERROR_MEMORY = -3 Returned due to insufficient memory. integer, public, parameter :: METIS_ERROR = -4 Return status: some other type of error. integer, public, parameter :: METIS_OPTION_PTYPE = 0 Specifies the partitioning method. integer, public, parameter :: METIS_OPTION_OBJTYPE = 1 Specifies the type of objective. integer, public, parameter :: METIS_OPTION_CTYPE = 2 Specifies the matching scheme to be used during coarsening. integer, public, parameter :: METIS_OPTION_IPTYPE = 3 Determines the algorithm used during initial partitioning. integer, public, parameter :: METIS_OPTION_RTYPE = 4 Determines the algorithm used for refinement. integer, public, parameter :: METIS_OPTION_DBGLVL = 5 Specifies the amount of progress/debugging information will be printed. integer, public, parameter :: METIS_OPTION_NITER = 6 Specifies the number of iterations for the refinement algorithm. integer, public, parameter :: METIS_OPTION_NCUTS = 7 Specifies the number of different partitionings that it will compute. integer, public, parameter :: METIS_OPTION_SEED = 8 Specifies the seed for the random number generator. integer, public, parameter :: METIS_OPTION_NO2HOP = 9 Specifies that the coarsening will not perform any 2–hop matchings when the standard matching approach fails to sufficiently coarsen the graph. integer, public, parameter :: METIS_OPTION_MINCONN = 10 Specifies that the partitioning routines should try to minimize the maximum degree of the subdomain graph. integer, public, parameter :: METIS_OPTION_CONTIG = 11 Specifies that the partitioning routines should try to produce partitions that are contigous. integer, public, parameter :: METIS_OPTION_COMPRESS = 12 Specifies that the graph should be compressed by combining together vertices that have identical adjacency lists. integer, public, parameter :: METIS_OPTION_CCORDER = 13 Specifies if the connected components of the graph should first be identifies and ordered separately. integer, public, parameter :: METIS_OPTION_PFACTOR = 14 Specifies the minimum degree of the vertices that will be ordered last. integer, public, parameter :: METIS_OPTION_NSEPS = 15 Specifies the number of different separators that it will compute at each level of nested dissection. integer, public, parameter :: METIS_OPTION_UFACTOR = 16 Specifies the maximum allowed load imbalance among the partitions. integer, public, parameter :: METIS_OPTION_NUMBERING = 17 Used to indicate which numbering scheme is used for the adjacency structure of a graph or the element-node structure of a mesh integer, public, parameter :: METIS_PTYPE_RB = 0 Multilevel recursive bisectioning. integer, public, parameter :: METIS_PTYPE_KWAY = 1 Multilevel k-way partitioning. integer, public, parameter :: METIS_CTYPE_RM = 0 Random matching. integer, public, parameter :: METIS_CTYPE_SHEM = 1 Sorted heavy-edge matching. integer, public, parameter :: METIS_IPTYPE_GROW = 0 Grows a bisection using a greedy strategy. integer, public, parameter :: METIS_IPTYPE_RANDOM = 1 Computes a bisection at random followed by a refinement. integer, public, parameter :: METIS_IPTYPE_EDGE = 2 Derives a separator form an edge cut. integer, public, parameter :: METIS_IPTYPE_NODE = 3 Grows a bisection using a greedy node-based strategy. integer, public, parameter :: METIS_IPTYPE_METISRB = 4 integer, public, parameter :: METIS_RTYPE_FM = 0 FM-based cut refinement. integer, public, parameter :: METIS_RTYPE_GREEDY = 1 Greedy-based cut and volume refinement. integer, public, parameter :: METIS_RTYPE_SEP2SIDED = 2 Two-sided node FM refinement. integer, public, parameter :: METIS_RTYPE_SEP1SIDED = 3 One-sided node FM refinement. integer, public, parameter :: METIS_DBG_INFO = 1 Shows various diagnostic messages. integer, public, parameter :: METIS_DBG_TIME = 2 Perform timing analysis. integer, public, parameter :: METIS_DBG_COARSEN = 4 Show the coarsening progress. integer, public, parameter :: METIS_DBG_REFINE = 8 Show the refinement progress. integer, public, parameter :: METIS_DBG_IPART = 16 Show info on initial partitioning. integer, public, parameter :: METIS_DBG_MOVEINFO = 32 Show info on vertex moves during refinement. integer, public, parameter :: METIS_DBG_SEPINFO = 64 Show info on vertex moves during sep refinement. integer, public, parameter :: METIS_DBG_CONNINFO = 128 Show info on minimization of subdomain connectivity. integer, public, parameter :: METIS_DBG_CONTIGINFO = 256 Show info on elimination of connected components. integer, public, parameter :: METIS_DBG_MEMORY = 2048 Show info related to wspace allocation. integer, public, parameter :: METIS_OBJTYPE_CUT = 0 Edge-cut minimization. integer, public, parameter :: METIS_OBJTYPE_VOL = 1 Total communication volume minimization. integer, public, parameter :: METIS_OBJTYPE_NODE = 2","tags":"","loc":"module/metis_enum.html","title":"metis_enum – Fortran METIS Interface"},{"text":"Uses: metis_interface metis_enum module~~metis_io~~UsesGraph module~metis_io metis_io module~metis_enum metis_enum module~metis_enum->module~metis_io module~metis_interface metis_interface module~metis_interface->module~metis_io iso_c_binding iso_c_binding iso_c_binding->module~metis_interface Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Used By module~~metis_io~~UsedByGraph module~metis_io metis_io module~metis_tests metis_tests module~metis_io->module~metis_tests program~test_fmetis test_fmetis module~metis_io->program~test_fmetis Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types MetisGraph Functions whitechar count_columns Subroutines write_graph load_graph print_metis_options ForMETIS_MeshToNodal Derived Types type, public :: MetisGraph Components Type Visibility Attributes Name Initial integer, public :: nvtxs integer, public :: nedgs integer, public, allocatable :: xadj (:) integer, public, allocatable :: adjncy (:) Functions public function whitechar (char) Arguments Type Intent Optional Attributes Name character, intent(in) :: char Return Value logical public function count_columns (unit, stat) result(ncol) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit integer, intent(out) :: stat Return Value integer Subroutines public subroutine write_graph (fname, xadj, adjncy, numflag) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname integer, intent(in) :: xadj (:) integer, intent(in) :: adjncy (:) integer, intent(in) :: numflag public subroutine load_graph (this, fname, numflag) Arguments Type Intent Optional Attributes Name type( MetisGraph ), intent(out) :: this character(len=*), intent(in) :: fname integer, intent(in) :: numflag public subroutine print_metis_options (opts, unit) Arguments Type Intent Optional Attributes Name integer, intent(in) :: opts (0:) integer, intent(in), optional :: unit public subroutine ForMETIS_MeshToNodal (ne, nn, eptr, eind, numflag, xadj, adjncy, stat) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ne integer, intent(in) :: nn integer, intent(in) :: eptr (ne+1) integer, intent(in) :: eind (:) integer, intent(in) :: numflag integer, intent(out), allocatable :: xadj (:) integer, intent(out), allocatable :: adjncy (:) integer, intent(out) :: stat","tags":"","loc":"module/metis_io.html","title":"metis_io – Fortran METIS Interface"},{"text":"Uses: metis_enum metis_interface module~~metis_oo_interface~~UsesGraph module~metis_oo_interface metis_oo_interface module~metis_enum metis_enum module~metis_enum->module~metis_oo_interface module~metis_interface metis_interface module~metis_interface->module~metis_oo_interface iso_c_binding iso_c_binding iso_c_binding->module~metis_interface Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types graph_type Functions whitechar count_columns Subroutines import_graph export_graph write_graph read_graph Derived Types type, public :: graph_type Components Type Visibility Attributes Name Initial integer, public :: nvxts Number of vertices. integer, public :: nedgs Number of edges. integer, public, pointer :: xadj (:) => null() integer, public, pointer :: adjncy (:) => null() integer, public :: numflag = 1 Numbering style. integer, public :: ncon integer, public, pointer :: vwgt (:) => null() integer, public, pointer :: adjwgt (:) => null() integer, public, pointer :: vsize (:) => null() Functions public function whitechar (char) Arguments Type Intent Optional Attributes Name character, intent(in) :: char Return Value logical public function count_columns (unit, stat) result(ncol) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit integer, intent(out) :: stat Return Value integer Subroutines public subroutine import_graph (fname, graph, numflag) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname class( graph_type ), intent(out) :: graph integer, intent(in), optional :: numflag public subroutine export_graph (fname, graph) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname class( graph_type ), intent(in) :: graph public subroutine write_graph (unit, xadj, adjncy, numflag, vwgt, adjwgt, vsize) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit integer, intent(in) :: xadj (:) integer, intent(in) :: adjncy (:) integer, intent(in), optional :: numflag integer, intent(in), optional :: vwgt (:) integer, intent(in), optional :: adjwgt (:) integer, intent(in), optional :: vsize (:) public subroutine read_graph (unit, xadj, adjncy, numflag, vwgt, adjwgt, vsize) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit integer, intent(out), pointer :: xadj (:) integer, intent(out), pointer :: adjncy (:) integer, intent(in), optional :: numflag integer, optional pointer :: vwgt (:) integer, intent(out), optional pointer :: adjwgt (:) integer, intent(out), optional pointer :: vsize (:)","tags":"","loc":"module/metis_oo_interface.html","title":"metis_oo_interface – Fortran METIS Interface"},{"text":"Uses: metis_interface metis_io module~~metis_tests~~UsesGraph module~metis_tests metis_tests module~metis_io metis_io module~metis_io->module~metis_tests module~metis_interface metis_interface module~metis_interface->module~metis_tests module~metis_interface->module~metis_io module~metis_enum metis_enum module~metis_enum->module~metis_io iso_c_binding iso_c_binding iso_c_binding->module~metis_interface Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Subroutines test1 test2 test3 test4 Subroutines public subroutine test1 () Arguments None public subroutine test2 () Arguments None public subroutine test3 () Arguments None public subroutine test4 () Arguments None","tags":"","loc":"module/metis_tests.html","title":"metis_tests – Fortran METIS Interface"},{"text":"Uses: iso_c_binding metis_interface metis_enum program~~test_partgraphrecursive1~~UsesGraph program~test_partgraphrecursive1 test_PartGraphRecursive1 iso_c_binding iso_c_binding iso_c_binding->program~test_partgraphrecursive1 module~metis_interface metis_interface iso_c_binding->module~metis_interface module~metis_interface->program~test_partgraphrecursive1 module~metis_enum metis_enum module~metis_enum->program~test_partgraphrecursive1 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Calls program~~test_partgraphrecursive1~~CallsGraph program~test_partgraphrecursive1 test_PartGraphRecursive1 metis_partgraphrecursive metis_partgraphrecursive program~test_partgraphrecursive1->metis_partgraphrecursive Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Variables nvtxs nedgs xadj adjncy part objval ios Variables Type Attributes Name Initial integer(kind=c_int), parameter :: nvtxs = 15 integer(kind=c_int), parameter :: nedgs = 22 integer(kind=c_int) :: xadj (nvtxs+1) integer(kind=c_int) :: adjncy (2*nedgs) integer(kind=c_int) :: part (nvtxs) integer(kind=c_int) :: objval integer(kind=c_int) :: ios","tags":"","loc":"program/test_partgraphrecursive1.html","title":"test_PartGraphRecursive1 – Fortran METIS Interface"},{"text":"Uses: iso_c_binding metis_interface metis_enum program~~test_partmeshnodal1~~UsesGraph program~test_partmeshnodal1 test_PartMeshNodal1 iso_c_binding iso_c_binding iso_c_binding->program~test_partmeshnodal1 module~metis_interface metis_interface iso_c_binding->module~metis_interface module~metis_interface->program~test_partmeshnodal1 module~metis_enum metis_enum module~metis_enum->program~test_partmeshnodal1 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Calls program~~test_partmeshnodal1~~CallsGraph program~test_partmeshnodal1 test_PartMeshNodal1 metis_setdefaultoptions metis_setdefaultoptions program~test_partmeshnodal1->metis_setdefaultoptions metis_free metis_free program~test_partmeshnodal1->metis_free metis_partmeshnodal metis_partmeshnodal program~test_partmeshnodal1->metis_partmeshnodal metis_meshtonodal metis_meshtonodal program~test_partmeshnodal1->metis_meshtonodal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Variables ne nn npel eptr eind epart npart options ios objval c_xadj c_adjncy xadj adjncy Variables Type Attributes Name Initial integer(kind=c_int), parameter :: ne = 3 integer(kind=c_int), parameter :: nn = 8 integer(kind=c_int), parameter :: npel = 4 integer(kind=c_int) :: eptr (ne+1) integer(kind=c_int) :: eind (ne*npel) integer(kind=c_int) :: epart (ne) integer(kind=c_int) :: npart (nn) integer(kind=c_int) :: options (0:METIS_NOPTIONS-1) integer(kind=c_int) :: ios integer(kind=c_int) :: objval type(c_ptr) :: c_xadj type(c_ptr) :: c_adjncy integer(kind=c_int), pointer :: xadj (:) => null() integer(kind=c_int), pointer :: adjncy (:) => null()","tags":"","loc":"program/test_partmeshnodal1.html","title":"test_PartMeshNodal1 – Fortran METIS Interface"},{"text":"Uses: iso_c_binding metis_interface metis_enum program~~test_partgraphkway~~UsesGraph program~test_partgraphkway test_PartGraphKway iso_c_binding iso_c_binding iso_c_binding->program~test_partgraphkway module~metis_interface metis_interface iso_c_binding->module~metis_interface module~metis_interface->program~test_partgraphkway module~metis_enum metis_enum module~metis_enum->program~test_partgraphkway Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Partition a graph specified by a matrix Source: http://people.eecs.berkeley.edu/~demmel/cs267/lecture18/lecture18.html Calls program~~test_partgraphkway~~CallsGraph program~test_partgraphkway test_PartGraphKway metis_setdefaultoptions metis_setdefaultoptions program~test_partgraphkway->metis_setdefaultoptions metis_partgraphkway metis_partgraphkway program~test_partgraphkway->metis_partgraphkway Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Variables npart n m xadj adjncy perm iperm part options ios objval Variables Type Attributes Name Initial integer(kind=c_int), parameter :: npart = 3 integer(kind=c_int), parameter :: n = 8 integer(kind=c_int), parameter :: m = 10 integer(kind=c_int) :: xadj (n+1) integer(kind=c_int) :: adjncy (2*m) integer(kind=c_int) :: perm (n) integer(kind=c_int) :: iperm (n) integer(kind=c_int) :: part (n) integer(kind=c_int) :: options (0:METIS_NOPTIONS-1) integer(kind=c_int) :: ios integer(kind=c_int) :: objval","tags":"","loc":"program/test_partgraphkway.html","title":"test_PartGraphKway – Fortran METIS Interface"},{"text":"Uses: iso_c_binding metis_interface metis_enum program~~test_partmeshnodal2~~UsesGraph program~test_partmeshnodal2 test_PartMeshNodal2 iso_c_binding iso_c_binding iso_c_binding->program~test_partmeshnodal2 module~metis_interface metis_interface iso_c_binding->module~metis_interface module~metis_interface->program~test_partmeshnodal2 module~metis_enum metis_enum module~metis_enum->program~test_partmeshnodal2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Example of partitioning a mesh composed of 4 quadrilaterals and 9 nodes\n   based upon its nodal graph. Source: https://www.cfd-online.com/Forums/main/112366-using-metis-functions-fortran.html#post404734 Calls program~~test_partmeshnodal2~~CallsGraph program~test_partmeshnodal2 test_PartMeshNodal2 metis_setdefaultoptions metis_setdefaultoptions program~test_partmeshnodal2->metis_setdefaultoptions metis_partmeshnodal metis_partmeshnodal program~test_partmeshnodal2->metis_partmeshnodal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Variables ne nn eptr eind epart npart opts ios objval Variables Type Attributes Name Initial integer(kind=c_int), parameter :: ne = 4 integer(kind=c_int), parameter :: nn = 9 integer(kind=c_int) :: eptr (ne+1) integer(kind=c_int) :: eind (4*ne) integer(kind=c_int) :: epart (ne) integer(kind=c_int) :: npart (nn) integer(kind=c_int) :: opts (0:METIS_NOPTIONS-1) integer(kind=c_int) :: ios integer(kind=c_int) :: objval","tags":"","loc":"program/test_partmeshnodal2.html","title":"test_PartMeshNodal2 – Fortran METIS Interface"},{"text":"Uses: iso_c_binding metis_interface metis_enum program~~test_partgraphrecursive2~~UsesGraph program~test_partgraphrecursive2 test_PartGraphRecursive2 iso_c_binding iso_c_binding iso_c_binding->program~test_partgraphrecursive2 module~metis_interface metis_interface iso_c_binding->module~metis_interface module~metis_interface->program~test_partgraphrecursive2 module~metis_enum metis_enum module~metis_enum->program~test_partgraphrecursive2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Partitioning a graph with non-equal number of edges per node. Calls program~~test_partgraphrecursive2~~CallsGraph program~test_partgraphrecursive2 test_PartGraphRecursive2 metis_setdefaultoptions metis_setdefaultoptions program~test_partgraphrecursive2->metis_setdefaultoptions metis_partgraphrecursive metis_partgraphrecursive program~test_partgraphrecursive2->metis_partgraphrecursive Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Variables n m xadj adjncy part options ios ncon objval Variables Type Attributes Name Initial integer(kind=c_int) :: n integer(kind=c_int) :: m integer(kind=c_int), allocatable :: xadj (:) integer(kind=c_int), allocatable :: adjncy (:) integer(kind=c_int), allocatable :: part (:) integer(kind=c_int) :: options (0:METIS_NOPTIONS-1) integer(kind=c_int) :: ios integer(kind=c_int) :: ncon integer(kind=c_int) :: objval","tags":"","loc":"program/test_partgraphrecursive2.html","title":"test_PartGraphRecursive2 – Fortran METIS Interface"},{"text":"Uses: iso_c_binding metis_interface metis_enum program~~test_nodend~~UsesGraph program~test_nodend test_NodeND iso_c_binding iso_c_binding iso_c_binding->program~test_nodend module~metis_interface metis_interface iso_c_binding->module~metis_interface module~metis_interface->program~test_nodend module~metis_enum metis_enum module~metis_enum->program~test_nodend Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Example of computing a fill-reducing ordering of a sparse matrix Source: http://comp.lang.fortran.narkive.com/uFmDM7Bo/how-to-call-a-metis-subroutine-from-my-fortran-code Calls program~~test_nodend~~CallsGraph program~test_nodend test_NodeND metis_setdefaultoptions metis_setdefaultoptions program~test_nodend->metis_setdefaultoptions metis_nodend metis_nodend program~test_nodend->metis_nodend Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Variables n m xadj adjncy perm iperm options ios Variables Type Attributes Name Initial integer(kind=c_int), parameter :: n = 15 integer(kind=c_int), parameter :: m = 22 integer(kind=c_int) :: xadj (n+1) integer(kind=c_int) :: adjncy (2*m) integer(kind=c_int) :: perm (n) integer(kind=c_int) :: iperm (n) integer(kind=c_int) :: options (0:METIS_NOPTIONS-1) integer(kind=c_int) :: ios","tags":"","loc":"program/test_nodend.html","title":"test_NodeND – Fortran METIS Interface"},{"text":"Uses: iso_c_binding metis_interface metis_enum metis_io program~~test_fmetis~~UsesGraph program~test_fmetis test_fmetis module~metis_io metis_io module~metis_io->program~test_fmetis iso_c_binding iso_c_binding iso_c_binding->program~test_fmetis module~metis_interface metis_interface iso_c_binding->module~metis_interface module~metis_interface->program~test_fmetis module~metis_interface->module~metis_io module~metis_enum metis_enum module~metis_enum->program~test_fmetis module~metis_enum->module~metis_io Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Calls program~~test_fmetis~~CallsGraph program~test_fmetis test_fmetis interface~metis_setdefaultoptions METIS_SetDefaultOptions program~test_fmetis->interface~metis_setdefaultoptions test1 test1 program~test_fmetis->test1 test4 test4 program~test_fmetis->test4 test2 test2 program~test_fmetis->test2 interface~metis_partgraphkway METIS_PartGraphKway program~test_fmetis->interface~metis_partgraphkway test3 test3 program~test_fmetis->test3 proc~write_graph write_graph program~test_fmetis->proc~write_graph proc~load_graph load_graph program~test_fmetis->proc~load_graph proc~whitechar whitechar proc~load_graph->proc~whitechar proc~count_columns count_columns proc~load_graph->proc~count_columns proc~count_columns->proc~whitechar Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Variables mgraph xadj adjncy part options ios ncon objval Variables Type Attributes Name Initial type(MetisGraph) :: mgraph integer, allocatable :: xadj (:) integer, allocatable :: adjncy (:) integer, allocatable :: part (:) integer(kind=c_int) :: options (40) integer(kind=c_int) :: ios integer(kind=c_int) :: ncon integer(kind=c_int) :: objval","tags":"","loc":"program/test_fmetis.html","title":"test_fmetis – Fortran METIS Interface"}]}