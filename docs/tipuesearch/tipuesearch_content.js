var tipuesearch = {"pages":[{"text":"Fortran METIS Interface Brief description This is a Fortran interface to the METIS software package for partitioning unstructured graphs, partitioning meshes, and computing fill-reducing orderings\nof sparse matrices. The interface makes use of the C interoperability features available in modern Fortran \n(i.e., Fortran 2003+) and provides a simple and safe way to call the original serial routines. License Further information METIS Home page METIS Manual (PDF) Developer Info Ivan Pribec","tags":"","loc":"index.html","title":" Fortran METIS Interface "},{"text":"Files Dependent On This One sourcefile~~metis_interface.f90~~AfferentGraph sourcefile~metis_interface.f90 metis_interface.f90 sourcefile~metis_tests.f90 metis_tests.f90 sourcefile~metis_interface.f90->sourcefile~metis_tests.f90 sourcefile~metis_io.f90 metis_io.f90 sourcefile~metis_interface.f90->sourcefile~metis_io.f90 sourcefile~metis_io.f90->sourcefile~metis_tests.f90 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules metis_interface Source Code metis_interface.f90 Source Code !***************************************************************************************** !> author: Ivan Pribec !  date: 7/2018 ! ! A Fortran interface to the METIS graph partitioning library. ! module metis_interface use iso_c_binding , only : c_int , c_double , c_ptr implicit none private ! Graph partitioning routines public :: METIS_PartGraphRecursive public :: METIS_PartGraphKway ! Mesh partitioning routines public :: METIS_PartMeshDual public :: METIS_PartMeshNodal ! Sparse matrix reordering routines public :: METIS_NodeND ! Mesh-to-graph conversion routines public :: METIS_MeshToDual public :: METIS_MeshToNodal ! Utility routines public :: METIS_SetDefaultOptions public :: METIS_Free ! Constants integer , parameter , public :: METIS_NOPTIONS = 40 !! Number of METIS options. ! ! METIS' API ! ! http://glaros.dtc.umn.edu/gkhome/node/877 interface ! ! Graph partitioning routines ! !***************************************************************************************** !> This function is used to partition a graph into `nparts` parts using recursive bisection. ! !  If `tpwgt` is present, the *target partition weight* for the `i`-th partition and `j`-th constraint should !  be specified at `tpwgts(i*ncon+j)` (the numbering for both partitions and constraints starts from 0). !  For each constraint, the sum of the `tpwgts`entries must be 1.0. ! !  The following options are valid: <br /> !  `METIS_OPTION_CTYPE`, `METIS_OPTION_IPTYPE`, `METIS_OPTION_RTYPE`, !  `METIS_OPTION_NO2HOP`, `METIS_OPTION_NCUTS`, `METIS_OPTION_NITER`, !  `METIS_OPTION_SEED`, `METIS_OPTION_UFACTOR`, `METIS_OPTION_NUMBERING`, !  `METIS_OPTION_DBGLVL` ! function METIS_PartGraphRecursive ( nvtxs , ncon , xadj , adjncy ,& vwgt , vsize , adjwgt , nparts , tpwgts , ubvec , options , objval , part ) result ( ierr ) bind ( C , name = \"METIS_PartGraphRecursive\" ) import c_int , c_double , METIS_NOPTIONS ! Parameters integer ( c_int ), intent ( in ) :: nvtxs !! The number of vertices in the graph. integer ( c_int ), intent ( in ) :: ncon !! The number of balancing constraints. It should be atleast 1. integer ( c_int ), intent ( in ), dimension ( * ) :: xadj , adjncy !! The adjacency structure of the graph as described in section 5.5 of the [manual](http://glaros.dtc.umn.edu/gkhome/fetch/sw/metis/manual.pdf). integer ( c_int ), intent ( in ), dimension ( * ), optional :: vwgt ! NULL !! The weights of the vertices as described in Section 5.5 of the [manual](http://glaros.dtc.umn.edu/gkhome/fetch/sw/metis/manual.pdf). integer ( c_int ), intent ( in ), dimension ( * ), optional :: vsize ! NULL !! The size of the vertices for computing the total communication volume as described in section 5.7 of the [manual](http://glaros.dtc.umn.edu/gkhome/fetch/sw/metis/manual.pdf). integer ( c_int ), intent ( in ), dimension ( * ), optional :: adjwgt ! NULL !! The weights of the edges as describe in Section 5.5 of the [manual](http://glaros.dtc.umn.edu/gkhome/fetch/sw/metis/manual.pdf). integer ( c_int ) , intent ( in ) :: nparts !! The number of parts to partition the graph. real ( c_double ), intent ( in ), optional :: tpwgts ( nparts * ncon ) !! An array of size `nparts*ncon` that specifies the desired weight for each partition and constraint. !! If not present, the graph is divided equally among the partitions. More in the description. real ( c_double ), intent ( in ), optional :: ubvec ( ncon ) !! An array of size `ncon` that specifiew the allowed load imbalance for each constraint. !! For the `i`-th partition and `j`-th constraint the allowed weight is the `ubvec(j)*tpwgts(i*ncon+j)` !! fraction of the `j`-th's constraint total weight. If not present, the load imbalance !! tolerance is 1.001 (for `ncon = 1`) or 1.01 (for `ncon > 1`). integer ( c_int ), intent ( in ), optional :: options ( METIS_NOPTIONS ) !! An array of options as described in Section 5.4 of the METIS manual. See description for valid options. integer ( c_int ), intent ( out ) :: objval !! Upon successful completion, this variable stores the edge-cut or the total communication volume of the partitioning !! solution. The value returned depends on the partitioning's objective function. integer ( c_int ), intent ( out ) :: part ( nvtxs ) !! This is a vector of size `nvtxs` that upon successful completion stores the partition vector of the graph. !! The numbering of this vector starts from either 0 or 1, depending on the value of `options(METIS_OPTION_NUMBERING)`. ! Returns integer ( c_int ) :: ierr !! `METIS_OK` - Indicates that the function returned normally.<br /> !! `METIS_ERROR_INPUT` - Indicates an input error.<br /> !! `METIS_ERROR_MEMORY` - Indicates that it could not allocate the required memory.<br /> !! `METIS_ERROR` - Indicates some other type of error. end function !***************************************************************************************** !***************************************************************************************** !> This function is used to partition a graph into `nparts` parts using multilevel k-way partitioning. ! !  If `tpwgt` is present, the *target partition weight* for the `i`-th partition and `j`-th constraint should !  be specified at `tpwgts(i*ncon+j)` (the numbering for both partitions and constraints starts from 0). !  For each constraint, the sum of the `tpwgts`entries must be 1.0. ! !  The following options are valid: <br /> !  `METIS_OPTION_OBJTYPE`, `METIS_OPTION_CTYPE`, `METIS_OPTION_IPTYPE`, !  `METIS_OPTION_RTYPE`, `METIS_OPTION_NO2HOP`, `METIS_OPTION_NCUTS`, !  `METIS_OPTION_NITER`, `METIS_OPTION_UFACTOR`, `METIS_OPTION_MINCONN`, !  `METIS_OPTION_CONTIG`, `METIS_OPTION_SEED`, `METIS_OPTION_NUMBERING`, !  `METIS_OPTION_DBGLVL` ! function METIS_PartGraphKway ( nvtxs , ncon , xadj , adjncy ,& vwgt , vsize , adjwgt , nparts , tpwgts , ubvec , options , objval , part ) result ( ierr ) bind ( C , name = \"METIS_PartGraphKway\" ) import c_int , c_double , METIS_NOPTIONS ! Parameters integer ( c_int ), intent ( in ) :: nvtxs !! The number of vertices in the graph. integer ( c_int ), intent ( in ) :: ncon !! The number of balancing constraints. It should be at least 1. integer ( c_int ), intent ( in ), dimension ( * ) :: xadj , adjncy !! The adjacency structure of the graph as described in section 5.5 of the [manual](http://glaros.dtc.umn.edu/gkhome/fetch/sw/metis/manual.pdf). integer ( c_int ), intent ( in ), dimension ( * ), optional :: vwgt !! The weights of the vertices as described in Section 5.5 of the [manual](http://glaros.dtc.umn.edu/gkhome/fetch/sw/metis/manual.pdf). integer ( c_int ), intent ( in ), dimension ( * ), optional :: vsize !! The size of the vertices for computing the total communication volume as described in section 5.7 of the [manual](http://glaros.dtc.umn.edu/gkhome/fetch/sw/metis/manual.pdf). integer ( c_int ), intent ( in ), dimension ( * ), optional :: adjwgt !! The weights of the edges as describe in Section 5.5 of the [manual](http://glaros.dtc.umn.edu/gkhome/fetch/sw/metis/manual.pdf). integer ( c_int ), intent ( in ) :: nparts !! The number of parts to partition the graph. real ( c_double ), intent ( in ), optional :: tpwgts ( nparts * ncon ) !! An array of size `nparts*ncon` that specifies the desired weight for each partition and constraint. !! If not present, the graph is divided equally among the partitions. More in the description. real ( c_double ), intent ( in ), optional :: ubvec ( ncon ) !! An array of size `ncon` that specifiew the allowed load imbalance for each constraint. !! For the `i`-th partition and `j`-th constraint the allowed weight is the `ubvec(j)*tpwgts(i*ncon+j)` !! fraction of the `j`-th's constraint total weight. If not present, the load imbalance !! tolerance is 1.001 (for `ncon == 1`) or 1.01 (for `ncon > 1`). integer ( c_int ), intent ( in ), optional :: options ( METIS_NOPTIONS ) !! An array of options as described in Section 5.4 of the [manual](http://glaros.dtc.umn.edu/gkhome/fetch/sw/metis/manual.pdf). See description for valid options. integer ( c_int ), intent ( out ) :: objval !! Upon successful completion, this variable stores the edge-cut or the total communication volume of the partitioning !! solution. The value returned depends on the partitioning's objective function. integer ( c_int ), intent ( out ) :: part ( nvtxs ) !! This is a vector of size `nvtxs` that upon successful completion stores the partition vector of the graph. !! The numbering of this vector starts from either 0 or 1, depending on the value of `options(METIS_OPTION_NUMBERING)`. ! Returns integer ( c_int ) :: ierr !! `METIS_OK` - Indicates that the function returned normally.<br /> !! `METIS_ERROR_INPUT` - Indicates an input error.<br /> !! `METIS_ERROR_MEMORY` - Indicates that it could not allocate the required memory.<br /> !! `METIS_ERROR` - Indicates some other type of error. end function !***************************************************************************************** ! ! Mesh partitioning routines ! !***************************************************************************************** !> This function is used to partition a mesh into `nparts` parts based on a partitioning of the mesh's dual graph. ! !  The following options are valid: <br /> !  `METIS_OPTION_PTYPE`, `METIS_OPTION_OBJTYPE`, `METIS_OPTION_CTYPE`, !  `METIS_OPTION_IPTYPE`, `METIS_OPTION_RTYPE`, `METIS_OPTION_NCUTS`, !  `METIS_OPTION_NITER`, `METIS_OPTION_SEED`, `METIS_OPTION_UFACTOR`, !  `METIS_OPTION_NUMBERING`, `METIS_OPTION_DBGLVL` ! function METIS_PartMeshDual ( ne , nn , eptr , eind , vwgt , vsize , ncommon , & nparts , tpwgts , options , objval , epart , npart ) result ( ierr ) bind ( C , name = \"METIS_PartMeshDual\" ) import c_int , METIS_NOPTIONS integer ( c_int ), intent ( in ) :: ne !! The number of elements in the mesh. integer ( c_int ), intent ( in ) :: nn !! The number of nodes in the mesh. integer ( c_int ), intent ( in ), dimension ( * ) :: eptr , eind !! The pair of arrays storing the mesh as described in Section 5.6 of the [manual](http://glaros.dtc.umn.edu/gkhome/fetch/sw/metis/manual.pdf). integer ( c_int ), intent ( in ), optional :: vwgt ( ne ) !! An array of size `ne` specifying the weights of the elements. If not present, !! all elements have an equal weight. integer ( c_int ), intent ( in ), optional :: vsize ( ne ) !! An array of size `ne` specifying the size of the elements that is used !! for computing the total comunication volume as described in Section 5.7 of the  [manual](http://glaros.dtc.umn.edu/gkhome/fetch/sw/metis/manual.pdf). !! If not present, the objective is cut or all elements have an equal size. integer ( c_int ), intent ( in ) :: ncommon integer ( c_int ), intent ( in ) :: nparts !! The number of parts to partition the mesh. integer ( c_int ), intent ( in ), optional :: tpwgts ( nparts ) !! An array of size `nparts` that specifies the desired weight for each partition. The *target !! partition weight* for the `i`-th partition is specified at `tpwgts(i)` (the numbering for the !! partitions starts from 0). The sum of the `tpwgts` entries must be 1.0. <br /> If not present, the graph !! is divided equally among the partitions. integer ( c_int ), intent ( in ), optional :: options ( METIS_NOPTIONS ) !! An array of options as described in Section 5.4 of the [manual](http://glaros.dtc.umn.edu/gkhome/fetch/sw/metis/manual.pdf). See description for valid options. integer ( c_int ), intent ( out ) :: objval !! Upon successful completion, this variable stores either the edgecut or the total communication !! volume of the dual graph's partitioning. integer ( c_int ), intent ( out ) :: epart ( ne ) !! A vector of size `ne` that upon successful completion stores the partition vector for the elements !! of the mesh. The numbering of this vector starts from either 0 or 1, depending on the value of !! `options(METIS_OPTION_NUMBERING)`. integer ( c_int ), intent ( out ) :: npart ( nn ) !! A vector of size `nn` that upon successful completion stores the partition vector for the nodes !! of the mesh. The numbering of this vector starts from either 0 or 1, depending on the value of !! `options(METIS_OPTION_NUMBERING)`. ! Returns integer ( c_int ) :: ierr !! `METIS_OK` - Indicates that the function returned normally.<br /> !! `METIS_ERROR_INPUT` - Indicates an input error.<br /> !! `METIS_ERROR_MEMORY` - Indicates that it could not allocate the required memory.<br /> !! `METIS_ERROR` - Indicates some other type of error. end function !***************************************************************************************** !***************************************************************************************** !> This function us used to partition a mesh into `nparts` parts based on a !  partitioning of the mesh's nodal graph. ! !  The following options are valid: <br /> !  `METIS_OPTION_PTYPE`, `METIS_OPTION_OBJTYPE`, `METIS_OPTION_CTYPE`, !  `METIS_OPTION_IPTYPE`, `METIS_OPTION_RTYPE`, `METIS_OPTION_NCUTS`, !  `METIS_OPTION_NITER`, `METIS_OPTION_SEED`, `METIS_OPTION_UFACTOR`, !  `METIS_OPTION_NUMBERING`, `METIS_OPTION_DBGLVL` ! function METIS_PartMeshNodal ( ne , nn , eptr , eind , vwgt , vsize , & nparts , tpwgts , options , objval , epart , npart ) result ( ierr ) bind ( C , name = \"METIS_PartMeshNodal\" ) import c_int , METIS_NOPTIONS integer ( c_int ), intent ( in ) :: ne !! The number of elements in the mesh. integer ( c_int ), intent ( in ) :: nn !! The number of nodes in the mesh. integer ( c_int ), intent ( in ), dimension ( * ) :: eptr , eind !! The pair of arrays storing the mesh as described in Section 5.6 of the [manual](http://glaros.dtc.umn.edu/gkhome/fetch/sw/metis/manual.pdf). integer ( c_int ), intent ( in ), optional :: vwgt ( nn ) !! An array of size `nn` specifying weights of the nodes. If not passed, all nodes have an equal weight. integer ( c_int ), intent ( in ), optional :: vsize ( nn ) !! An array of size `nn` specifying the size of the nodes that is used for computing the !! total comunication volume as described in Section 5.7 of the [manual](http://glaros.dtc.umn.edu/gkhome/fetch/sw/metis/manual.pdf). If not passed, !! the objective is cut or all nodes have an equal size. integer ( c_int ), intent ( in ) :: nparts !! The number of parts to partition the mesh. integer ( c_int ), intent ( in ), optional :: tpwgts ( nparts ) !! An array of size `nparts` that specifies the desired weight for each partition. The *target !! partition weight* for the `i`-th partition is specified at `tpwgts(i)` (the numbering for the !! partitions starts from 0). The sum of the `tpwgts` entries must be 1.0. If not passed, the graph !! is divided equally among the partitions. integer ( c_int ), intent ( in ), optional :: options ( METIS_NOPTIONS ) !! An array of options as described in Section 5.4 of the [manual](http://glaros.dtc.umn.edu/gkhome/fetch/sw/metis/manual.pdf). See description for valid options. integer ( c_int ), intent ( out ) :: objval !! Upon successful completion, this variable stores either the edgecut or the total communication !! volume of the nodal graph's partitioning. integer ( c_int ), intent ( out ) :: epart ( ne ) !! A vector of size `ne` that upon successful completion stores the partition vector for the elements !! of the mesh. The numbering of this vector starts from either 0 or 1, depending on the value of !! `options(METIS_OPTION_NUMBERING)`. integer ( c_int ), intent ( out ) :: npart ( nn ) !! A vector of size `nn` that upon successful completion stores the partition vector for the nodes !! of the mesh. The numbering of this vector starts from either 0 or 1, depending on the value of !! `options(METIS_OPTION_NUMBERING)`. ! Returns integer ( c_int ) :: ierr !! `METIS_OK` - Indicates that the function returned normally.<br /> !! `METIS_ERROR_INPUT` - Indicates an input error.<br /> !! `METIS_ERROR_MEMORY` - Indicates that it could not allocate the required memory.<br /> !! `METIS_ERROR` - Indicates some other type of error. end function !***************************************************************************************** ! ! Sparse Matrix Reordering Routines ! !***************************************************************************************** !> This function computes fill reducing orderings of sparse matrices using the !  multilevel nested dissection algorithm. ! !  Let A be the original matrix and A' be the permuted matrix. The arrays !  `perm` and `iperm` are defined as follows. Row (column) `i` of A' is the !  `perm(i)` row (column) of A, and row (column) `i` of A is the `iperm(i)` !  row (column) of A'. the numbering of this vector starts from either 0 or 1, !  depending on the value of `options(METIS_OPTION_NUMBERING)`. ! !  If the graph is weighted, meaning `vgwt` was provided, the nested dissection ordering computes !  vertex separators that minimize the sum of the weights of the vertices on the separators. ! !  The following options are valid: <br /> !  `METIS_OPTION_CTYPE`, `METIS_OPTION_RTYPE`, `METIS_OPTION_NO2HOP`, !  `METIS_OPTION_NSEPS`, `METIS_OPTION_NITER`, `METIS_OPTION_UFACTOR`, !  `METIS_OPTION_COMPRESS`, `METIS_OPTION_CCORDER`, `METIS_OPTION_SEED`, !  `METIS_OPTION_PFACTOR`, `METIS_OPTION_NUMBERING`, `METIS_OPTION_DBGLVL` ! !#Example ! The code below generates the nodal graph of the following mesh: !```Fortran !integer(c_int), parameter :: n = 15, m = 22 !integer(c_int) :: xadj(n+1), adjncy(2*m) !integer(c_int) :: perm(n), iperm(n) !integer(c_int) :: options(0:39), ierr ! !xadj = [1,3,6,9,12,14,17,21,25,29,32,34,37,40,43,45] !adjncy = [2,6,1,3,7,2,4,8,3,5,9,4,10,1,7,11,2,6, & !                  8,12,3,7,9,13,4,8,10,14,5,9,15,6,12,7,11,13, & !                  8,12,14,9,13,15,10,14] ! !ierr = METIS_SetDefaultOptions(options) !options(18) = 1 ! !ierr = METIS_NodeND(n,xadj,adjncy,options=options,perm=perm,iperm=iperm) !end !``` function METIS_NodeND ( nvtxs , xadj , adjncy , vwgt , options , perm , iperm ) result ( ierr ) bind ( C , name = \"METIS_NodeND\" ) import c_int , METIS_NOPTIONS ! Parameters integer ( c_int ), intent ( in ) :: nvtxs !! The number of vertices in the graph. integer ( c_int ), intent ( in ), dimension ( * ) :: xadj , adjncy !! The adjacency structure of the graph as described in Section 5.5 of the [manual](http://glaros.dtc.umn.edu/gkhome/fetch/sw/metis/manual.pdf). integer ( c_int ), intent ( in ), optional :: vwgt ( nvtxs ) !! An array of size `nvtxs` specifying the weights of the vertices. integer ( c_int ), intent ( in ), optional :: options ( METIS_NOPTIONS ) !! This is the array of options as described in Section 5.4 of the [manual](http://glaros.dtc.umn.edu/gkhome/fetch/sw/metis/manual.pdf). See description for valid options. integer ( c_int ), intent ( out ) :: perm ( nvtxs ), iperm ( nvtxs ) !! Vectors of size `nvtxs`. Upon successful completion, they store the fill-reducing !! permutation and inverse-permutation. More in the description. ! Returns integer ( c_int ) :: ierr !! `METIS_OK` - Indicates that the function returned normally.<br /> !! `METIS_ERROR_INPUT` - Indicates an input error.<br /> !! `METIS_ERROR_MEMORY` - Indicates that it could not allocate the required memory.<br /> !! `METIS_ERROR` - Indicates some other type of error. end function !***************************************************************************************** ! ! Mesh-to-graph conversion routines ! !***************************************************************************************** !> This function is used to generate the dual graph of a mesh. ! !@note ! To use the returned arrays `xadj` and `adjncy`, these must be first converted from ! a C pointer to a Fortran pointer using the subroutine `c_f_pointer(cptr,fptr,shape)` ! that assigns the target of the C pointer `cptr` to the Fortran pointer `fptr` and ! specifies its shape. The `shape` is an integer rank-one array, storing the size `ne+1` ! in case of the dual graph. The size of the new `adjncy` array is stored in the ! last element of `xadj` when using C-style numbering. An example is shown below. !@endnote ! !@warning ! Memory for the returned arrays `xadj` and `adjncy` is allocated by METIS' API in C ! using the standard `malloc` function. It is the responsibility of the application to free ! this memory by calling `free`. Therefore, METIS provides the [[METIS_Free]] function that is a wrapper to ! C's `free`function. !@endwarning ! !# Example ! The code below generates the nodal graph of the following mesh: ! __image__ !```Fortran !use iso_c_binding, only : c_int, c_ptr, c_f_pointer !integer(c_int), parameter :: ne = 3, nn = 8, npel = 4 !integer(c_int) :: ierr, eptr(ne+1), eind(ne*npel), numflag, ncommon !type(c_ptr) :: xadj, adjncy !integer(c_int), dimension(:), pointer :: fxadj => null(), fadjncy => null() ! !numflag = 0 ! C-style numbering !ncommon = 2 ! 2 common nodes per edge !eptr = [0,4,8,12] !eind = [0,1,2,3,1,4,5,2,4,6,7,5] ! note four nodes per element ! !ierr = METIS_MeshToDual(ne,nn,eptr,eind,ncommon,numflag,xadj,adjncy) !call c_f_pointer(xadj,fxadj,shape=[ne+1]) ! xadj is of the size ne+1 !call c_f_pointer(adjncy,fadjncy,shape=[fxadj(ne+1)]) ! last value in xadj is the size of adjncy ! ! !... use values in fxadj and fadjncy ... ! !call METIS_Free(xadj) !call METIS_Free(adjncy) !end !``` function METIS_MeshToDual ( ne , nn , eptr , eind , ncommon , numflag , xadj , adjncy ) result ( ierr ) bind ( C , name = \"METIS_MeshToDual\" ) import c_int , c_ptr ! Parameters integer ( c_int ), intent ( in ) :: ne !! The number of elements in the mesh. integer ( c_int ), intent ( in ) :: nn !! The number of nodes in the mesh. integer ( c_int ), intent ( in ), dimension ( * ) :: eptr , eind !! The pair of arrays storing the mesh as described in Section 5.6 of the [manual](http://glaros.dtc.umn.edu/gkhome/fetch/sw/metis/manual.pdf). integer ( c_int ), intent ( in ) :: ncommon !! The number of common nodes that two elements must have in order to put !! an edge between them in the dual graph. integer ( c_int ), intent ( in ) :: numflag !! Used to indicate which numbering scheme is used for `eptr` and `eind`. !! The possible values are: <br /> !! 0 - C-style numbering is assumed that starts from 0 <br /> !! 1 - Fortran-style numbering is assumed that starts from 1 type ( c_ptr ), intent ( out ) :: xadj , adjncy !! These arrays store the adjacency structure of the generated dual graph. !! The format of the adjacency structure is described in Section 5.5 of the [manual](http://glaros.dtc.umn.edu/gkhome/fetch/sw/metis/manual.pdf). ! Returns integer ( c_int ) :: ierr !! `METIS_OK` - Indicates that the function returned normally.<br /> !! `METIS_ERROR_INPUT` - Indicates an input error.<br /> !! `METIS_ERROR_MEMORY` - Indicates that it could not allocate the required memory.<br /> !! `METIS_ERROR` - Indicates some other type of error. end function !***************************************************************************************** !***************************************************************************************** !> This function is used to generate the nodal graph of a mesh. ! !@note ! To use the returned arrays `xadj` and `adjncy`, these must be first converted from ! a C pointer to a Fortran pointer using the subroutine `c_f_pointer(cptr,fptr,shape)` ! that assigns the target of the C pointer `cptr` to the Fortran pointer `fptr` and ! specifies its shape. The `shape` is an integer rank-one array, storing the size `nn+1` ! in case of the nodal graph. The size of the new `adjncy` array is stored in the ! last element of `xadj` when using C-style numbering. An example is shown below. !@endnote ! !@warning ! Memory for the returned arrays `xadj` and `adjncy` is allocated by METIS' API in C ! using the standard `malloc` function. It is the responsibility of the application to free ! this memory by calling `free`. Therefore, METIS provides the [[METIS_Free]] function that is a wrapper to ! C's `free`function. !@endwarning ! !# Example ! The code below generates the nodal graph of the following mesh: ! __image__ !```Fortran !use iso_c_binding, only : c_int, c_ptr, c_f_pointer !integer(c_int), parameter :: ne = 3, nn = 8, npel = 4 !integer(c_int) :: ierr, eptr(ne+1), eind(ne*npel), numflag !type(c_ptr) :: xadj, adjncy !integer(c_int), dimension(:), pointer :: fxadj => null(), fadjncy => null() ! !numflag = 0 ! C-style numbering !eptr = [0,4,8,12] !eind = [0,1,2,3,1,4,5,2,4,6,7,5] ! note four nodes per element ! !ierr = METIS_MeshToNodal(ne,nn,eptr,eind,numflag,xadj,adjncy) !call c_f_pointer(xadj,fxadj,shape=[nn+1]) ! xadj is of the size nn+1 !call c_f_pointer(adjncy,fadjncy,shape=[fxadj(nn+1)]) ! last value in xadj is the size of adjncy ! ! !... use values in fxadj and fadjncy ... ! !call METIS_Free(xadj) !call METIS_Free(adjncy) !end !``` function METIS_MeshToNodal ( ne , nn , eptr , eind , numflag , xadj , adjncy ) result ( ierr ) bind ( C , name = \"METIS_MeshToNodal\" ) import c_int , c_ptr ! Parameters integer ( c_int ), intent ( in ) :: ne !! The number of elements in the mesh. integer ( c_int ), intent ( in ) :: nn !! The number of nodes in the mesh. integer ( c_int ), intent ( in ), dimension ( * ) :: eptr , eind !! The pair of arrays storing the mesh as described in Section 5.6 of the [manual](http://glaros.dtc.umn.edu/gkhome/fetch/sw/metis/manual.pdf). integer ( c_int ), intent ( in ) :: numflag !! Used to indicate which numbering scheme is used for `eptr` and `eind`. !! The possible values are: <br /> !! 0 - C-style numbering is assumed that starts from 0 <br /> !! 1 - Fortran-style numbering is assumed that starts from 1 type ( c_ptr ), intent ( out ) :: xadj , adjncy !! These arrays store the adjacency structure of the generated dual graph. !! The format of the adjacency structure is described in Section 5.5 of the [manual](http://glaros.dtc.umn.edu/gkhome/fetch/sw/metis/manual.pdf). ! Returns integer ( c_int ) :: ierr !! `METIS_OK` - Indicates that the function returned normally.<br /> !! `METIS_ERROR_INPUT` - Indicates an input error.<br /> !! `METIS_ERROR_MEMORY` - Indicates that it could not allocate the required memory.<br /> !! `METIS_ERROR` - Indicates some other type of error. end function !***************************************************************************************** ! ! Utility routines ! !***************************************************************************************** !> Initializes the options array into its default values. ! !@note ! The passed array `options` must have the size `METIS_NOPTIONS` (40). ! To be able to use the parameters in the [[metis_enum]] module it is recommended to use ! zero-based indexing for the options array: !```Fortran !integer(c_int) :: opts(0:39) !``` !@endnote ! !# Examples ! To set Fortran style index-numbering use: !```Fortran !integer :: opts(0:39) ! !call METIS_SetDefaultOptions(opts) !opts(17) = 1 ! Fortran-style index numbering !``` ! ! Other options can be changed using parameters from the [[metis_enum]] module. !```Fortran !use metis_interface, only : METIS_SetDefaultOptions !use metis_enum, only : METIS_OPTION_DBGLVL, METIS_DBG_INFO !integer :: opts(0:39) ! !call METIS_SetDefaultOptions(opts) !opts(METIS_OPTION_DBGLVL) = METIS_DBG_INFO ! Show various diagnostic messages !end !``` function METIS_SetDefaultOptions ( options ) result ( ierr ) bind ( C , name = \"METIS_SetDefaultOptions\" ) import c_int , METIS_NOPTIONS ! Parameters integer ( c_int ), intent ( out ) :: options ( METIS_NOPTIONS ) !! The array of options that will be initialized. ! Returns integer ( c_int ) :: ierr !! `METIS_OK` - Indicates that the function returned normally. end function !***************************************************************************************** !***************************************************************************************** !> Frees the memory that was allocated by either the [[METIS_MeshToDual]] or the !  [[METIS_MeshToNodal]] routines for returning the dual or nodal graph of a mesh. ! !@warning Memory deallocation should always happen on the same side it was allocated! ! Also check the descriptions of the above-mentioned routines. ! !# Example ! !```Fortran ! type(c_ptr) :: xadj(:),adjncy(:) ! ! call METIS_MeshToNodal(...,xadj,adjncy) ! ! ! Deallocation of arrays allocated in C ! call METIS_Free(xadj) ! call METIS_Free(adjncy) !``` function METIS_Free ( ptr ) result ( ierr ) bind ( C , name = \"METIS_Free\" ) import c_int , c_ptr ! Parameters type ( c_ptr ), value :: ptr !! The pointer to be freed. This pointer should be one of the `xadj` or `adjncy` !! arrays returned by METIS' API routines. ! Returns integer ( c_int ) :: ierr !! `METIS_OK` - Indicates that the function returned normally. end function !***************************************************************************************** end interface end module !*****************************************************************************************","tags":"","loc":"sourcefile/metis_interface.f90.html","title":"metis_interface.f90 â€“ Fortran METIS Interface"},{"text":"Files Dependent On This One sourcefile~~metis_enum.f90~~AfferentGraph sourcefile~metis_enum.f90 metis_enum.f90 sourcefile~metis_tests.f90 metis_tests.f90 sourcefile~metis_enum.f90->sourcefile~metis_tests.f90 sourcefile~metis_io.f90 metis_io.f90 sourcefile~metis_enum.f90->sourcefile~metis_io.f90 sourcefile~metis_io.f90->sourcefile~metis_tests.f90 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules metis_enum Source Code metis_enum.f90 Source Code module metis_enum implicit none public ! ! Enum type definitions ! ! Return codes integer , parameter :: METIS_OK = 1 !! Returned normally. integer , parameter :: METIS_ERROR_INPUT = - 2 !! Returned due to erroneous inputs and/or options. integer , parameter :: METIS_ERROR_MEMORY = - 3 !! Returned due to insufficient memory. integer , parameter :: METIS_ERROR = - 4 !! Return status: some other type of error. ! Operation type codes ! integer, parameter :: METIS_OP_PMETIS = 0 ! integer, parameter :: METIS_OP_KMETIS = 1 ! integer, parameter :: METIS_OP_OMETIS = 2 ! Options codes (i.e., `options`) integer , parameter :: METIS_OPTION_PTYPE = 0 !! Specifies the partitioning method. integer , parameter :: METIS_OPTION_OBJTYPE = 1 !! Specifies the type of objective. integer , parameter :: METIS_OPTION_CTYPE = 2 !! Specifies the matching scheme to be used during coarsening. integer , parameter :: METIS_OPTION_IPTYPE = 3 !! Determines the algorithm used during initial partitioning. integer , parameter :: METIS_OPTION_RTYPE = 4 !! Determines the algorithm used for refinement. integer , parameter :: METIS_OPTION_DBGLVL = 5 !! Specifies the amount of progress/debugging information will be printed. integer , parameter :: METIS_OPTION_NITER = 6 !! Specifies the number of iterations for the refinement algorithm. integer , parameter :: METIS_OPTION_NCUTS = 7 !! Specifies the number of different partitionings that it will compute. integer , parameter :: METIS_OPTION_SEED = 8 !! Specifies the seed for the random number generator. integer , parameter :: METIS_OPTION_NO2HOP = 9 !! Specifies that the coarsening will not perform any 2â€“hop matchings when the standard matching approach fails to sufficiently coarsen the graph. integer , parameter :: METIS_OPTION_MINCONN = 10 !! Specifies that the partitioning routines should try to minimize the maximum degree of the subdomain graph. integer , parameter :: METIS_OPTION_CONTIG = 11 !! Specifies that the partitioning routines should try to produce partitions that are contigous. integer , parameter :: METIS_OPTION_COMPRESS = 12 !! Specifies that the graph should be compressed by combining together vertices that have identical adjacency lists. integer , parameter :: METIS_OPTION_CCORDER = 13 !! Specifies if the connected components of the graph should first be identifies and ordered separately. integer , parameter :: METIS_OPTION_PFACTOR = 14 !! Specifies the minimum degree of the vertices that will be ordered last. integer , parameter :: METIS_OPTION_NSEPS = 15 !! Specifies the number of different separators that it will compute at each level of nested dissection. integer , parameter :: METIS_OPTION_UFACTOR = 16 !! Specifies the maximum allowed load imbalance among the partitions. integer , parameter :: METIS_OPTION_NUMBERING = 17 !! Used to indicate which numbering scheme is used for the adjacency structure of a graph or the element-node structure of a mesh ! Partitioning Schemes integer , parameter :: METIS_PTYPE_RB = 0 !! Multilevel recursive bisectioning. integer , parameter :: METIS_PTYPE_KWAY = 1 !! Multilevel k-way partitioning. ! Graph types for meshes ! integer, parameter :: METIS_GTYPE_DUAL  = 0 ! integer, parameter :: METIS_GTYPE_NODAL = 1 ! Coarsening Schemes integer , parameter :: METIS_CTYPE_RM = 0 !! Random matching. integer , parameter :: METIS_CTYPE_SHEM = 1 !! sorted heavy-edge matching. ! Initial partitioning schemes integer , parameter :: METIS_IPTYPE_GROW = 0 !! Grows a bisection using a greedy strategy. integer , parameter :: METIS_IPTYPE_RANDOM = 1 !! Computes a bisection at random followed by a refinement. integer , parameter :: METIS_IPTYPE_EDGE = 2 !! Derives a separator form an edge cut. integer , parameter :: METIS_IPTYPE_NODE = 3 !! Grows a bisection using a greedy node-based strategy. integer , parameter :: METIS_IPTYPE_METISRB = 4 ! Refinement schemes integer , parameter :: METIS_RTYPE_FM = 0 !! FM-based cut refinement. integer , parameter :: METIS_RTYPE_GREEDY = 1 !! Greedy-based cut and volume refinement. integer , parameter :: METIS_RTYPE_SEP2SIDED = 2 !! Two-sided node FM refinement. integer , parameter :: METIS_RTYPE_SEP1SIDED = 3 !! One-sided node FM refinement. ! Debug Levels integer , parameter :: METIS_DBG_INFO = 1 !! Shows various diagnostic messages. integer , parameter :: METIS_DBG_TIME = 2 !! Perform timing analysis. integer , parameter :: METIS_DBG_COARSEN = 4 !! Show the coarsening progress. integer , parameter :: METIS_DBG_REFINE = 8 !! Show the refinement progress. integer , parameter :: METIS_DBG_IPART = 16 !! Show info on initial partitioning. integer , parameter :: METIS_DBG_MOVEINFO = 32 !! Show info on vertex moves during refinement. integer , parameter :: METIS_DBG_SEPINFO = 64 !! Show info on vertex moves during sep refinement. integer , parameter :: METIS_DBG_CONNINFO = 128 !! Show info on minimization of subdomain connectivity. integer , parameter :: METIS_DBG_CONTIGINFO = 256 !! Show info on elimination of connected components. integer , parameter :: METIS_DBG_MEMORY = 2048 !! Show info related to wspace allocation. ! Types of objectives integer , parameter :: METIS_OBJTYPE_CUT = 0 !! Edge-cut minimization. integer , parameter :: METIS_OBJTYPE_VOL = 1 !! Total communication volume minimization. integer , parameter :: METIS_OBJTYPE_NODE = 2 end module","tags":"","loc":"sourcefile/metis_enum.f90.html","title":"metis_enum.f90 â€“ Fortran METIS Interface"},{"text":"This File Depends On sourcefile~~metis_io.f90~~EfferentGraph sourcefile~metis_io.f90 metis_io.f90 sourcefile~metis_interface.f90 metis_interface.f90 sourcefile~metis_interface.f90->sourcefile~metis_io.f90 sourcefile~metis_enum.f90 metis_enum.f90 sourcefile~metis_enum.f90->sourcefile~metis_io.f90 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~metis_io.f90~~AfferentGraph sourcefile~metis_io.f90 metis_io.f90 sourcefile~metis_tests.f90 metis_tests.f90 sourcefile~metis_io.f90->sourcefile~metis_tests.f90 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules metis_io Source Code metis_io.f90 Source Code module metis_io use metis_interface use metis_enum implicit none public type :: MetisGraph integer :: nvtxs , nedgs integer , allocatable :: xadj (:), adjncy (:) end type contains subroutine write_graph ( fname , xadj , adjncy , numflag ) character ( len =* ), intent ( in ) :: fname integer , intent ( in ) :: xadj (:) integer , intent ( in ) :: adjncy (:) integer , intent ( in ) :: numflag integer :: unit , i , j print * , \"[write_graph] adjncy = \" , adjncy open ( newunit = unit , file = fname ) if ( numflag == 0 ) then write ( unit , * ) size ( xadj ) - 1 , size ( adjncy ) / 2 do i = 1 , size ( xadj ) - 1 write ( unit , * ) ( adjncy ( j ), j = xadj ( i ) + 1 , xadj ( i + 1 )) end do else write ( unit , * ) size ( xadj ) - 1 , size ( adjncy ) / 2 do i = 1 , size ( xadj ) - 1 write ( unit , * ) ( adjncy ( j ), j = xadj ( i ), xadj ( i + 1 ) - 1 ) end do end if close ( unit ) end subroutine logical function whitechar ( char ) ! white character ! returns .true. if char is space (32) or tab (9), .false. otherwise character , intent ( in ) :: char if ( iachar ( char ) == 32 . or . iachar ( char ) == 9 ) then whitechar = . true . else whitechar = . false . end if end function integer function count_columns ( unit , stat ) result ( ncol ) integer , intent ( in ) :: unit integer , intent ( out ) :: stat character ( len = 1 ) :: c logical :: lastwhite ncol = 0 lastwhite = . true . do read ( unit , '(a)' , advance = 'no' , iostat = stat ) c if ( stat /= 0 ) exit if ( lastwhite . and . . not . whitechar ( c )) ncol = ncol + 1 lastwhite = whitechar ( c ) end do end function subroutine load_graph ( this , fname , numflag ) type ( MetisGraph ), intent ( out ) :: this character ( len =* ), intent ( in ) :: fname integer , intent ( in ) :: numflag character ( len = 1 ) :: c integer :: unit , ncol , ios , i , rowcol , j logical :: lastwhite character ( len = 3 ) :: fmt integer :: n , m , ncon , ifmt integer , allocatable :: xadj (:), adjncy (:) integer , allocatable :: vsize (:), vwgt (:), adjwgt (:) integer , allocatable :: tmp (:) open ( newunit = unit , file = fname , status = 'old' ) ! determine number of columns in first row of file ncol = 0 lastwhite = . true . do read ( unit , '(a)' , advance = 'no' , iostat = ios ) c if ( ios /= 0 ) exit if ( lastwhite . and . . not . whitechar ( c )) ncol = ncol + 1 lastwhite = whitechar ( c ) end do ! back to start of file rewind ( unit ) ! read header line select case ( ncol ) case ( 2 ) fmt = \"000\" ncon = 0 read ( unit , * , iostat = ios ) n , m case ( 3 ) ncon = 0 read ( unit , * , iostat = ios ) n , m , fmt case ( 4 ) read ( unit , * , iostat = ios ) n , m , fmt , ncon case default write ( * , * ) \"[load_graph]: incorrect file\" stop end select read ( fmt , '(I3)' , iostat = ios ) ifmt print * , n , m , fmt , ncon print * , \"ifmt = \" , ifmt ! allocate vertex adjacency structures allocate ( xadj ( n + 1 )) allocate ( adjncy ( 2 * m )) ! perform bit-tests to check for weights and sizes if ( btest ( ifmt , 0 )) allocate ( adjwgt ( 2 * m )) if ( btest ( ifmt , 1 )) then if ( ncon == 0 ) then ncol = 4 ! implicit fourth column with 1 constraint ncon = 1 ! case for fmt = \"*1*\" and ncon is not specified end if if ( ncon > 0 ) then allocate ( vwgt ( n * ncon )) else print * , \"[load_graph] ncon has not been specified\" stop end if end if if ( btest ( ifmt , 2 )) allocate ( vsize ( n )) print * , \"allocated vertex sizes\" , allocated ( vsize ) print * , \"allocated vertex weights\" , allocated ( vwgt ) print * , \"allocated edge weights\" , allocated ( adjwgt ) xadj ( 1 ) = 0 select case ( ncol ) case ( 2 ) ! only connectivity, fmt = \"000\" do i = 1 , n rowcol = count_columns ( unit , stat = ios ) ! print *, \"rowcol = \", rowcol xadj ( i + 1 ) = xadj ( i ) + rowcol backspace ( unit , iostat = ios ) read ( unit , * ) adjncy ( xadj ( i ) + 1 : xadj ( i + 1 )) ! print *, (adjncy(j),j=xadj(i)+1, xadj(i+1)) end do case ( 3 ) ! edge weights or vertex sizes select case ( fmt ) case ( \"001\" ) do i = 1 , n rowcol = count_columns ( unit , stat = ios ) backspace ( unit , iostat = ios ) ! print *, \"rowcol = \", rowcol xadj ( i + 1 ) = xadj ( i ) + rowcol / 2 if ( allocated ( tmp )) deallocate ( tmp ) allocate ( tmp ( rowcol )) read ( unit , * ) tmp adjncy ( xadj ( i ) + 1 : xadj ( i + 1 )) = tmp ( 1 :: 2 ) adjwgt ( xadj ( i ) + 1 : xadj ( i + 1 )) = tmp ( 2 :: 2 ) end do case ( \"101\" ) do i = 1 , n rowcol = count_columns ( unit , stat = ios ) - 1 backspace ( unit , iostat = ios ) ! print *, \"rowcol = \", rowcol xadj ( i + 1 ) = xadj ( i ) + rowcol / 2 if ( allocated ( tmp )) deallocate ( tmp ) allocate ( tmp ( rowcol )) read ( unit , * ) vsize ( i ), tmp adjncy ( xadj ( i ) + 1 : xadj ( i + 1 )) = tmp ( 1 :: 2 ) adjwgt ( xadj ( i ) + 1 : xadj ( i + 1 )) = tmp ( 2 :: 2 ) end do case ( \"100\" ) do i = 1 , n rowcol = count_columns ( unit , stat = ios ) - 1 ! print *, \"rowcol = \", rowcol xadj ( i + 1 ) = xadj ( i ) + rowcol backspace ( unit , iostat = ios ) read ( unit , * ) vsize ( i ), ( adjncy ( j ), j = xadj ( i ) + 1 , xadj ( i + 1 )) ! print *, (adjncy(j),j=xadj(i)+1, xadj(i+1)) end do case default print * , \"should not be here\" stop end select case ( 4 ) ! vertex weights and constraint select case ( fmt ) case ( '010' ) do i = 1 , n rowcol = count_columns ( unit , stat = ios ) - ncon print * , ncon , rowcol xadj ( i + 1 ) = xadj ( i ) + rowcol backspace ( unit , iostat = ios ) read ( unit , * ) vwgt (( i - 1 ) * ncon + 1 :( i - 1 ) * ncon + ncon ), adjncy ( xadj ( i ) + 1 : xadj ( i + 1 )) end do case ( '011' ) do i = 1 , n rowcol = ( count_columns ( unit , stat = ios ) - ncon ) / 2 print * , ncon , rowcol backspace ( unit , iostat = ios ) xadj ( i + 1 ) = xadj ( i ) + rowcol if ( allocated ( tmp )) deallocate ( tmp ) allocate ( tmp ( 2 * rowcol )) read ( unit , * ) vwgt (( i - 1 ) * ncon + 1 :( i - 1 ) * ncon + ncon ), tmp adjncy ( xadj ( i ) + 1 : xadj ( i + 1 )) = tmp ( 1 :: 2 ) adjwgt ( xadj ( i ) + 1 : xadj ( i + 1 )) = tmp ( 2 :: 2 ) end do case ( '110' ) do i = 1 , n rowcol = count_columns ( unit , stat = ios ) - 1 - ncon print * , ncon , rowcol xadj ( i + 1 ) = xadj ( i ) + rowcol backspace ( unit , iostat = ios ) read ( unit , * ) vsize ( i ), vwgt (( i - 1 ) * ncon + 1 :( i - 1 ) * ncon + ncon ), adjncy ( xadj ( i ) + 1 : xadj ( i + 1 )) end do case ( '111' ) do i = 1 , n rowcol = ( count_columns ( unit , stat = ios ) - 1 - ncon ) / 2 print * , ncon , rowcol backspace ( unit , iostat = ios ) xadj ( i + 1 ) = xadj ( i ) + rowcol if ( allocated ( tmp )) deallocate ( tmp ) allocate ( tmp ( 2 * rowcol )) read ( unit , * ) vsize ( i ), vwgt (( i - 1 ) * ncon + 1 :( i - 1 ) * ncon + ncon ), tmp adjncy ( xadj ( i ) + 1 : xadj ( i + 1 )) = tmp ( 1 :: 2 ) adjwgt ( xadj ( i ) + 1 : xadj ( i + 1 )) = tmp ( 2 :: 2 ) end do case default print * , \"should not be here\" stop end select ! fmt case default print * , \"[load_graph] error\" stop end select ! ncol this % nvtxs = n this % nedgs = m this % xadj = xadj if ( numflag == 0 ) then this % adjncy = adjncy else this % adjncy = adjncy + 1 end if ! print *, \"xadj = \", xadj ! print *, \"adjncy = \",adjncy ! print *, \"edge weights = \", adjwgt ! print *, \"vsize = \", vsize ! print *, \"vertex weights = \", vwgt close ( unit ) end subroutine subroutine print_options ( opts ) integer , intent ( in ) :: opts (:) integer :: i do i = lbound ( opts , 1 ), ubound ( opts , 1 ) print * , \"option \" , i , opts ( i ) end do end subroutine subroutine ForMETIS_MeshToNodal ( ne , nn , eptr , eind , numflag , xadj , adjncy , stat ) use iso_c_binding , only : c_int , c_ptr , c_f_pointer integer , intent ( in ) :: ne integer , intent ( in ) :: nn integer , intent ( in ) :: eptr ( ne + 1 ) integer , intent ( in ) :: eind (:) integer , intent ( in ) :: numflag integer , intent ( out ), allocatable :: xadj (:) integer , intent ( out ), allocatable :: adjncy (:) integer , intent ( out ) :: stat type ( c_ptr ) :: xadj_ , adjncy_ integer ( c_int ), pointer :: fxadj (:) => null (), fadjncy (:) => null () stat = METIS_MeshToNodal ( ne , nn , eptr , eind , numflag , xadj_ , adjncy_ ) if ( stat < 0 ) return call c_f_pointer ( xadj_ , fxadj , shape = [ nn + 1 ]) select case ( numflag ) case ( 0 ) call c_f_pointer ( adjncy_ , fadjncy , shape = [ fxadj ( nn + 1 )]) case ( 1 ) call c_f_pointer ( adjncy_ , fadjncy , shape = [ fxadj ( nn + 1 ) - 1 ]) end select ! xadj => fxadj allocate ( xadj ( size ( fxadj ))) xadj = fxadj allocate ( adjncy ( size ( fadjncy )), stat = stat ) adjncy = fadjncy stat = METIS_Free ( xadj_ ); ! if (stat < 0) return stat = METIS_Free ( adjncy_ ) ! if (stat < 0) return end subroutine end module","tags":"","loc":"sourcefile/metis_io.f90.html","title":"metis_io.f90 â€“ Fortran METIS Interface"},{"text":"This File Depends On sourcefile~~metis_tests.f90~~EfferentGraph sourcefile~metis_tests.f90 metis_tests.f90 sourcefile~metis_enum.f90 metis_enum.f90 sourcefile~metis_enum.f90->sourcefile~metis_tests.f90 sourcefile~metis_io.f90 metis_io.f90 sourcefile~metis_enum.f90->sourcefile~metis_io.f90 sourcefile~metis_interface.f90 metis_interface.f90 sourcefile~metis_interface.f90->sourcefile~metis_tests.f90 sourcefile~metis_interface.f90->sourcefile~metis_io.f90 sourcefile~metis_io.f90->sourcefile~metis_tests.f90 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs test_fmetis Modules metis_tests Source Code metis_tests.f90 Source Code module metis_tests use metis_interface use metis_io implicit none private public :: test1 , test2 , test3 , test4 contains ! https://stackoverflow.com/questions/20006253/using-metis-libraries-in-fortran-code-the-basics ! http://glaros.dtc.umn.edu/gkhome/node/852 subroutine test1 () use , intrinsic :: iso_c_binding , only : c_int , c_ptr , c_f_pointer integer , parameter :: nel = 3 ! number of elements integer , parameter :: nnds = 8 ! number of nodes integer , parameter :: npel = 4 ! nodes per element integer :: eptr ( nel + 1 ) integer :: eind ( nel * npel ) integer :: epart ( nel ), npart ( nnds ) integer ( c_int ) :: options ( 0 : METIS_NOPTIONS - 1 ) integer :: ios , objval type ( c_ptr ) :: xadj , adjncy integer ( c_int ), pointer :: fxadj (:) => null (), fadjncy (:) => null () integer , allocatable :: new_xadj (:), new_adjncy (:) print * , \"TEST 1\" ! 0---1---4---6 ! : 0 : 1 : 2 : ! 3---2---5---7 eptr = [ 0 , 4 , 8 , 12 ] eind = [ 0 , 1 , 2 , 3 , 1 , 4 , 5 , 2 , 4 , 6 , 7 , 5 ] ! Element 1 has nodes 0 1 2 3 ! Element 2 has nodes 1 4 5 2 ios = METIS_SetDefaultOptions ( options ) options ( 17 ) = 0 ios = METIS_PartMeshNodal ( nel , nnds , eptr , eind , nparts = 2 , options = options ,& objval = objval , epart = epart , npart = npart ) print * , \"ios = \" , ios print * , \"objval = \" , objval print * , \"npart = \" , npart print * , \"epart = \" , epart call ForMETIS_MeshToNodal ( nel , nnds , eptr , eind , 0 , new_xadj , new_adjncy , ios ) print * , \"new_xadj = \" , new_xadj print * , \"new_adjncy = \" , new_adjncy ios = METIS_MeshToNodal ( nel , nnds , eptr , eind , 0 , xadj , adjncy ) ! print *, \"xadj = \", xadj ! print *, \"adjncy = \", adjncy call c_f_pointer ( xadj , fxadj , shape = [ nnds + 1 ]) call c_f_pointer ( adjncy , fadjncy , shape = [ fxadj ( nnds + 1 )]) print * , \"size=\" , size ( fxadj ), \"fxadj = \" , fxadj print * , \"fadjncy = \" , fadjncy call write_graph ( \"test1.graph\" , fxadj , fadjncy , 1 ) ios = METIS_Free ( xadj ) ! print *, \"xadj = \", xadj ! print *, \"fxadj = \", fxadj ! ios = METIS_Free(adjncy) end subroutine ! https://stackoverflow.com/questions/8155160/metis-with-fortran ! http://glaros.dtc.umn.edu/gkhome/node/799 subroutine test2 () use , intrinsic :: iso_c_binding , only : c_int integer , parameter :: nvtxs = 15 integer , parameter :: nedgs = 22 integer :: xadj ( nvtxs + 1 ), adjncy ( 2 * nedgs ) integer :: objval , part ( nvtxs ), ios print * , \"TEST 2\" xadj = [ 0 , 2 , 5 , 8 , 11 , 13 , 16 , 20 , 24 , 28 , 31 , 33 , 36 , 39 , 42 , 44 ] adjncy = [ 1 , 5 , 0 , 2 , 6 , 1 , 3 , 7 , 2 , 4 , 8 , 3 , 9 , 0 , 6 , 10 , 1 , 5 , 7 , 11 , 2 , 6 , 8 , 12 , 3 , 7 , 9 , 13 , 4 , 8 , 14 , 5 , 11 , 6 , 10 , 12 , 7 , 11 , 13 , 8 , 12 , 14 , 9 , 13 ] ! options(18) = 0 ! C-style indexing ios = METIS_PartGraphRecursive ( nvtxs , ncon = 1 , xadj = xadj , adjncy = adjncy , nparts = 2 , objval = objval , part = part ) print * , \"ios = \" , ios print * , \"objval = \" , objval print * , \"part = \" , part end subroutine ! http://comp.lang.fortran.narkive.com/uFmDM7Bo/how-to-call-a-metis-subroutine-from-my-fortran-code subroutine test3 () !  1---2---3---4---5 !  |   |   |   |   | !  6---7---8---9---10 !  |   |   |   |   | !  11--12--13--14--15 integer , parameter :: n = 15 integer , parameter :: m = 22 integer :: xadj ( n + 1 ), adjncy ( 2 * m ) integer :: perm ( n ), iperm ( n ) integer :: options ( 0 : 40 ), ios print * , \"TEST 3\" xadj = [ 1 , 3 , 6 , 9 , 12 , 14 , 17 , 21 , 25 , 29 , 32 , 34 , 37 , 40 , 43 , 45 ] adjncy = [ 2 , 6 , 1 , 3 , 7 , 2 , 4 , 8 , 3 , 5 , 9 , 4 , 10 , 1 , 7 , 11 , 2 , 6 , & 8 , 12 , 3 , 7 , 9 , 13 , 4 , 8 , 10 , 14 , 5 , 9 , 15 , 6 , 12 , 7 , 11 , 13 , & 8 , 12 , 14 , 9 , 13 , 15 , 10 , 14 ] ios = METIS_SetDefaultOptions ( options ) options ( 17 ) = 1 ios = METIS_NodeND ( n , xadj , adjncy , options = options , perm = perm , iperm = iperm ) print * , \"ios = \" , ios print * , \"perm = \" , perm print * , \"iperm = \" , iperm end subroutine ! https://www.cfd-online.com/Forums/main/112366-using-metis-functions-fortran.html subroutine test4 !  1---2---5 !  | 1 | 2 | !  4---3---6 !  | 4 | 3 | !  9---8---7 integer , parameter :: ne = 4 integer , parameter :: nn = 9 integer :: eptr ( ne + 1 ), eind ( 4 * ne ) integer :: epart ( ne ), npart ( nn ) integer :: opts ( 0 : 39 ), ios , objval print * , \"TEST 4\" eptr = [ 1 , 5 , 9 , 13 , 17 ] eind = [ 1 , 2 , 3 , 4 , 2 , 5 , 6 , 3 , 3 , 6 , 7 , 8 , 4 , 3 , 8 , 9 ] ios = METIS_SetDefaultOptions ( opts ) opts ( 17 ) = 1 opts ( METIS_OPTION_CONTIG ) = 1 call print_options ( opts ) ios = METIS_PartMeshDual ( ne , nn , eptr , eind , ncommon = 2 , nparts = 2 , options = opts , & objval = objval , epart = epart , npart = npart ) ! ios = METIS_PartMeshNodal(ne,nn,eptr,eind,nparts=2,options=opts, & ! objval=objval,epart=epart,npart=npart) print * , \"ios = \" , ios print * , \"objval = \" , objval print * , \"epart = \" , epart print * , \"npart = \" , npart end subroutine end module program test_fmetis use iso_c_binding use metis_interface use metis_enum use metis_io type ( MetisGraph ) :: mgraph integer , allocatable :: xadj (:), adjncy (:), part (:) integer ( c_int ) :: options ( 40 ), ios , ncon , objval xadj = [ 0 , 3 , 6 , 10 , 14 , 17 , 20 , 22 ] adjncy = [ 5 , 3 , 2 , 1 , 3 , 4 , 5 , 4 , 2 , 1 , 2 , 3 , 6 , 7 , 1 , 3 , 6 , 5 , 4 , 7 , 6 , 4 ] - 1 print * , \"n = \" , size ( xadj ) - 1 print * , \"2*m = \" , size ( adjncy ) call write_graph ( \"example.graph\" , xadj , adjncy , 0 ) ! call load_graph(mgraph,\"../graphs/4elt.graph\",numflag=0) call load_graph ( mgraph , \"example.graph\" , numflag = 0 ) print * , mgraph % nvtxs print * , mgraph % nedgs print * , mgraph % xadj print * , mgraph % adjncy ! call write_graph(\"print.graph\",) ios = METIS_SetDefaultOptions ( options ) options ( 18 ) = 0 print * , \"ios = \" , ios allocate ( part ( mgraph % nvtxs )) ncon = 1 ios = METIS_PartGraphKway ( mgraph % nvtxs , ncon , mgraph % xadj , mgraph % adjncy ,& nparts = 2 , objval = objval , part = part , options = options ) print * , \"ios = \" , ios print * , \"objval = \" , objval print * , \"part = \" , part write ( * , * ) call test1 print * , \" \" call test2 print * , \" \" call test3 print * , \" \" call test4 end program","tags":"","loc":"sourcefile/metis_tests.f90.html","title":"metis_tests.f90 â€“ Fortran METIS Interface"},{"text":"type, public :: MetisGraph Variables nvtxs nedgs xadj adjncy Components Type Visibility Attributes Name Initial integer, public :: nvtxs integer, public :: nedgs integer, public, allocatable :: xadj (:) integer, public, allocatable :: adjncy (:)","tags":"","loc":"type/metisgraph.html","title":"MetisGraph â€“ Fortran METIS Interface "},{"text":"interface Called By interface~~metis_partgraphrecursive~~CalledByGraph interface~metis_partgraphrecursive METIS_PartGraphRecursive proc~test2 test2 proc~test2->interface~metis_partgraphrecursive Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public function METIS_PartGraphRecursive(nvtxs, ncon, xadj, adjncy, vwgt, vsize, adjwgt, nparts, tpwgts, ubvec, options, objval, part) result(ierr) bind(C,name=\"METIS_PartGraphRecursive\") Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: nvtxs The number of vertices in the graph. integer(kind=c_int), intent(in) :: ncon The number of balancing constraints. It should be atleast 1. integer(kind=c_int), intent(in), dimension(*) :: xadj The adjacency structure of the graph as described in section 5.5 of the manual . integer(kind=c_int), intent(in), dimension(*) :: adjncy The adjacency structure of the graph as described in section 5.5 of the manual . integer(kind=c_int), intent(in), optional dimension(*) :: vwgt The weights of the vertices as described in Section 5.5 of the manual . integer(kind=c_int), intent(in), optional dimension(*) :: vsize The size of the vertices for computing the total communication volume as described in section 5.7 of the manual . integer(kind=c_int), intent(in), optional dimension(*) :: adjwgt The weights of the edges as describe in Section 5.5 of the manual . integer(kind=c_int), intent(in) :: nparts The number of parts to partition the graph. real(kind=c_double), intent(in), optional :: tpwgts (nparts*ncon) An array of size nparts*ncon that specifies the desired weight for each partition and constraint.\n If not present, the graph is divided equally among the partitions. More in the description. real(kind=c_double), intent(in), optional :: ubvec (ncon) An array of size ncon that specifiew the allowed load imbalance for each constraint. \n For the i -th partition and j -th constraint the allowed weight is the ubvec(j)*tpwgts(i*ncon+j) fraction of the j -th's constraint total weight. If not present, the load imbalance\n tolerance is 1.001 (for ncon = 1 ) or 1.01 (for ncon > 1 ). integer(kind=c_int), intent(in), optional :: options (METIS_NOPTIONS) An array of options as described in Section 5.4 of the METIS manual. See description for valid options. integer(kind=c_int), intent(out) :: objval Upon successful completion, this variable stores the edge-cut or the total communication volume of the partitioning\n solution. The value returned depends on the partitioning's objective function. integer(kind=c_int), intent(out) :: part (nvtxs) This is a vector of size nvtxs that upon successful completion stores the partition vector of the graph.\n The numbering of this vector starts from either 0 or 1, depending on the value of options(METIS_OPTION_NUMBERING) . Return Value integer(kind=c_int) METIS_OK - Indicates that the function returned normally. METIS_ERROR_INPUT - Indicates an input error. METIS_ERROR_MEMORY - Indicates that it could not allocate the required memory. METIS_ERROR - Indicates some other type of error. Description This function is used to partition a graph into nparts parts using recursive bisection. If tpwgt is present, the target partition weight for the i -th partition and j -th constraint should\n  be specified at tpwgts(i*ncon+j) (the numbering for both partitions and constraints starts from 0).\n  For each constraint, the sum of the tpwgts entries must be 1.0. The following options are valid: METIS_OPTION_CTYPE , METIS_OPTION_IPTYPE , METIS_OPTION_RTYPE , METIS_OPTION_NO2HOP , METIS_OPTION_NCUTS , METIS_OPTION_NITER , METIS_OPTION_SEED , METIS_OPTION_UFACTOR , METIS_OPTION_NUMBERING , METIS_OPTION_DBGLVL","tags":"","loc":"interface/metis_partgraphrecursive.html","title":"METIS_PartGraphRecursive â€“ Fortran METIS Interface"},{"text":"interface Called By interface~~metis_partgraphkway~~CalledByGraph interface~metis_partgraphkway METIS_PartGraphKway program~test_fmetis test_fmetis program~test_fmetis->interface~metis_partgraphkway Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public function METIS_PartGraphKway(nvtxs, ncon, xadj, adjncy, vwgt, vsize, adjwgt, nparts, tpwgts, ubvec, options, objval, part) result(ierr) bind(C,name=\"METIS_PartGraphKway\") Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: nvtxs The number of vertices in the graph. integer(kind=c_int), intent(in) :: ncon The number of balancing constraints. It should be at least 1. integer(kind=c_int), intent(in), dimension(*) :: xadj The adjacency structure of the graph as described in section 5.5 of the manual . integer(kind=c_int), intent(in), dimension(*) :: adjncy The adjacency structure of the graph as described in section 5.5 of the manual . integer(kind=c_int), intent(in), optional dimension(*) :: vwgt The weights of the vertices as described in Section 5.5 of the manual . integer(kind=c_int), intent(in), optional dimension(*) :: vsize The size of the vertices for computing the total communication volume as described in section 5.7 of the manual . integer(kind=c_int), intent(in), optional dimension(*) :: adjwgt The weights of the edges as describe in Section 5.5 of the manual . integer(kind=c_int), intent(in) :: nparts The number of parts to partition the graph. real(kind=c_double), intent(in), optional :: tpwgts (nparts*ncon) An array of size nparts*ncon that specifies the desired weight for each partition and constraint.\n If not present, the graph is divided equally among the partitions. More in the description. real(kind=c_double), intent(in), optional :: ubvec (ncon) An array of size ncon that specifiew the allowed load imbalance for each constraint. \n For the i -th partition and j -th constraint the allowed weight is the ubvec(j)*tpwgts(i*ncon+j) fraction of the j -th's constraint total weight. If not present, the load imbalance\n tolerance is 1.001 (for ncon == 1 ) or 1.01 (for ncon > 1 ). integer(kind=c_int), intent(in), optional :: options (METIS_NOPTIONS) An array of options as described in Section 5.4 of the manual . See description for valid options. integer(kind=c_int), intent(out) :: objval Upon successful completion, this variable stores the edge-cut or the total communication volume of the partitioning\n solution. The value returned depends on the partitioning's objective function. integer(kind=c_int), intent(out) :: part (nvtxs) This is a vector of size nvtxs that upon successful completion stores the partition vector of the graph.\n The numbering of this vector starts from either 0 or 1, depending on the value of options(METIS_OPTION_NUMBERING) . Return Value integer(kind=c_int) METIS_OK - Indicates that the function returned normally. METIS_ERROR_INPUT - Indicates an input error. METIS_ERROR_MEMORY - Indicates that it could not allocate the required memory. METIS_ERROR - Indicates some other type of error. Description This function is used to partition a graph into nparts parts using multilevel k-way partitioning. If tpwgt is present, the target partition weight for the i -th partition and j -th constraint should\n  be specified at tpwgts(i*ncon+j) (the numbering for both partitions and constraints starts from 0).\n  For each constraint, the sum of the tpwgts entries must be 1.0. The following options are valid: METIS_OPTION_OBJTYPE , METIS_OPTION_CTYPE , METIS_OPTION_IPTYPE , METIS_OPTION_RTYPE , METIS_OPTION_NO2HOP , METIS_OPTION_NCUTS , METIS_OPTION_NITER , METIS_OPTION_UFACTOR , METIS_OPTION_MINCONN , METIS_OPTION_CONTIG , METIS_OPTION_SEED , METIS_OPTION_NUMBERING , METIS_OPTION_DBGLVL","tags":"","loc":"interface/metis_partgraphkway.html","title":"METIS_PartGraphKway â€“ Fortran METIS Interface"},{"text":"interface Called By interface~~metis_partmeshdual~~CalledByGraph interface~metis_partmeshdual METIS_PartMeshDual proc~test4 test4 proc~test4->interface~metis_partmeshdual Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public function METIS_PartMeshDual(ne, nn, eptr, eind, vwgt, vsize, ncommon, nparts, tpwgts, options, objval, epart, npart) result(ierr) bind(C,name=\"METIS_PartMeshDual\") Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: ne The number of elements in the mesh. integer(kind=c_int), intent(in) :: nn The number of nodes in the mesh. integer(kind=c_int), intent(in), dimension(*) :: eptr The pair of arrays storing the mesh as described in Section 5.6 of the manual . integer(kind=c_int), intent(in), dimension(*) :: eind The pair of arrays storing the mesh as described in Section 5.6 of the manual . integer(kind=c_int), intent(in), optional :: vwgt (ne) An array of size ne specifying the weights of the elements. If not present,\n all elements have an equal weight. integer(kind=c_int), intent(in), optional :: vsize (ne) An array of size ne specifying the size of the elements that is used\n for computing the total comunication volume as described in Section 5.7 of the manual .\n If not present, the objective is cut or all elements have an equal size. integer(kind=c_int), intent(in) :: ncommon integer(kind=c_int), intent(in) :: nparts The number of parts to partition the mesh. integer(kind=c_int), intent(in), optional :: tpwgts (nparts) An array of size nparts that specifies the desired weight for each partition. The target\n partition weight for the i -th partition is specified at tpwgts(i) (the numbering for the \n partitions starts from 0). The sum of the tpwgts entries must be 1.0. If not present, the graph\n is divided equally among the partitions. integer(kind=c_int), intent(in), optional :: options (METIS_NOPTIONS) An array of options as described in Section 5.4 of the manual . See description for valid options. integer(kind=c_int), intent(out) :: objval Upon successful completion, this variable stores either the edgecut or the total communication\n volume of the dual graph's partitioning. integer(kind=c_int), intent(out) :: epart (ne) A vector of size ne that upon successful completion stores the partition vector for the elements\n of the mesh. The numbering of this vector starts from either 0 or 1, depending on the value of options(METIS_OPTION_NUMBERING) . integer(kind=c_int), intent(out) :: npart (nn) A vector of size nn that upon successful completion stores the partition vector for the nodes \n of the mesh. The numbering of this vector starts from either 0 or 1, depending on the value of options(METIS_OPTION_NUMBERING) . Return Value integer(kind=c_int) METIS_OK - Indicates that the function returned normally. METIS_ERROR_INPUT - Indicates an input error. METIS_ERROR_MEMORY - Indicates that it could not allocate the required memory. METIS_ERROR - Indicates some other type of error. Description This function is used to partition a mesh into nparts parts based on a partitioning of the mesh's dual graph. The following options are valid: METIS_OPTION_PTYPE , METIS_OPTION_OBJTYPE , METIS_OPTION_CTYPE , METIS_OPTION_IPTYPE , METIS_OPTION_RTYPE , METIS_OPTION_NCUTS , METIS_OPTION_NITER , METIS_OPTION_SEED , METIS_OPTION_UFACTOR , METIS_OPTION_NUMBERING , METIS_OPTION_DBGLVL","tags":"","loc":"interface/metis_partmeshdual.html","title":"METIS_PartMeshDual â€“ Fortran METIS Interface"},{"text":"interface Called By interface~~metis_partmeshnodal~~CalledByGraph interface~metis_partmeshnodal METIS_PartMeshNodal proc~test1 test1 proc~test1->interface~metis_partmeshnodal Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public function METIS_PartMeshNodal(ne, nn, eptr, eind, vwgt, vsize, nparts, tpwgts, options, objval, epart, npart) result(ierr) bind(C,name=\"METIS_PartMeshNodal\") Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: ne The number of elements in the mesh. integer(kind=c_int), intent(in) :: nn The number of nodes in the mesh. integer(kind=c_int), intent(in), dimension(*) :: eptr The pair of arrays storing the mesh as described in Section 5.6 of the manual . integer(kind=c_int), intent(in), dimension(*) :: eind The pair of arrays storing the mesh as described in Section 5.6 of the manual . integer(kind=c_int), intent(in), optional :: vwgt (nn) An array of size nn specifying weights of the nodes. If not passed, all nodes have an equal weight. integer(kind=c_int), intent(in), optional :: vsize (nn) An array of size nn specifying the size of the nodes that is used for computing the\n total comunication volume as described in Section 5.7 of the manual . If not passed,\n the objective is cut or all nodes have an equal size. integer(kind=c_int), intent(in) :: nparts The number of parts to partition the mesh. integer(kind=c_int), intent(in), optional :: tpwgts (nparts) An array of size nparts that specifies the desired weight for each partition. The target\n partition weight for the i -th partition is specified at tpwgts(i) (the numbering for the \n partitions starts from 0). The sum of the tpwgts entries must be 1.0. If not passed, the graph\n is divided equally among the partitions. integer(kind=c_int), intent(in), optional :: options (METIS_NOPTIONS) An array of options as described in Section 5.4 of the manual . See description for valid options. integer(kind=c_int), intent(out) :: objval Upon successful completion, this variable stores either the edgecut or the total communication\n volume of the nodal graph's partitioning. integer(kind=c_int), intent(out) :: epart (ne) A vector of size ne that upon successful completion stores the partition vector for the elements\n of the mesh. The numbering of this vector starts from either 0 or 1, depending on the value of options(METIS_OPTION_NUMBERING) . integer(kind=c_int), intent(out) :: npart (nn) A vector of size nn that upon successful completion stores the partition vector for the nodes \n of the mesh. The numbering of this vector starts from either 0 or 1, depending on the value of options(METIS_OPTION_NUMBERING) . Return Value integer(kind=c_int) METIS_OK - Indicates that the function returned normally. METIS_ERROR_INPUT - Indicates an input error. METIS_ERROR_MEMORY - Indicates that it could not allocate the required memory. METIS_ERROR - Indicates some other type of error. Description This function us used to partition a mesh into nparts parts based on a \n  partitioning of the mesh's nodal graph. The following options are valid: METIS_OPTION_PTYPE , METIS_OPTION_OBJTYPE , METIS_OPTION_CTYPE , METIS_OPTION_IPTYPE , METIS_OPTION_RTYPE , METIS_OPTION_NCUTS , METIS_OPTION_NITER , METIS_OPTION_SEED , METIS_OPTION_UFACTOR , METIS_OPTION_NUMBERING , METIS_OPTION_DBGLVL","tags":"","loc":"interface/metis_partmeshnodal.html","title":"METIS_PartMeshNodal â€“ Fortran METIS Interface"},{"text":"interface Called By interface~~metis_nodend~~CalledByGraph interface~metis_nodend METIS_NodeND proc~test3 test3 proc~test3->interface~metis_nodend Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public function METIS_NodeND(nvtxs, xadj, adjncy, vwgt, options, perm, iperm) result(ierr) bind(C,name=\"METIS_NodeND\") Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: nvtxs The number of vertices in the graph. integer(kind=c_int), intent(in), dimension(*) :: xadj The adjacency structure of the graph as described in Section 5.5 of the manual . integer(kind=c_int), intent(in), dimension(*) :: adjncy The adjacency structure of the graph as described in Section 5.5 of the manual . integer(kind=c_int), intent(in), optional :: vwgt (nvtxs) An array of size nvtxs specifying the weights of the vertices. integer(kind=c_int), intent(in), optional :: options (METIS_NOPTIONS) This is the array of options as described in Section 5.4 of the manual . See description for valid options. integer(kind=c_int), intent(out) :: perm (nvtxs) Vectors of size nvtxs . Upon successful completion, they store the fill-reducing\n permutation and inverse-permutation. More in the description. integer(kind=c_int), intent(out) :: iperm (nvtxs) Vectors of size nvtxs . Upon successful completion, they store the fill-reducing\n permutation and inverse-permutation. More in the description. Return Value integer(kind=c_int) METIS_OK - Indicates that the function returned normally. METIS_ERROR_INPUT - Indicates an input error. METIS_ERROR_MEMORY - Indicates that it could not allocate the required memory. METIS_ERROR - Indicates some other type of error. Description This function computes fill reducing orderings of sparse matrices using the\n  multilevel nested dissection algorithm. Let A be the original matrix and A' be the permuted matrix. The arrays perm and iperm are defined as follows. Row (column) i of A' is the perm(i) row (column) of A, and row (column) i of A is the iperm(i) row (column) of A'. the numbering of this vector starts from either 0 or 1,\n  depending on the value of options(METIS_OPTION_NUMBERING) . If the graph is weighted, meaning vgwt was provided, the nested dissection ordering computes\n  vertex separators that minimize the sum of the weights of the vertices on the separators. The following options are valid: METIS_OPTION_CTYPE , METIS_OPTION_RTYPE , METIS_OPTION_NO2HOP , METIS_OPTION_NSEPS , METIS_OPTION_NITER , METIS_OPTION_UFACTOR , METIS_OPTION_COMPRESS , METIS_OPTION_CCORDER , METIS_OPTION_SEED , METIS_OPTION_PFACTOR , METIS_OPTION_NUMBERING , METIS_OPTION_DBGLVL Example The code below generates the nodal graph of the following mesh: integer ( c_int ), parameter :: n = 15 , m = 22 integer ( c_int ) :: xadj ( n + 1 ), adjncy ( 2 * m ) integer ( c_int ) :: perm ( n ), iperm ( n ) integer ( c_int ) :: options ( 0 : 39 ), ierr xadj = [ 1 , 3 , 6 , 9 , 12 , 14 , 17 , 21 , 25 , 29 , 32 , 34 , 37 , 40 , 43 , 45 ] adjncy = [ 2 , 6 , 1 , 3 , 7 , 2 , 4 , 8 , 3 , 5 , 9 , 4 , 10 , 1 , 7 , 11 , 2 , 6 , & 8 , 12 , 3 , 7 , 9 , 13 , 4 , 8 , 10 , 14 , 5 , 9 , 15 , 6 , 12 , 7 , 11 , 13 , & 8 , 12 , 14 , 9 , 13 , 15 , 10 , 14 ] ierr = METIS_SetDefaultOptions ( options ) options ( 18 ) = 1 ierr = METIS_NodeND ( n , xadj , adjncy , options = options , perm = perm , iperm = iperm ) end","tags":"","loc":"interface/metis_nodend.html","title":"METIS_NodeND â€“ Fortran METIS Interface"},{"text":"interface public function METIS_MeshToDual(ne, nn, eptr, eind, ncommon, numflag, xadj, adjncy) result(ierr) bind(C,name=\"METIS_MeshToDual\") Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: ne The number of elements in the mesh. integer(kind=c_int), intent(in) :: nn The number of nodes in the mesh. integer(kind=c_int), intent(in), dimension(*) :: eptr The pair of arrays storing the mesh as described in Section 5.6 of the manual . integer(kind=c_int), intent(in), dimension(*) :: eind The pair of arrays storing the mesh as described in Section 5.6 of the manual . integer(kind=c_int), intent(in) :: ncommon The number of common nodes that two elements must have in order to put\n an edge between them in the dual graph. integer(kind=c_int), intent(in) :: numflag Used to indicate which numbering scheme is used for eptr and eind . \n The possible values are: 0 - C-style numbering is assumed that starts from 0 1 - Fortran-style numbering is assumed that starts from 1 type(c_ptr), intent(out) :: xadj These arrays store the adjacency structure of the generated dual graph. \n The format of the adjacency structure is described in Section 5.5 of the manual . type(c_ptr), intent(out) :: adjncy These arrays store the adjacency structure of the generated dual graph. \n The format of the adjacency structure is described in Section 5.5 of the manual . Return Value integer(kind=c_int) METIS_OK - Indicates that the function returned normally. METIS_ERROR_INPUT - Indicates an input error. METIS_ERROR_MEMORY - Indicates that it could not allocate the required memory. METIS_ERROR - Indicates some other type of error. Description This function is used to generate the dual graph of a mesh. Note To use the returned arrays xadj and adjncy , these must be first converted from\n a C pointer to a Fortran pointer using the subroutine c_f_pointer(cptr,fptr,shape) that assigns the target of the C pointer cptr to the Fortran pointer fptr and\n specifies its shape. The shape is an integer rank-one array, storing the size ne+1 in case of the dual graph. The size of the new adjncy array is stored in the \n last element of xadj when using C-style numbering. An example is shown below. Warning Memory for the returned arrays xadj and adjncy is allocated by METIS' API in C\n using the standard malloc function. It is the responsibility of the application to free\n this memory by calling free . Therefore, METIS provides the METIS_Free function that is a wrapper to\n C's free function. Example The code below generates the nodal graph of the following mesh: image use iso_c_binding , only : c_int , c_ptr , c_f_pointer integer ( c_int ), parameter :: ne = 3 , nn = 8 , npel = 4 integer ( c_int ) :: ierr , eptr ( ne + 1 ), eind ( ne * npel ), numflag , ncommon type ( c_ptr ) :: xadj , adjncy integer ( c_int ), dimension (:), pointer :: fxadj => null (), fadjncy => null () numflag = 0 ! C-style numbering ncommon = 2 ! 2 common nodes per edge eptr = [ 0 , 4 , 8 , 12 ] eind = [ 0 , 1 , 2 , 3 , 1 , 4 , 5 , 2 , 4 , 6 , 7 , 5 ] ! note four nodes per element ierr = METIS_MeshToDual ( ne , nn , eptr , eind , ncommon , numflag , xadj , adjncy ) call c_f_pointer ( xadj , fxadj , shape = [ ne + 1 ]) ! xadj is of the size ne+1 call c_f_pointer ( adjncy , fadjncy , shape = [ fxadj ( ne + 1 )]) ! last value in xadj is the size of adjncy !... use values in fxadj and fadjncy ... call METIS_Free ( xadj ) call METIS_Free ( adjncy ) end","tags":"","loc":"interface/metis_meshtodual.html","title":"METIS_MeshToDual â€“ Fortran METIS Interface"},{"text":"interface Called By interface~~metis_meshtonodal~~CalledByGraph interface~metis_meshtonodal METIS_MeshToNodal proc~test1 test1 proc~test1->interface~metis_meshtonodal proc~formetis_meshtonodal ForMETIS_MeshToNodal proc~test1->proc~formetis_meshtonodal proc~formetis_meshtonodal->interface~metis_meshtonodal Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public function METIS_MeshToNodal(ne, nn, eptr, eind, numflag, xadj, adjncy) result(ierr) bind(C,name=\"METIS_MeshToNodal\") Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: ne The number of elements in the mesh. integer(kind=c_int), intent(in) :: nn The number of nodes in the mesh. integer(kind=c_int), intent(in), dimension(*) :: eptr The pair of arrays storing the mesh as described in Section 5.6 of the manual . integer(kind=c_int), intent(in), dimension(*) :: eind The pair of arrays storing the mesh as described in Section 5.6 of the manual . integer(kind=c_int), intent(in) :: numflag Used to indicate which numbering scheme is used for eptr and eind .\n The possible values are: 0 - C-style numbering is assumed that starts from 0 1 - Fortran-style numbering is assumed that starts from 1 type(c_ptr), intent(out) :: xadj These arrays store the adjacency structure of the generated dual graph. \n The format of the adjacency structure is described in Section 5.5 of the manual . type(c_ptr), intent(out) :: adjncy These arrays store the adjacency structure of the generated dual graph. \n The format of the adjacency structure is described in Section 5.5 of the manual . Return Value integer(kind=c_int) METIS_OK - Indicates that the function returned normally. METIS_ERROR_INPUT - Indicates an input error. METIS_ERROR_MEMORY - Indicates that it could not allocate the required memory. METIS_ERROR - Indicates some other type of error. Description This function is used to generate the nodal graph of a mesh. Note To use the returned arrays xadj and adjncy , these must be first converted from\n a C pointer to a Fortran pointer using the subroutine c_f_pointer(cptr,fptr,shape) that assigns the target of the C pointer cptr to the Fortran pointer fptr and\n specifies its shape. The shape is an integer rank-one array, storing the size nn+1 in case of the nodal graph. The size of the new adjncy array is stored in the \n last element of xadj when using C-style numbering. An example is shown below. Warning Memory for the returned arrays xadj and adjncy is allocated by METIS' API in C\n using the standard malloc function. It is the responsibility of the application to free\n this memory by calling free . Therefore, METIS provides the METIS_Free function that is a wrapper to\n C's free function. Example The code below generates the nodal graph of the following mesh: image use iso_c_binding , only : c_int , c_ptr , c_f_pointer integer ( c_int ), parameter :: ne = 3 , nn = 8 , npel = 4 integer ( c_int ) :: ierr , eptr ( ne + 1 ), eind ( ne * npel ), numflag type ( c_ptr ) :: xadj , adjncy integer ( c_int ), dimension (:), pointer :: fxadj => null (), fadjncy => null () numflag = 0 ! C-style numbering eptr = [ 0 , 4 , 8 , 12 ] eind = [ 0 , 1 , 2 , 3 , 1 , 4 , 5 , 2 , 4 , 6 , 7 , 5 ] ! note four nodes per element ierr = METIS_MeshToNodal ( ne , nn , eptr , eind , numflag , xadj , adjncy ) call c_f_pointer ( xadj , fxadj , shape = [ nn + 1 ]) ! xadj is of the size nn+1 call c_f_pointer ( adjncy , fadjncy , shape = [ fxadj ( nn + 1 )]) ! last value in xadj is the size of adjncy !... use values in fxadj and fadjncy ... call METIS_Free ( xadj ) call METIS_Free ( adjncy ) end","tags":"","loc":"interface/metis_meshtonodal.html","title":"METIS_MeshToNodal â€“ Fortran METIS Interface"},{"text":"interface Called By interface~~metis_setdefaultoptions~~CalledByGraph interface~metis_setdefaultoptions METIS_SetDefaultOptions proc~test1 test1 proc~test1->interface~metis_setdefaultoptions proc~test4 test4 proc~test4->interface~metis_setdefaultoptions program~test_fmetis test_fmetis program~test_fmetis->interface~metis_setdefaultoptions proc~test3 test3 proc~test3->interface~metis_setdefaultoptions Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public function METIS_SetDefaultOptions(options) result(ierr) bind(C,name=\"METIS_SetDefaultOptions\") Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(out) :: options (METIS_NOPTIONS) The array of options that will be initialized. Return Value integer(kind=c_int) METIS_OK - Indicates that the function returned normally. Description Initializes the options array into its default values. Note The passed array options must have the size METIS_NOPTIONS (40).\n To be able to use the parameters in the metis_enum module it is recommended to use\n zero-based indexing for the options array: integer ( c_int ) :: opts ( 0 : 39 ) Examples To set Fortran style index-numbering use: integer :: opts ( 0 : 39 ) call METIS_SetDefaultOptions ( opts ) opts ( 17 ) = 1 ! Fortran-style index numbering Other options can be changed using parameters from the metis_enum module. use metis_interface , only : METIS_SetDefaultOptions use metis_enum , only : METIS_OPTION_DBGLVL , METIS_DBG_INFO integer :: opts ( 0 : 39 ) call METIS_SetDefaultOptions ( opts ) opts ( METIS_OPTION_DBGLVL ) = METIS_DBG_INFO ! Show various diagnostic messages end","tags":"","loc":"interface/metis_setdefaultoptions.html","title":"METIS_SetDefaultOptions â€“ Fortran METIS Interface"},{"text":"interface Called By interface~~metis_free~~CalledByGraph interface~metis_free METIS_Free proc~test1 test1 proc~test1->interface~metis_free proc~formetis_meshtonodal ForMETIS_MeshToNodal proc~test1->proc~formetis_meshtonodal proc~formetis_meshtonodal->interface~metis_free Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public function METIS_Free(ptr) result(ierr) bind(C,name=\"METIS_Free\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: ptr The pointer to be freed. This pointer should be one of the xadj or adjncy arrays returned by METIS' API routines. Return Value integer(kind=c_int) METIS_OK - Indicates that the function returned normally. Description Frees the memory that was allocated by either the METIS_MeshToDual or the METIS_MeshToNodal routines for returning the dual or nodal graph of a mesh. Warning Memory deallocation should always happen on the same side it was allocated!\n Also check the descriptions of the above-mentioned routines. Example type ( c_ptr ) :: xadj (:), adjncy (:) call METIS_MeshToNodal (..., xadj , adjncy ) ! Deallocation of arrays allocated in C call METIS_Free ( xadj ) call METIS_Free ( adjncy )","tags":"","loc":"interface/metis_free.html","title":"METIS_Free â€“ Fortran METIS Interface"},{"text":"public function whitechar(char) Arguments Type Intent Optional Attributes Name character, intent(in) :: char Return Value logical Called By proc~~whitechar~~CalledByGraph proc~whitechar whitechar proc~load_graph load_graph proc~load_graph->proc~whitechar proc~count_columns count_columns proc~load_graph->proc~count_columns proc~count_columns->proc~whitechar program~test_fmetis test_fmetis program~test_fmetis->proc~load_graph Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/whitechar.html","title":"whitechar â€“ Fortran METIS Interface"},{"text":"public function count_columns(unit, stat) result(ncol) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit integer, intent(out) :: stat Return Value integer Calls proc~~count_columns~~CallsGraph proc~count_columns count_columns proc~whitechar whitechar proc~count_columns->proc~whitechar Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~count_columns~~CalledByGraph proc~count_columns count_columns proc~load_graph load_graph proc~load_graph->proc~count_columns program~test_fmetis test_fmetis program~test_fmetis->proc~load_graph Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/count_columns.html","title":"count_columns â€“ Fortran METIS Interface"},{"text":"public subroutine write_graph(fname, xadj, adjncy, numflag) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname integer, intent(in) :: xadj (:) integer, intent(in) :: adjncy (:) integer, intent(in) :: numflag Called By proc~~write_graph~~CalledByGraph proc~write_graph write_graph proc~test1 test1 proc~test1->proc~write_graph program~test_fmetis test_fmetis program~test_fmetis->proc~write_graph Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/write_graph.html","title":"write_graph â€“ Fortran METIS Interface"},{"text":"public subroutine load_graph(this, fname, numflag) Arguments Type Intent Optional Attributes Name type( MetisGraph ), intent(out) :: this character(len=*), intent(in) :: fname integer, intent(in) :: numflag Calls proc~~load_graph~~CallsGraph proc~load_graph load_graph proc~whitechar whitechar proc~load_graph->proc~whitechar proc~count_columns count_columns proc~load_graph->proc~count_columns proc~count_columns->proc~whitechar Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~load_graph~~CalledByGraph proc~load_graph load_graph program~test_fmetis test_fmetis program~test_fmetis->proc~load_graph Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/load_graph.html","title":"load_graph â€“ Fortran METIS Interface"},{"text":"public subroutine print_options(opts) Arguments Type Intent Optional Attributes Name integer, intent(in) :: opts (:) Called By proc~~print_options~~CalledByGraph proc~print_options print_options proc~test4 test4 proc~test4->proc~print_options Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/print_options.html","title":"print_options â€“ Fortran METIS Interface"},{"text":"public subroutine ForMETIS_MeshToNodal(ne, nn, eptr, eind, numflag, xadj, adjncy, stat) Uses: iso_c_binding proc~~formetis_meshtonodal~~UsesGraph proc~formetis_meshtonodal ForMETIS_MeshToNodal iso_c_binding iso_c_binding iso_c_binding->proc~formetis_meshtonodal Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Arguments Type Intent Optional Attributes Name integer, intent(in) :: ne integer, intent(in) :: nn integer, intent(in) :: eptr (ne+1) integer, intent(in) :: eind (:) integer, intent(in) :: numflag integer, intent(out), allocatable :: xadj (:) integer, intent(out), allocatable :: adjncy (:) integer, intent(out) :: stat Calls proc~~formetis_meshtonodal~~CallsGraph proc~formetis_meshtonodal ForMETIS_MeshToNodal interface~metis_meshtonodal METIS_MeshToNodal proc~formetis_meshtonodal->interface~metis_meshtonodal interface~metis_free METIS_Free proc~formetis_meshtonodal->interface~metis_free Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~formetis_meshtonodal~~CalledByGraph proc~formetis_meshtonodal ForMETIS_MeshToNodal proc~test1 test1 proc~test1->proc~formetis_meshtonodal Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/formetis_meshtonodal.html","title":"ForMETIS_MeshToNodal â€“ Fortran METIS Interface"},{"text":"public subroutine test1() Uses: iso_c_binding proc~~test1~~UsesGraph proc~test1 test1 iso_c_binding iso_c_binding iso_c_binding->proc~test1 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Arguments None Calls proc~~test1~~CallsGraph proc~test1 test1 interface~metis_meshtonodal METIS_MeshToNodal proc~test1->interface~metis_meshtonodal interface~metis_setdefaultoptions METIS_SetDefaultOptions proc~test1->interface~metis_setdefaultoptions interface~metis_partmeshnodal METIS_PartMeshNodal proc~test1->interface~metis_partmeshnodal proc~formetis_meshtonodal ForMETIS_MeshToNodal proc~test1->proc~formetis_meshtonodal proc~write_graph write_graph proc~test1->proc~write_graph interface~metis_free METIS_Free proc~test1->interface~metis_free proc~formetis_meshtonodal->interface~metis_meshtonodal proc~formetis_meshtonodal->interface~metis_free Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/test1.html","title":"test1 â€“ Fortran METIS Interface"},{"text":"public subroutine test2() Uses: iso_c_binding proc~~test2~~UsesGraph proc~test2 test2 iso_c_binding iso_c_binding iso_c_binding->proc~test2 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Arguments None Calls proc~~test2~~CallsGraph proc~test2 test2 interface~metis_partgraphrecursive METIS_PartGraphRecursive proc~test2->interface~metis_partgraphrecursive Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/test2.html","title":"test2 â€“ Fortran METIS Interface"},{"text":"public subroutine test3() Arguments None Calls proc~~test3~~CallsGraph proc~test3 test3 interface~metis_nodend METIS_NodeND proc~test3->interface~metis_nodend interface~metis_setdefaultoptions METIS_SetDefaultOptions proc~test3->interface~metis_setdefaultoptions Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/test3.html","title":"test3 â€“ Fortran METIS Interface"},{"text":"public subroutine test4() Arguments None Calls proc~~test4~~CallsGraph proc~test4 test4 proc~print_options print_options proc~test4->proc~print_options interface~metis_setdefaultoptions METIS_SetDefaultOptions proc~test4->interface~metis_setdefaultoptions interface~metis_partmeshdual METIS_PartMeshDual proc~test4->interface~metis_partmeshdual Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/test4.html","title":"test4 â€“ Fortran METIS Interface"},{"text":"Uses: iso_c_binding module~~metis_interface~~UsesGraph module~metis_interface metis_interface iso_c_binding iso_c_binding iso_c_binding->module~metis_interface Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. A Fortran interface to the METIS graph partitioning library. Used By module~~metis_interface~~UsedByGraph module~metis_interface metis_interface module~metis_io metis_io module~metis_interface->module~metis_io module~metis_tests metis_tests module~metis_interface->module~metis_tests program~test_fmetis test_fmetis module~metis_interface->program~test_fmetis module~metis_io->module~metis_tests module~metis_io->program~test_fmetis Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables METIS_NOPTIONS Interfaces METIS_PartGraphRecursive METIS_PartGraphKway METIS_PartMeshDual METIS_PartMeshNodal METIS_NodeND METIS_MeshToDual METIS_MeshToNodal METIS_SetDefaultOptions METIS_Free Variables Type Visibility Attributes Name Initial integer, public, parameter :: METIS_NOPTIONS = 40 Number of METIS options. Interfaces interface public function METIS_PartGraphRecursive (nvtxs, ncon, xadj, adjncy, vwgt, vsize, adjwgt, nparts, tpwgts, ubvec, options, objval, part) result(ierr) bind(C,name=\"METIS_PartGraphRecursive\") This function is used to partition a graph into nparts parts using recursive bisection. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: nvtxs The number of vertices in the graph. integer(kind=c_int), intent(in) :: ncon The number of balancing constraints. It should be atleast 1. integer(kind=c_int), intent(in), dimension(*) :: xadj The adjacency structure of the graph as described in section 5.5 of the manual . integer(kind=c_int), intent(in), dimension(*) :: adjncy The adjacency structure of the graph as described in section 5.5 of the manual . integer(kind=c_int), intent(in), optional dimension(*) :: vwgt The weights of the vertices as described in Section 5.5 of the manual . integer(kind=c_int), intent(in), optional dimension(*) :: vsize The size of the vertices for computing the total communication volume as described in section 5.7 of the manual . integer(kind=c_int), intent(in), optional dimension(*) :: adjwgt The weights of the edges as describe in Section 5.5 of the manual . integer(kind=c_int), intent(in) :: nparts The number of parts to partition the graph. real(kind=c_double), intent(in), optional :: tpwgts (nparts*ncon) An array of size nparts*ncon that specifies the desired weight for each partition and constraint.\n If not present, the graph is divided equally among the partitions. More in the description. real(kind=c_double), intent(in), optional :: ubvec (ncon) An array of size ncon that specifiew the allowed load imbalance for each constraint. \n For the i -th partition and j -th constraint the allowed weight is the ubvec(j)*tpwgts(i*ncon+j) fraction of the j -th's constraint total weight. If not present, the load imbalance\n tolerance is 1.001 (for ncon = 1 ) or 1.01 (for ncon > 1 ). integer(kind=c_int), intent(in), optional :: options (METIS_NOPTIONS) An array of options as described in Section 5.4 of the METIS manual. See description for valid options. integer(kind=c_int), intent(out) :: objval Upon successful completion, this variable stores the edge-cut or the total communication volume of the partitioning\n solution. The value returned depends on the partitioning's objective function. integer(kind=c_int), intent(out) :: part (nvtxs) This is a vector of size nvtxs that upon successful completion stores the partition vector of the graph.\n The numbering of this vector starts from either 0 or 1, depending on the value of options(METIS_OPTION_NUMBERING) . Return Value integer(kind=c_int) METIS_OK - Indicates that the function returned normally. METIS_ERROR_INPUT - Indicates an input error. METIS_ERROR_MEMORY - Indicates that it could not allocate the required memory. METIS_ERROR - Indicates some other type of error. interface public function METIS_PartGraphKway (nvtxs, ncon, xadj, adjncy, vwgt, vsize, adjwgt, nparts, tpwgts, ubvec, options, objval, part) result(ierr) bind(C,name=\"METIS_PartGraphKway\") This function is used to partition a graph into nparts parts using multilevel k-way partitioning. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: nvtxs The number of vertices in the graph. integer(kind=c_int), intent(in) :: ncon The number of balancing constraints. It should be at least 1. integer(kind=c_int), intent(in), dimension(*) :: xadj The adjacency structure of the graph as described in section 5.5 of the manual . integer(kind=c_int), intent(in), dimension(*) :: adjncy The adjacency structure of the graph as described in section 5.5 of the manual . integer(kind=c_int), intent(in), optional dimension(*) :: vwgt The weights of the vertices as described in Section 5.5 of the manual . integer(kind=c_int), intent(in), optional dimension(*) :: vsize The size of the vertices for computing the total communication volume as described in section 5.7 of the manual . integer(kind=c_int), intent(in), optional dimension(*) :: adjwgt The weights of the edges as describe in Section 5.5 of the manual . integer(kind=c_int), intent(in) :: nparts The number of parts to partition the graph. real(kind=c_double), intent(in), optional :: tpwgts (nparts*ncon) An array of size nparts*ncon that specifies the desired weight for each partition and constraint.\n If not present, the graph is divided equally among the partitions. More in the description. real(kind=c_double), intent(in), optional :: ubvec (ncon) An array of size ncon that specifiew the allowed load imbalance for each constraint. \n For the i -th partition and j -th constraint the allowed weight is the ubvec(j)*tpwgts(i*ncon+j) fraction of the j -th's constraint total weight. If not present, the load imbalance\n tolerance is 1.001 (for ncon == 1 ) or 1.01 (for ncon > 1 ). integer(kind=c_int), intent(in), optional :: options (METIS_NOPTIONS) An array of options as described in Section 5.4 of the manual . See description for valid options. integer(kind=c_int), intent(out) :: objval Upon successful completion, this variable stores the edge-cut or the total communication volume of the partitioning\n solution. The value returned depends on the partitioning's objective function. integer(kind=c_int), intent(out) :: part (nvtxs) This is a vector of size nvtxs that upon successful completion stores the partition vector of the graph.\n The numbering of this vector starts from either 0 or 1, depending on the value of options(METIS_OPTION_NUMBERING) . Return Value integer(kind=c_int) METIS_OK - Indicates that the function returned normally. METIS_ERROR_INPUT - Indicates an input error. METIS_ERROR_MEMORY - Indicates that it could not allocate the required memory. METIS_ERROR - Indicates some other type of error. interface public function METIS_PartMeshDual (ne, nn, eptr, eind, vwgt, vsize, ncommon, nparts, tpwgts, options, objval, epart, npart) result(ierr) bind(C,name=\"METIS_PartMeshDual\") This function is used to partition a mesh into nparts parts based on a partitioning of the mesh's dual graph. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: ne The number of elements in the mesh. integer(kind=c_int), intent(in) :: nn The number of nodes in the mesh. integer(kind=c_int), intent(in), dimension(*) :: eptr The pair of arrays storing the mesh as described in Section 5.6 of the manual . integer(kind=c_int), intent(in), dimension(*) :: eind The pair of arrays storing the mesh as described in Section 5.6 of the manual . integer(kind=c_int), intent(in), optional :: vwgt (ne) An array of size ne specifying the weights of the elements. If not present,\n all elements have an equal weight. integer(kind=c_int), intent(in), optional :: vsize (ne) An array of size ne specifying the size of the elements that is used\n for computing the total comunication volume as described in Section 5.7 of the manual .\n If not present, the objective is cut or all elements have an equal size. integer(kind=c_int), intent(in) :: ncommon integer(kind=c_int), intent(in) :: nparts The number of parts to partition the mesh. integer(kind=c_int), intent(in), optional :: tpwgts (nparts) An array of size nparts that specifies the desired weight for each partition. The target\n partition weight for the i -th partition is specified at tpwgts(i) (the numbering for the \n partitions starts from 0). The sum of the tpwgts entries must be 1.0. If not present, the graph\n is divided equally among the partitions. integer(kind=c_int), intent(in), optional :: options (METIS_NOPTIONS) An array of options as described in Section 5.4 of the manual . See description for valid options. integer(kind=c_int), intent(out) :: objval Upon successful completion, this variable stores either the edgecut or the total communication\n volume of the dual graph's partitioning. integer(kind=c_int), intent(out) :: epart (ne) A vector of size ne that upon successful completion stores the partition vector for the elements\n of the mesh. The numbering of this vector starts from either 0 or 1, depending on the value of options(METIS_OPTION_NUMBERING) . integer(kind=c_int), intent(out) :: npart (nn) A vector of size nn that upon successful completion stores the partition vector for the nodes \n of the mesh. The numbering of this vector starts from either 0 or 1, depending on the value of options(METIS_OPTION_NUMBERING) . Return Value integer(kind=c_int) METIS_OK - Indicates that the function returned normally. METIS_ERROR_INPUT - Indicates an input error. METIS_ERROR_MEMORY - Indicates that it could not allocate the required memory. METIS_ERROR - Indicates some other type of error. interface public function METIS_PartMeshNodal (ne, nn, eptr, eind, vwgt, vsize, nparts, tpwgts, options, objval, epart, npart) result(ierr) bind(C,name=\"METIS_PartMeshNodal\") This function us used to partition a mesh into nparts parts based on a \n  partitioning of the mesh's nodal graph. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: ne The number of elements in the mesh. integer(kind=c_int), intent(in) :: nn The number of nodes in the mesh. integer(kind=c_int), intent(in), dimension(*) :: eptr The pair of arrays storing the mesh as described in Section 5.6 of the manual . integer(kind=c_int), intent(in), dimension(*) :: eind The pair of arrays storing the mesh as described in Section 5.6 of the manual . integer(kind=c_int), intent(in), optional :: vwgt (nn) An array of size nn specifying weights of the nodes. If not passed, all nodes have an equal weight. integer(kind=c_int), intent(in), optional :: vsize (nn) An array of size nn specifying the size of the nodes that is used for computing the\n total comunication volume as described in Section 5.7 of the manual . If not passed,\n the objective is cut or all nodes have an equal size. integer(kind=c_int), intent(in) :: nparts The number of parts to partition the mesh. integer(kind=c_int), intent(in), optional :: tpwgts (nparts) An array of size nparts that specifies the desired weight for each partition. The target\n partition weight for the i -th partition is specified at tpwgts(i) (the numbering for the \n partitions starts from 0). The sum of the tpwgts entries must be 1.0. If not passed, the graph\n is divided equally among the partitions. integer(kind=c_int), intent(in), optional :: options (METIS_NOPTIONS) An array of options as described in Section 5.4 of the manual . See description for valid options. integer(kind=c_int), intent(out) :: objval Upon successful completion, this variable stores either the edgecut or the total communication\n volume of the nodal graph's partitioning. integer(kind=c_int), intent(out) :: epart (ne) A vector of size ne that upon successful completion stores the partition vector for the elements\n of the mesh. The numbering of this vector starts from either 0 or 1, depending on the value of options(METIS_OPTION_NUMBERING) . integer(kind=c_int), intent(out) :: npart (nn) A vector of size nn that upon successful completion stores the partition vector for the nodes \n of the mesh. The numbering of this vector starts from either 0 or 1, depending on the value of options(METIS_OPTION_NUMBERING) . Return Value integer(kind=c_int) METIS_OK - Indicates that the function returned normally. METIS_ERROR_INPUT - Indicates an input error. METIS_ERROR_MEMORY - Indicates that it could not allocate the required memory. METIS_ERROR - Indicates some other type of error. interface public function METIS_NodeND (nvtxs, xadj, adjncy, vwgt, options, perm, iperm) result(ierr) bind(C,name=\"METIS_NodeND\") This function computes fill reducing orderings of sparse matrices using the\n  multilevel nested dissection algorithm. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: nvtxs The number of vertices in the graph. integer(kind=c_int), intent(in), dimension(*) :: xadj The adjacency structure of the graph as described in Section 5.5 of the manual . integer(kind=c_int), intent(in), dimension(*) :: adjncy The adjacency structure of the graph as described in Section 5.5 of the manual . integer(kind=c_int), intent(in), optional :: vwgt (nvtxs) An array of size nvtxs specifying the weights of the vertices. integer(kind=c_int), intent(in), optional :: options (METIS_NOPTIONS) This is the array of options as described in Section 5.4 of the manual . See description for valid options. integer(kind=c_int), intent(out) :: perm (nvtxs) Vectors of size nvtxs . Upon successful completion, they store the fill-reducing\n permutation and inverse-permutation. More in the description. integer(kind=c_int), intent(out) :: iperm (nvtxs) Vectors of size nvtxs . Upon successful completion, they store the fill-reducing\n permutation and inverse-permutation. More in the description. Return Value integer(kind=c_int) METIS_OK - Indicates that the function returned normally. METIS_ERROR_INPUT - Indicates an input error. METIS_ERROR_MEMORY - Indicates that it could not allocate the required memory. METIS_ERROR - Indicates some other type of error. interface public function METIS_MeshToDual (ne, nn, eptr, eind, ncommon, numflag, xadj, adjncy) result(ierr) bind(C,name=\"METIS_MeshToDual\") This function is used to generate the dual graph of a mesh. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: ne The number of elements in the mesh. integer(kind=c_int), intent(in) :: nn The number of nodes in the mesh. integer(kind=c_int), intent(in), dimension(*) :: eptr The pair of arrays storing the mesh as described in Section 5.6 of the manual . integer(kind=c_int), intent(in), dimension(*) :: eind The pair of arrays storing the mesh as described in Section 5.6 of the manual . integer(kind=c_int), intent(in) :: ncommon The number of common nodes that two elements must have in order to put\n an edge between them in the dual graph. integer(kind=c_int), intent(in) :: numflag Used to indicate which numbering scheme is used for eptr and eind . \n The possible values are: 0 - C-style numbering is assumed that starts from 0 1 - Fortran-style numbering is assumed that starts from 1 type(c_ptr), intent(out) :: xadj These arrays store the adjacency structure of the generated dual graph. \n The format of the adjacency structure is described in Section 5.5 of the manual . type(c_ptr), intent(out) :: adjncy These arrays store the adjacency structure of the generated dual graph. \n The format of the adjacency structure is described in Section 5.5 of the manual . Return Value integer(kind=c_int) METIS_OK - Indicates that the function returned normally. METIS_ERROR_INPUT - Indicates an input error. METIS_ERROR_MEMORY - Indicates that it could not allocate the required memory. METIS_ERROR - Indicates some other type of error. interface public function METIS_MeshToNodal (ne, nn, eptr, eind, numflag, xadj, adjncy) result(ierr) bind(C,name=\"METIS_MeshToNodal\") This function is used to generate the nodal graph of a mesh. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: ne The number of elements in the mesh. integer(kind=c_int), intent(in) :: nn The number of nodes in the mesh. integer(kind=c_int), intent(in), dimension(*) :: eptr The pair of arrays storing the mesh as described in Section 5.6 of the manual . integer(kind=c_int), intent(in), dimension(*) :: eind The pair of arrays storing the mesh as described in Section 5.6 of the manual . integer(kind=c_int), intent(in) :: numflag Used to indicate which numbering scheme is used for eptr and eind .\n The possible values are: 0 - C-style numbering is assumed that starts from 0 1 - Fortran-style numbering is assumed that starts from 1 type(c_ptr), intent(out) :: xadj These arrays store the adjacency structure of the generated dual graph. \n The format of the adjacency structure is described in Section 5.5 of the manual . type(c_ptr), intent(out) :: adjncy These arrays store the adjacency structure of the generated dual graph. \n The format of the adjacency structure is described in Section 5.5 of the manual . Return Value integer(kind=c_int) METIS_OK - Indicates that the function returned normally. METIS_ERROR_INPUT - Indicates an input error. METIS_ERROR_MEMORY - Indicates that it could not allocate the required memory. METIS_ERROR - Indicates some other type of error. interface public function METIS_SetDefaultOptions (options) result(ierr) bind(C,name=\"METIS_SetDefaultOptions\") Initializes the options array into its default values. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(out) :: options (METIS_NOPTIONS) The array of options that will be initialized. Return Value integer(kind=c_int) METIS_OK - Indicates that the function returned normally. interface public function METIS_Free (ptr) result(ierr) bind(C,name=\"METIS_Free\") Frees the memory that was allocated by either the METIS_MeshToDual or the METIS_MeshToNodal routines for returning the dual or nodal graph of a mesh. Arguments Type Intent Optional Attributes Name type(c_ptr), value :: ptr The pointer to be freed. This pointer should be one of the xadj or adjncy arrays returned by METIS' API routines. Return Value integer(kind=c_int) METIS_OK - Indicates that the function returned normally.","tags":"","loc":"module/metis_interface.html","title":"metis_interface â€“ Fortran METIS Interface"},{"text":"Used By module~~metis_enum~~UsedByGraph module~metis_enum metis_enum module~metis_io metis_io module~metis_enum->module~metis_io program~test_fmetis test_fmetis module~metis_enum->program~test_fmetis module~metis_io->program~test_fmetis module~metis_tests metis_tests module~metis_io->module~metis_tests Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables METIS_OK METIS_ERROR_INPUT METIS_ERROR_MEMORY METIS_ERROR METIS_OPTION_PTYPE METIS_OPTION_OBJTYPE METIS_OPTION_CTYPE METIS_OPTION_IPTYPE METIS_OPTION_RTYPE METIS_OPTION_DBGLVL METIS_OPTION_NITER METIS_OPTION_NCUTS METIS_OPTION_SEED METIS_OPTION_NO2HOP METIS_OPTION_MINCONN METIS_OPTION_CONTIG METIS_OPTION_COMPRESS METIS_OPTION_CCORDER METIS_OPTION_PFACTOR METIS_OPTION_NSEPS METIS_OPTION_UFACTOR METIS_OPTION_NUMBERING METIS_PTYPE_RB METIS_PTYPE_KWAY METIS_CTYPE_RM METIS_CTYPE_SHEM METIS_IPTYPE_GROW METIS_IPTYPE_RANDOM METIS_IPTYPE_EDGE METIS_IPTYPE_NODE METIS_IPTYPE_METISRB METIS_RTYPE_FM METIS_RTYPE_GREEDY METIS_RTYPE_SEP2SIDED METIS_RTYPE_SEP1SIDED METIS_DBG_INFO METIS_DBG_TIME METIS_DBG_COARSEN METIS_DBG_REFINE METIS_DBG_IPART METIS_DBG_MOVEINFO METIS_DBG_SEPINFO METIS_DBG_CONNINFO METIS_DBG_CONTIGINFO METIS_DBG_MEMORY METIS_OBJTYPE_CUT METIS_OBJTYPE_VOL METIS_OBJTYPE_NODE Variables Type Visibility Attributes Name Initial integer, public, parameter :: METIS_OK = 1 Returned normally. integer, public, parameter :: METIS_ERROR_INPUT = -2 Returned due to erroneous inputs and/or options. integer, public, parameter :: METIS_ERROR_MEMORY = -3 Returned due to insufficient memory. integer, public, parameter :: METIS_ERROR = -4 Return status: some other type of error. integer, public, parameter :: METIS_OPTION_PTYPE = 0 Specifies the partitioning method. integer, public, parameter :: METIS_OPTION_OBJTYPE = 1 Specifies the type of objective. integer, public, parameter :: METIS_OPTION_CTYPE = 2 Specifies the matching scheme to be used during coarsening. integer, public, parameter :: METIS_OPTION_IPTYPE = 3 Determines the algorithm used during initial partitioning. integer, public, parameter :: METIS_OPTION_RTYPE = 4 Determines the algorithm used for refinement. integer, public, parameter :: METIS_OPTION_DBGLVL = 5 Specifies the amount of progress/debugging information will be printed. integer, public, parameter :: METIS_OPTION_NITER = 6 Specifies the number of iterations for the refinement algorithm. integer, public, parameter :: METIS_OPTION_NCUTS = 7 Specifies the number of different partitionings that it will compute. integer, public, parameter :: METIS_OPTION_SEED = 8 Specifies the seed for the random number generator. integer, public, parameter :: METIS_OPTION_NO2HOP = 9 Specifies that the coarsening will not perform any 2â€“hop matchings when the standard matching approach fails to sufficiently coarsen the graph. integer, public, parameter :: METIS_OPTION_MINCONN = 10 Specifies that the partitioning routines should try to minimize the maximum degree of the subdomain graph. integer, public, parameter :: METIS_OPTION_CONTIG = 11 Specifies that the partitioning routines should try to produce partitions that are contigous. integer, public, parameter :: METIS_OPTION_COMPRESS = 12 Specifies that the graph should be compressed by combining together vertices that have identical adjacency lists. integer, public, parameter :: METIS_OPTION_CCORDER = 13 Specifies if the connected components of the graph should first be identifies and ordered separately. integer, public, parameter :: METIS_OPTION_PFACTOR = 14 Specifies the minimum degree of the vertices that will be ordered last. integer, public, parameter :: METIS_OPTION_NSEPS = 15 Specifies the number of different separators that it will compute at each level of nested dissection. integer, public, parameter :: METIS_OPTION_UFACTOR = 16 Specifies the maximum allowed load imbalance among the partitions. integer, public, parameter :: METIS_OPTION_NUMBERING = 17 Used to indicate which numbering scheme is used for the adjacency structure of a graph or the element-node structure of a mesh integer, public, parameter :: METIS_PTYPE_RB = 0 Multilevel recursive bisectioning. integer, public, parameter :: METIS_PTYPE_KWAY = 1 Multilevel k-way partitioning. integer, public, parameter :: METIS_CTYPE_RM = 0 Random matching. integer, public, parameter :: METIS_CTYPE_SHEM = 1 sorted heavy-edge matching. integer, public, parameter :: METIS_IPTYPE_GROW = 0 Grows a bisection using a greedy strategy. integer, public, parameter :: METIS_IPTYPE_RANDOM = 1 Computes a bisection at random followed by a refinement. integer, public, parameter :: METIS_IPTYPE_EDGE = 2 Derives a separator form an edge cut. integer, public, parameter :: METIS_IPTYPE_NODE = 3 Grows a bisection using a greedy node-based strategy. integer, public, parameter :: METIS_IPTYPE_METISRB = 4 integer, public, parameter :: METIS_RTYPE_FM = 0 FM-based cut refinement. integer, public, parameter :: METIS_RTYPE_GREEDY = 1 Greedy-based cut and volume refinement. integer, public, parameter :: METIS_RTYPE_SEP2SIDED = 2 Two-sided node FM refinement. integer, public, parameter :: METIS_RTYPE_SEP1SIDED = 3 One-sided node FM refinement. integer, public, parameter :: METIS_DBG_INFO = 1 Shows various diagnostic messages. integer, public, parameter :: METIS_DBG_TIME = 2 Perform timing analysis. integer, public, parameter :: METIS_DBG_COARSEN = 4 Show the coarsening progress. integer, public, parameter :: METIS_DBG_REFINE = 8 Show the refinement progress. integer, public, parameter :: METIS_DBG_IPART = 16 Show info on initial partitioning. integer, public, parameter :: METIS_DBG_MOVEINFO = 32 Show info on vertex moves during refinement. integer, public, parameter :: METIS_DBG_SEPINFO = 64 Show info on vertex moves during sep refinement. integer, public, parameter :: METIS_DBG_CONNINFO = 128 Show info on minimization of subdomain connectivity. integer, public, parameter :: METIS_DBG_CONTIGINFO = 256 Show info on elimination of connected components. integer, public, parameter :: METIS_DBG_MEMORY = 2048 Show info related to wspace allocation. integer, public, parameter :: METIS_OBJTYPE_CUT = 0 Edge-cut minimization. integer, public, parameter :: METIS_OBJTYPE_VOL = 1 Total communication volume minimization. integer, public, parameter :: METIS_OBJTYPE_NODE = 2","tags":"","loc":"module/metis_enum.html","title":"metis_enum â€“ Fortran METIS Interface"},{"text":"Uses: metis_interface metis_enum module~~metis_io~~UsesGraph module~metis_io metis_io module~metis_interface metis_interface module~metis_interface->module~metis_io module~metis_enum metis_enum module~metis_enum->module~metis_io iso_c_binding iso_c_binding iso_c_binding->module~metis_interface Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Used By module~~metis_io~~UsedByGraph module~metis_io metis_io module~metis_tests metis_tests module~metis_io->module~metis_tests program~test_fmetis test_fmetis module~metis_io->program~test_fmetis Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types MetisGraph Functions whitechar count_columns Subroutines write_graph load_graph print_options ForMETIS_MeshToNodal Derived Types type, public :: MetisGraph Components Type Visibility Attributes Name Initial integer, public :: nvtxs integer, public :: nedgs integer, public, allocatable :: xadj (:) integer, public, allocatable :: adjncy (:) Functions public function whitechar (char) Arguments Type Intent Optional Attributes Name character, intent(in) :: char Return Value logical public function count_columns (unit, stat) result(ncol) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit integer, intent(out) :: stat Return Value integer Subroutines public subroutine write_graph (fname, xadj, adjncy, numflag) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname integer, intent(in) :: xadj (:) integer, intent(in) :: adjncy (:) integer, intent(in) :: numflag public subroutine load_graph (this, fname, numflag) Arguments Type Intent Optional Attributes Name type( MetisGraph ), intent(out) :: this character(len=*), intent(in) :: fname integer, intent(in) :: numflag public subroutine print_options (opts) Arguments Type Intent Optional Attributes Name integer, intent(in) :: opts (:) public subroutine ForMETIS_MeshToNodal (ne, nn, eptr, eind, numflag, xadj, adjncy, stat) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ne integer, intent(in) :: nn integer, intent(in) :: eptr (ne+1) integer, intent(in) :: eind (:) integer, intent(in) :: numflag integer, intent(out), allocatable :: xadj (:) integer, intent(out), allocatable :: adjncy (:) integer, intent(out) :: stat","tags":"","loc":"module/metis_io.html","title":"metis_io â€“ Fortran METIS Interface"},{"text":"Uses: metis_interface metis_io module~~metis_tests~~UsesGraph module~metis_tests metis_tests module~metis_io metis_io module~metis_io->module~metis_tests module~metis_interface metis_interface module~metis_interface->module~metis_tests module~metis_interface->module~metis_io module~metis_enum metis_enum module~metis_enum->module~metis_io iso_c_binding iso_c_binding iso_c_binding->module~metis_interface Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Subroutines test1 test2 test3 test4 Subroutines public subroutine test1 () Arguments None public subroutine test2 () Arguments None public subroutine test3 () Arguments None public subroutine test4 () Arguments None","tags":"","loc":"module/metis_tests.html","title":"metis_tests â€“ Fortran METIS Interface"},{"text":"Uses: iso_c_binding metis_interface metis_enum metis_io program~~test_fmetis~~UsesGraph program~test_fmetis test_fmetis module~metis_io metis_io module~metis_io->program~test_fmetis module~metis_enum metis_enum module~metis_enum->program~test_fmetis module~metis_enum->module~metis_io iso_c_binding iso_c_binding iso_c_binding->program~test_fmetis module~metis_interface metis_interface iso_c_binding->module~metis_interface module~metis_interface->program~test_fmetis module~metis_interface->module~metis_io Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Calls program~~test_fmetis~~CallsGraph program~test_fmetis test_fmetis interface~metis_setdefaultoptions METIS_SetDefaultOptions program~test_fmetis->interface~metis_setdefaultoptions proc~load_graph load_graph program~test_fmetis->proc~load_graph proc~write_graph write_graph program~test_fmetis->proc~write_graph interface~metis_partgraphkway METIS_PartGraphKway program~test_fmetis->interface~metis_partgraphkway test2 test2 program~test_fmetis->test2 test1 test1 program~test_fmetis->test1 test3 test3 program~test_fmetis->test3 test4 test4 program~test_fmetis->test4 proc~whitechar whitechar proc~load_graph->proc~whitechar proc~count_columns count_columns proc~load_graph->proc~count_columns proc~count_columns->proc~whitechar Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Variables mgraph xadj adjncy part options ios ncon objval Variables Type Attributes Name Initial type(MetisGraph) :: mgraph integer, allocatable :: xadj (:) integer, allocatable :: adjncy (:) integer, allocatable :: part (:) integer(kind=c_int) :: options (40) integer(kind=c_int) :: ios integer(kind=c_int) :: ncon integer(kind=c_int) :: objval","tags":"","loc":"program/test_fmetis.html","title":"test_fmetis â€“ Fortran METIS Interface"}]}